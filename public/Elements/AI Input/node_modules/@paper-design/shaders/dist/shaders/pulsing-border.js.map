{
  "version": 3,
  "sources": ["../../src/shaders/pulsing-border.ts"],
  "sourcesContent": ["import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, colorBandingFix } from '../shader-utils';\n\nexport const pulsingBorderMeta = {\n  maxColorCount: 5,\n  maxSpotsPerColor: 5,\n} as const;\n\n/**\n * Pulsing Border Pattern with Smoke Effect\n * This shader creates a rounded border mask with multiple color spots\n * traveling along the border\n *\n * Uniforms include:\n * u_colorBack   - The background color of the pattern\n * u_colors      - An array of colors for the pulsing spots (with up to `u_colorsCount` entries)\n * u_colorsCount - The number of colors used in the pattern\n * u_roundness   - The roundness of the border corners\n * u_thickness   - The thickness of the border\n * u_softness    - The blur around the border edges\n * u_intensity   - The intensity multiplier for the pulsing effect\n * u_spotSize    - The size of the color spots\n * u_spotsPerColor - The number of spots for each color (not all the spots are visible all the time)\n * u_pulse     - A multiplier for the pulsing strength (pulsing signal taken from the u_pulseTexture)\n * u_smoke       - The strength of the smoke effect (the noise aroung the border)\n */\n\nexport const pulsingBorderFragmentShader: string = `#version 300 es\nprecision lowp float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${pulsingBorderMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_roundness;\nuniform float u_thickness;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_spotSize;\nuniform float u_spotsPerColor;\nuniform float u_pulse;\nuniform float u_smoke;\nuniform float u_smokeSize;\n\nuniform sampler2D u_pulseTexture;\nuniform sampler2D u_noiseTexture;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n\nfloat roundedBox(vec2 uv, vec2 halfSize, float radius, float distance, float edgeSoftness) {\n    \n    float borderDistance = abs(distance) - .5 * u_thickness;\n    float border = 1. - smoothstep(-.5 * edgeSoftness, .5 * edgeSoftness, borderDistance);\n    border *= border;\n\n    vec2 v0 = uv + halfSize;\n    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);\n    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);\n    vec2 v3 = uv - halfSize;\n    \n    float mult = (.07 - .25 * radius);\n    float m0 = mult * clamp(pow(1. - abs(v0.x - v0.y), 20.), 0., 1.);\n    float m1 = mult * clamp(pow(1. - abs(v1.x + v1.y), 20.), 0., 1.);\n    float m2 = mult * clamp(pow(1. - abs(v2.x + v2.y), 20.), 0., 1.);\n    float m3 = mult * clamp(pow(1. - abs(v3.x - v3.y), 20.), 0., 1.);\n    \n    float l = edgeSoftness * .5 + .75 * u_thickness;\n    float fade0 = 1. - clamp(length(v0) / l, 0., 1.);\n    float fade1 = 1. - clamp(length(v1) / l, 0., 1.);\n    float fade2 = 1. - clamp(length(v2) / l, 0., 1.);\n    float fade3 = 1. - clamp(length(v3) / l, 0., 1.);\n    \n    m0 *= fade0;\n    m1 *= fade1;\n    m2 *= fade2;\n    m3 *= fade3;\n    \n    float fillFix = m0 + m1 + m2 + m3;\n    fillFix *= step(distance, 0.);\n    fillFix *= (1. + 3. * u_thickness);\n    fillFix *= (1.5 - .5 * smoothstep(0., .5, edgeSoftness));\n    fillFix = clamp(fillFix, 0., 1.);\n\n    return border + fillFix;\n}\n\nfloat roundedBoxSmoke(vec2 uv, vec2 halfSize, float radius, float distance, float size) {\n    float borderDistance = abs(distance);\n    float border = 1. - smoothstep(-.75 * size, .75 * size, borderDistance);\n    border *= border;\n\n    vec2 v0 = uv + halfSize;\n    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);\n    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);\n    vec2 v3 = uv - halfSize;\n    \n    float l_mask = .5;\n    float mask = smoothstep(0., 1., length(v0) / l_mask);\n    mask *= smoothstep(0., 1., length(v1) / l_mask);\n    mask *= smoothstep(0., 1., length(v2) / l_mask);\n    mask *= smoothstep(0., 1., length(v3) / l_mask);\n\n    return border * mask;\n}\n\nvec2 rand(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, uv).gb;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = rand(i).x;\n  float b = rand(i + vec2(1.0, 0.0)).x;\n  float c = rand(i + vec2(0.0, 1.0)).x;\n  float d = rand(i + vec2(1.0, 1.0)).x;\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat getWaveformValue(float time) {\n  float dur = 5.;\n  float wrappedTime = mod(time, dur);\n  float normalizedTime = wrappedTime / dur;\n  float value = texture(u_pulseTexture, vec2(normalizedTime, 0.5)).r;\n  return value * 2. - 1.;\n}\n\nvoid main() {\n\n  float t = .5 * u_time + 20.;\n  \n  vec2 borderUV = v_responsiveUV;\n\n  float angle = atan(borderUV.y, borderUV.x) / TWO_PI;\n  \n  \n  float borderRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  borderUV.x *= borderRatio;\n  vec2 halfSize = vec2(.5);\n  halfSize.x *= borderRatio;\n  float radius = min(.5 * u_roundness, halfSize.x);\n  vec2 d = abs(borderUV) - halfSize + radius;\n  float outsideDistance = length(max(d, 0.)) - radius;\n  float insideDistance = min(max(d.x, d.y), 0.0);\n  float distance = outsideDistance + insideDistance;\n    \n  float border = roundedBox(borderUV, halfSize, radius, distance, .5 * u_softness);\n\n  float pulse = u_pulse * getWaveformValue(.18 * u_time);\n  \n  border *= (1. + .1 * pulse);\n  border *= (1. + u_intensity);\n\n  vec2 smokeUV = .001 * u_smokeSize * v_patternUV;\n  float smoke = clamp(3. * noise(2.7 * smokeUV + .5 * t), 0., 1.);\n  smoke -= noise(3.4 * smokeUV - .5 * t);\n  smoke *= roundedBoxSmoke(borderUV, halfSize, radius, distance, u_smoke);\n  smoke = 50. * pow(smoke, 2.);\n  smoke *= u_smoke;\n  smoke *= (.8 + .4 * pulse);\n  smoke = clamp(smoke, 0., 1.);\n\n  border += smoke;\n\n  float sectorsTotal = 0.;\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  \n  vec3 accumColor = vec3(0.);\n  float accumAlpha = 0.;\n  \n  for (int i = 0; i < ${pulsingBorderMeta.maxSpotsPerColor}; i++) {\n    if (i >= int(u_spotsPerColor)) break;\n    float idx = float(i);\n  \n    for (int j = 0; j < ${pulsingBorderMeta.maxColorCount}; j++) {\n      if (j >= int(u_colorsCount)) break;\n      float colorIdx = float(j);\n\n      vec2 randVal = rand(vec2(idx * 10. + 2., 40. + colorIdx));\n  \n      float time = (.1 + .15 * abs(sin(idx * (2. + colorIdx)) * cos(idx * (2. + 2.5 * colorIdx)))) * t + randVal.x * 3.;\n      time *= mix(1., -1., step(.5, randVal.y));\n  \n      float mask = .2 + mix(\n        sin(t + idx * (5. - 1.5 * colorIdx)),\n        cos(t + idx * (3. + 1.3 * colorIdx)),\n        step(mod(colorIdx, 2.), .5)\n      );\n      \n      mask += pulse;\n      if (mask < 0.) continue;\n  \n      float atg1 = fract(angle + time);\n      float sector = smoothstep(.5 - u_spotSize, .5, atg1) * smoothstep(.5 + u_spotSize, .5, atg1);\n      sector *= border;\n      sector *= mask;\n      sector = clamp(sector, 0., 1.);\n      \n      sectorsTotal += sector;\n      \n      float alpha = sector * u_colors[j].a;\n      accumColor += u_colors[j].rgb * alpha;\n      accumAlpha += alpha;\n    }\n  }\n  \n  color = accumColor;\n  opacity = clamp(accumAlpha, 0., 1.);\n  \n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n  \n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PulsingBorderUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_roundness: number;\n  u_thickness: number;\n  u_softness: number;\n  u_intensity: number;\n  u_spotsPerColor: number;\n  u_spotSize: number;\n  u_pulse: number;\n  u_smoke: number;\n  u_smokeSize: number;\n  u_pulseTexture?: HTMLImageElement;\n}\n\nexport interface PulsingBorderParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  roundness?: number;\n  thickness?: number;\n  softness?: number;\n  intensity?: number;\n  spotsPerColor?: number;\n  spotSize?: number;\n  pulse?: number;\n  smoke?: number;\n  smokeSize?: number;\n}\n"],
  "mappings": ";;;;;AAEA,SAAS,kCAAsF;AAC/F,SAAS,WAAW,uBAAuB;AAEpC,MAAM,oBAAoB;AAAA,EAC/B,eAAe;AAAA,EACf,kBAAkB;AACpB;AAqBO,MAAM,8BAAsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAM3B,kBAAkB,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAerD,0BAA0B;AAAA;AAAA;AAAA;AAAA,EAI1B,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAiIa,kBAAkB,gBAAgB;AAAA;AAAA;AAAA;AAAA,0BAIhC,kBAAkB,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAuCrD,eAAe;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
