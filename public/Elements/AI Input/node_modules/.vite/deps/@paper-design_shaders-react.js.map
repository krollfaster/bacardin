{
  "version": 3,
  "sources": ["../../@paper-design/shaders-react/src/shader-mount.tsx", "../../@paper-design/shaders/src/shader-mount.ts", "../../@paper-design/shaders/src/shader-sizing.ts", "../../@paper-design/shaders/src/shader-utils.ts", "../../@paper-design/shaders/src/shaders/mesh-gradient.ts", "../../@paper-design/shaders/src/shaders/smoke-ring.ts", "../../@paper-design/shaders/src/shaders/neuro-noise.ts", "../../@paper-design/shaders/src/shaders/dot-orbit.ts", "../../@paper-design/shaders/src/shaders/dot-grid.ts", "../../@paper-design/shaders/src/shaders/simplex-noise.ts", "../../@paper-design/shaders/src/shaders/metaballs.ts", "../../@paper-design/shaders/src/shaders/perlin-noise.ts", "../../@paper-design/shaders/src/shaders/voronoi.ts", "../../@paper-design/shaders/src/shaders/waves.ts", "../../@paper-design/shaders/src/shaders/warp.ts", "../../@paper-design/shaders/src/shaders/god-rays.ts", "../../@paper-design/shaders/src/shaders/spiral.ts", "../../@paper-design/shaders/src/shaders/swirl.ts", "../../@paper-design/shaders/src/shaders/dithering.ts", "../../@paper-design/shaders/src/shaders/grain-gradient.ts", "../../@paper-design/shaders/src/shaders/liquid-metal.ts", "../../@paper-design/shaders/src/shaders/pulsing-border.ts", "../../@paper-design/shaders/src/get-shader-color-from-string.ts", "../../@paper-design/shaders/src/get-shader-noise-texture.ts", "../../@paper-design/shaders-react/src/use-merge-refs.ts", "../../@paper-design/shaders-react/src/shaders/mesh-gradient.tsx", "../../@paper-design/shaders-react/src/color-props-are-equal.ts", "../../@paper-design/shaders-react/src/shaders/smoke-ring.tsx", "../../@paper-design/shaders-react/src/shaders/neuro-noise.tsx", "../../@paper-design/shaders-react/src/shaders/dot-orbit.tsx", "../../@paper-design/shaders-react/src/shaders/dot-grid.tsx", "../../@paper-design/shaders-react/src/shaders/simplex-noise.tsx", "../../@paper-design/shaders-react/src/shaders/metaballs.tsx", "../../@paper-design/shaders-react/src/shaders/waves.tsx", "../../@paper-design/shaders-react/src/shaders/perlin-noise.tsx", "../../@paper-design/shaders-react/src/shaders/voronoi.tsx", "../../@paper-design/shaders-react/src/shaders/warp.tsx", "../../@paper-design/shaders-react/src/shaders/god-rays.tsx", "../../@paper-design/shaders-react/src/shaders/spiral.tsx", "../../@paper-design/shaders-react/src/shaders/swirl.tsx", "../../@paper-design/shaders-react/src/shaders/dithering.tsx", "../../@paper-design/shaders-react/src/shaders/grain-gradient.tsx", "../../@paper-design/shaders-react/src/shaders/liquid-metal.tsx", "../../@paper-design/shaders-react/src/shaders/pulsing-border.tsx"],
  "sourcesContent": ["'use client';\n\nimport { useEffect, useRef, forwardRef, useState } from 'react';\nimport {\n  ShaderMount as ShaderMountVanilla,\n  type ShaderMotionParams,\n  type ShaderMountUniforms,\n} from '@paper-design/shaders';\nimport { useMergeRefs } from './use-merge-refs';\n\n/** React Shader Mount can also accept strings as uniform values, which will assumed to be URLs and loaded as images */\ninterface ShaderMountUniformsReact {\n  [key: string]: string | boolean | number | number[] | number[][] | HTMLImageElement;\n}\n\nexport interface ShaderMountProps extends Omit<React.ComponentProps<'div'>, 'color'>, ShaderMotionParams {\n  fragmentShader: string;\n  uniforms: ShaderMountUniformsReact;\n  minPixelRatio?: number;\n  maxPixelCount?: number;\n  webGlContextAttributes?: WebGLContextAttributes;\n}\n\nexport interface ShaderComponentProps extends Omit<React.ComponentProps<'div'>, 'color'> {\n  minPixelRatio?: number;\n  maxPixelCount?: number;\n  webGlContextAttributes?: WebGLContextAttributes;\n}\n\n/** Parse the provided uniforms, turning URL strings into loaded images */\nasync function processUniforms(uniformsProp: ShaderMountUniformsReact): Promise<ShaderMountUniforms> {\n  const processedUniforms = {} as ShaderMountUniforms;\n  const imageLoadPromises: Promise<void>[] = [];\n\n  const isValidUrl = (url: string): boolean => {\n    try {\n      // Handle absolute paths\n      if (url.startsWith('/')) return true;\n      // Check if it's a valid URL\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  const isExternalUrl = (url: string): boolean => {\n    try {\n      if (url.startsWith('/')) return false;\n      const urlObject = new URL(url, window.location.origin);\n      return urlObject.origin !== window.location.origin;\n    } catch {\n      return false;\n    }\n  };\n\n  Object.entries(uniformsProp).forEach(([key, value]) => {\n    if (typeof value === 'string') {\n      // Make sure the provided string is a valid URL or just skip trying to set this uniform entirely\n      if (!isValidUrl(value)) {\n        console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n        return;\n      }\n\n      const imagePromise = new Promise<void>((resolve, reject) => {\n        const img = new Image();\n        if (isExternalUrl(value)) {\n          img.crossOrigin = 'anonymous';\n        }\n        img.onload = () => {\n          processedUniforms[key] = img;\n          resolve();\n        };\n        img.onerror = () => {\n          console.error(`Could not set uniforms. Failed to load image at ${value}`);\n          reject();\n        };\n        img.src = value;\n      });\n      imageLoadPromises.push(imagePromise);\n    } else {\n      processedUniforms[key] = value;\n    }\n  });\n\n  await Promise.all(imageLoadPromises);\n  return processedUniforms;\n}\n\n/**\n * A React component that mounts a shader and updates its uniforms as the component's props change\n * If you pass a string as a uniform value, it will be assumed to be a URL and attempted to be loaded as an image\n */\nexport const ShaderMount: React.FC<ShaderMountProps> = forwardRef<HTMLDivElement, ShaderMountProps>(\n  function ShaderMountImpl(\n    {\n      fragmentShader,\n      uniforms: uniformsProp,\n      webGlContextAttributes,\n      speed = 0,\n      frame = 0,\n      minPixelRatio,\n      maxPixelCount,\n      ...divProps\n    },\n    forwardedRef\n  ) {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const divRef = useRef<HTMLDivElement>(null);\n    const shaderMountRef: React.RefObject<ShaderMountVanilla | null> = useRef<ShaderMountVanilla>(null);\n\n    // Initialize the ShaderMountVanilla\n    useEffect(() => {\n      const initShader = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n\n        if (divRef.current && !shaderMountRef.current) {\n          shaderMountRef.current = new ShaderMountVanilla(\n            divRef.current,\n            fragmentShader,\n            uniforms,\n            webGlContextAttributes,\n            speed,\n            frame,\n            minPixelRatio,\n            maxPixelCount\n          );\n\n          setIsInitialized(true);\n        }\n      };\n\n      initShader();\n\n      return () => {\n        shaderMountRef.current?.dispose();\n        shaderMountRef.current = null;\n      };\n    }, [fragmentShader, webGlContextAttributes]);\n\n    // Uniforms\n    useEffect(() => {\n      const updateUniforms = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n        shaderMountRef.current?.setUniforms(uniforms);\n      };\n\n      updateUniforms();\n    }, [uniformsProp, isInitialized]);\n\n    // Speed\n    useEffect(() => {\n      shaderMountRef.current?.setSpeed(speed);\n    }, [speed, isInitialized]);\n\n    // Max Pixel Count\n    useEffect(() => {\n      shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [maxPixelCount, isInitialized]);\n\n    // Min Pixel Ratio\n    useEffect(() => {\n      shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [minPixelRatio, isInitialized]);\n\n    // Frame\n    useEffect(() => {\n      shaderMountRef.current?.setFrame(frame);\n    }, [frame, isInitialized]);\n\n    return <div ref={useMergeRefs([divRef, forwardedRef])} {...divProps} />;\n  }\n);\n\nShaderMount.displayName = 'ShaderMount';\n", "const DEFAULT_MAX_PIXEL_COUNT: number = 1920 * 1080 * 4;\n\nexport class ShaderMount {\n  public parentElement: PaperShaderElement;\n  public canvasElement: HTMLCanvasElement;\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private uniformLocations: Record<string, WebGLUniformLocation | null> = {};\n  /** The fragment shader that we are using */\n  private fragmentShader: string;\n  /** Stores the RAF for the render loop */\n  private rafId: number | null = null;\n  /** Time of the last rendered frame */\n  private lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  private totalFrameTime = 0;\n  /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  private speed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  private providedUniforms: ShaderMountUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  private hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  private resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  private textures: Map<string, WebGLTexture> = new Map();\n  private minPixelRatio;\n  private maxPixelCount;\n  private isSafari = isSafari();\n\n  constructor(\n    /** The div you'd like to mount the shader to. The shader will match its size. */\n    parentElement: HTMLElement,\n    fragmentShader: string,\n    uniforms: ShaderMountUniforms,\n    webGlContextAttributes?: WebGLContextAttributes,\n    /** The speed of the animation, or 0 to stop it. Supports negative values to play in reverse. */\n    speed = 0,\n    /** Pass a frame to offset the starting u_time value and give deterministic results*/\n    frame = 0,\n    /**\n     * The minimum pixel ratio to render at, defaults to 2.\n     * May be reduced to improve performance or increased together with `maxPixelCount` to improve antialiasing.\n     */\n    minPixelRatio = 2,\n    /**\n     * The maximum amount of physical device pixels to render for the shader,\n     * by default it's 1920 * 1080 * 2x dpi (per each side) = 8,294,400 pixels of a 4K screen.\n     * Actual DOM size of the canvas can be larger, it will just lose quality after this.\n     *\n     * May be reduced to improve performance or increased to improve quality on high-resolution screens.\n     */\n    maxPixelCount: number = DEFAULT_MAX_PIXEL_COUNT\n  ) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement as PaperShaderElement;\n    } else {\n      throw new Error('Paper Shaders: parent element must be an HTMLElement');\n    }\n\n    if (!document.querySelector('style[data-paper-shaders]')) {\n      const styleElement = document.createElement('style');\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute('data-paper-shaders', '');\n      document.head.prepend(styleElement);\n    }\n\n    // Create the canvas element and mount it into the provided element\n    const canvasElement = document.createElement('canvas');\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    // Base our starting animation time on the provided frame value\n    this.totalFrameTime = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n\n    const gl = canvasElement.getContext('webgl2', webGlContextAttributes);\n    if (!gl) {\n      throw new Error('Paper Shaders: WebGL is not supported in this browser');\n    }\n    this.gl = gl;\n\n    this.initProgram();\n    this.setupPositionAttribute();\n    // Grab the locations of the uniforms in the fragment shader\n    this.setupUniforms();\n    // Put the user provided values into the uniforms\n    this.setUniformValues(this.providedUniforms);\n    // Set up the resize observer to handle window resizing and set u_resolution\n    this.setupResizeObserver();\n\n    // Set the animation speed after everything is ready to go\n    this.setSpeed(speed);\n\n    // Mark parent element as paper shader mount\n    this.parentElement.setAttribute('data-paper-shaders', '');\n\n    // Add the shaderMount instance to the div mount element to make it easily accessible\n    this.parentElement.paperShaderMount = this;\n  }\n\n  private initProgram = () => {\n    const program = createProgram(this.gl, vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n\n  private setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program!, 'a_position');\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n\n  private setupUniforms = () => {\n    // Create a map to store all uniform locations\n    const uniformLocations: Record<string, WebGLUniformLocation | null> = {\n      u_time: this.gl.getUniformLocation(this.program!, 'u_time'),\n      u_pixelRatio: this.gl.getUniformLocation(this.program!, 'u_pixelRatio'),\n      u_resolution: this.gl.getUniformLocation(this.program!, 'u_resolution'),\n    };\n\n    // Add locations for all provided uniforms\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program!, key);\n\n      // For texture uniforms, also look for the aspect ratio uniform\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}_aspect_ratio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program!, aspectRatioUniformName);\n      }\n    });\n\n    this.uniformLocations = uniformLocations;\n  };\n\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  private renderScale = 1;\n  private parentWidth = 0;\n  private parentHeight = 0;\n\n  private resizeObserver: ResizeObserver | null = null;\n  private setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n\n      this.handleResize();\n    });\n\n    this.resizeObserver.observe(this.parentElement);\n    visualViewport?.addEventListener('resize', this.handleVisualViewportChange);\n\n    const rect = this.parentElement.getBoundingClientRect();\n    this.parentWidth = rect.width;\n    this.parentHeight = rect.height;\n    this.handleResize();\n  };\n\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):\n  // - Frame 1: a paint after the visual viewport resize\n  // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  //\n  // Both resize observer and visual viewport will react to classic browser zoom changes,\n  // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.\n  private resizeRafId: number | null = null;\n  private handleVisualViewportChange = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n\n    this.resizeRafId = requestAnimationFrame(() => {\n      this.resizeRafId = requestAnimationFrame(() => {\n        this.handleResize();\n      });\n    });\n  };\n\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  private handleResize = () => {\n    // Cancel any scheduled resize handlers\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n\n    const pinchZoom = visualViewport?.scale ?? 1;\n\n    // Zoom level can be calculated comparing the browser's outerWidth and the viewport width.\n    // Note: avoid innerWidth, use visualViewport.width instead.\n    // - innerWidth is affected by pinch zoom in Safari, but not other browsers.\n    //   visualViewport.width works consistently in all browsers.\n    // - innerWidth is rounded to integer, but not visualViewport.width.\n    const innerWidth = visualViewport ? visualViewport.width * visualViewport.scale : window.innerWidth;\n\n    // Slight rounding here helps the <canvas> maintain a consistent computed size as the zoom level changes\n    const classicZoom = Math.round((10000 * window.outerWidth) / innerWidth) / 10000;\n\n    // As of 2025, Safari reports physical devicePixelRatio, but other browsers add the current zoom level\n    // https://bugs.webkit.org/show_bug.cgi?id=124862\n    const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;\n    const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);\n    const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;\n    const targetPixelWidth = this.parentWidth * targetRenderScale;\n    const targetPixelHeight = this.parentHeight * targetRenderScale;\n\n    // Prevent the total rendered pixel count from exceeding maxPixelCount\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n\n    const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(this.parentWidth * newRenderScale);\n    const newHeight = Math.round(this.parentHeight * newRenderScale);\n\n    if (\n      this.canvasElement.width !== newWidth ||\n      this.canvasElement.height !== newHeight ||\n      this.renderScale !== newRenderScale // Usually, only render scale change when the user zooms in/out\n    ) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n\n      // this is necessary to avoid flashes while resizing (the next scheduled render will set uniforms)\n      this.render(performance.now());\n    }\n  };\n\n  private render = (currentTime: number) => {\n    if (this.hasBeenDisposed) return;\n\n    if (this.program === null) {\n      console.warn('Tried to render before program or gl was initialized');\n      return;\n    }\n\n    // Calculate the delta time\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    // Increase the total animation time by dt * animationSpeed\n    if (this.speed !== 0) {\n      this.totalFrameTime += dt * this.speed;\n    }\n\n    // Clear the canvas\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Update uniforms\n    this.gl.useProgram(this.program);\n\n    // Update the time uniform\n    this.gl.uniform1f(this.uniformLocations.u_time!, this.totalFrameTime * 0.001);\n\n    // If the resolution has changed, we need to update the uniform\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution!, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio!, this.renderScale);\n      this.resolutionChanged = false;\n    }\n\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n\n    // Loop if we're animating\n    if (this.speed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n\n  private requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n\n  /** Creates a texture from an image and sets it into a uniform value */\n  private setTextureUniform = (uniformName: string, image: HTMLImageElement): void => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n\n    // Clean up existing texture if present\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n\n    // Create and set up the new texture\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n\n    // Set texture parameters\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n    // Upload image to texture\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error('Paper Shaders: WebGL error when uploading texture:', error);\n      return;\n    }\n\n    // Store the texture\n    this.textures.set(uniformName, texture);\n\n    // Set up texture unit and uniform\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      // Use texture unit based on the order textures were added\n      const textureUnit = this.textures.size - 1;\n      this.gl.useProgram(this.program);\n      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n      this.gl.uniform1i(location, textureUnit);\n\n      // Calculate and set the aspect ratio uniform\n      const aspectRatioUniformName = `${uniformName}_aspect_ratio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  private setUniformValues = (updatedUniforms: ShaderMountUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n\n      if (value instanceof HTMLImageElement) {\n        // Texture case, requires a good amount of code so it gets its own function:\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        // Array case\n        let flatArray: number[] | null = null;\n        let valueLength: number | null = null;\n\n        // If it's an array of same-sized arrays, flatten it down so we can set the uniform\n        if (value[0] !== undefined && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => (arr as number[]).length === firstChildLength)) {\n            // Array of same-sized arrays case, flattens the array sets it\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          // Array of primitive values case, supports 2, 3, 4, 9, 16 length arrays\n          flatArray = value as number[];\n          valueLength = flatArray.length;\n        }\n\n        // Set the uniform based on array length... supports 2, 3, 4, 9, 16 length arrays of primitive values\n        // or arbitrary length arrays of arrays\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === 'number') {\n        // Number case, supports floats and ints\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === 'boolean') {\n        // Boolean case, supports true and false\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n\n  /** Gets the current total animation time from 0ms */\n  public getCurrentFrameTime = (): number => {\n    return this.totalFrameTime;\n  };\n\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  public setFrame = (newFrame: number): void => {\n    this.totalFrameTime = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n\n  /** Set an animation speed (or 0 to stop animation) */\n  public setSpeed = (newSpeed: number = 1): void => {\n    // Set the new animation speed\n    this.speed = newSpeed;\n\n    if (this.rafId === null && newSpeed !== 0) {\n      // Moving from 0 to animating, kick off a new rAF loop\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n\n    if (this.rafId !== null && newSpeed === 0) {\n      // Moving from animating to not animating, cancel the rAF loop\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  public setMaxPixelCount = (newMaxPixelCount: number = DEFAULT_MAX_PIXEL_COUNT): void => {\n    this.maxPixelCount = newMaxPixelCount;\n\n    this.handleResize();\n  };\n\n  /** Set the minimum pixel ratio for the shader */\n  public setMinPixelRatio = (newMinPixelRatio: number = 2): void => {\n    this.minPixelRatio = newMinPixelRatio;\n\n    this.handleResize();\n  };\n\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  public setUniforms = (newUniforms: ShaderMountUniforms): void => {\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n\n    // If we need to allow users to add uniforms after the shader has been created, we can do that here\n    // But right now we're expecting the uniform list to be predictable and static\n    // this.setupUniforms();\n\n    this.setUniformValues(newUniforms);\n    this.render(performance.now());\n  };\n\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  public dispose = (): void => {\n    // Immediately mark as disposed to prevent future renders from leaking in\n    this.hasBeenDisposed = true;\n\n    // Cancel the rAF loop\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n\n    if (this.gl && this.program) {\n      // Clean up all textures\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n\n      // Reset the WebGL context\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n\n      // Clear any errors\n      this.gl.getError();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    visualViewport?.removeEventListener('resize', this.handleVisualViewportChange);\n\n    this.uniformLocations = {};\n\n    // Remove the shader mount from the div wrapper element to avoid any GC issues\n    this.parentElement.paperShaderMount = undefined;\n  };\n}\n\n/** Vertex shader for the shader mount */\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_objectHelperBox = uv;\n    v_objectHelperBox *= objectWorldScale;\n    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_responsiveHelperBox = uv;\n    v_responsiveHelperBox *= responsiveBoxScale;\n    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_patternHelperBox = uv;\n    v_patternHelperBox *= patternBoxScale;\n    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  v_patternUV += .5;\n\n  // ===================================================\n\n}`;\n\nfunction createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction createProgram(\n  gl: WebGLRenderingContext,\n  vertexShaderSource: string,\n  fragmentShaderSource: string\n): WebGLProgram | null {\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n  if (!vertexShader || !fragmentShader) return null;\n\n  const program = gl.createProgram();\n  if (!program) return null;\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n\n  // Clean up shaders after successful linking\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  return program;\n}\n\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shaders]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}`;\n\n/** A canvas element that has a ShaderMount available on it */\nexport interface PaperShaderElement extends HTMLElement {\n  paperShaderMount: ShaderMount | undefined;\n}\n\n/** Check if a canvas element is a ShaderCanvas */\nexport function isPaperShaderElement(element: HTMLElement): element is PaperShaderElement {\n  return 'paperShaderMount' in element;\n}\n\n/** Uniform types that we support to be auto-mapped into the fragment shader */\nexport interface ShaderMountUniforms {\n  [key: string]: boolean | number | number[] | number[][] | HTMLImageElement;\n}\n\nexport interface ShaderMotionParams {\n  speed?: number;\n  frame?: number;\n}\n\nexport type ShaderPreset<T> = {\n  name: string;\n  params: Required<T>;\n};\n\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes('safari') && !ua.includes('chrome') && !ua.includes('android');\n}\n", "/*\n ===================================================================\n The space coordinates passed from the vertex shader.\n\n `sizingVariablesDeclaration` must be included in every fragment\n shader\u2014unless we want to apply sizing to the coordinates directly\n in the fragment shader.\n\n So far, the only exception is when we need to apply pixelization\n before sizing (e.g., to make dithering pixels independent of sizing).\n*/\nexport const sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;`;\n\n/*\n ===================================================================\n Additional variables used only for drawing a sizing overlay.\n*/\nexport const sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\n\n/*\n ===================================================================\n In most cases, sizing UNIFORMS are used only in the vertex shader.\n But there are cases where we need to pass them to the fragment shader\n as well:\n  - dithering pixelization where all the sizing happens in fragment\n  - drawing the sizing helpers\n*/\nexport const sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\n\n/*\n ===================================================================\n In most cases, sizing TRANSFORMS are applied in the vertex shader.\n For exceptions (e.g., dithering pixelization), the operations below\n need to be included in the fragment shader instead.\n\n Currently, only `objectUV` and `patternUV` are supported.\n The transforms are identical to those in the vertex shader,\n except for the `USE_PIXELIZATION` part.\n*/\nexport const sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n`;\n\n/*\n ===================================================================\n Helpers used to draw the sizing (box, box origin and graphic origin)\n over the shader. Can be used with both vertex sizing and vector sizing\n\n helperBox and boxSize should be defined before inserting the code\n*/\nexport const drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\n\nexport interface ShaderSizingUniforms {\n  u_fit: (typeof ShaderFitOptions)[ShaderFit];\n  u_scale: number;\n  u_rotation: number;\n  u_originX: number;\n  u_originY: number;\n  u_offsetX: number;\n  u_offsetY: number;\n  u_worldWidth: number;\n  u_worldHeight: number;\n}\n\nexport interface ShaderSizingParams {\n  fit?: 'none' | 'contain' | 'cover';\n  scale?: number;\n  rotation?: number;\n  originX?: number;\n  originY?: number;\n  offsetX?: number;\n  offsetY?: number;\n  worldWidth?: number;\n  worldHeight?: number;\n}\n\nexport const defaultObjectSizing: Required<ShaderSizingParams> = {\n  fit: 'contain',\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0,\n};\n\nexport const defaultPatternSizing: Required<ShaderSizingParams> = {\n  fit: 'none',\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0,\n};\n\nexport const ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2,\n} as const;\n\nexport type ShaderFit = keyof typeof ShaderFitOptions;\n", "export const declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\n\nexport const declareRotate = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\n\nexport const declareRandom = `\nfloat random(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n`;\n\n// It does use the standard random function but we don't call it to keep\n// colorBandingFix insertion independent from declareRandom\nexport const colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\n\nexport const declareSimplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRotate, colorBandingFix } from '../shader-utils';\n\nexport const meshGradientMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Mesh Gradient Ksenia Kondrashova\n * Smooth, animated mesh gradient using a dynamic list of colors\n *\n * Uniforms include:\n * - u_colors (vec4[]): Input RGBA colors\n * - u_colorsCount (float): Number of active colors (`u_colors` length)\n * - u_distortion (float): Amount of animated wavy distortion applied to UV coordinates\n * - u_swirl (float): Amount of radial swirl distortion applied to UV coordinates\n */\nexport const meshGradientFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${meshGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_distortion;\nuniform float u_swirl;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRotate}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  float t = .5 * u_time;\n\n  float radius = smoothstep(0., 1., length(shape_uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    shape_uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., shape_uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., shape_uv.y));\n    shape_uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., shape_uv.x));\n  }\n\n  vec2 uvRotated = shape_uv;\n  uvRotated -= vec2(.5);\n  float angle = 3. * u_swirl * radius;\n  uvRotated = rotate(uvRotated, -angle);\n  uvRotated += vec2(.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n  \n  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n    \n    vec2 pos = getPosition(i, t);\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n      \n    float dist = 0.;\n    if (mod(float(i), 2.) > 1.) {\n      dist = length(shape_uv - pos);\n    } else {\n      dist = length(uvRotated - pos);\n    }\n\n    dist = pow(dist, 3.5);\n    float weight = 1. / (dist + 1e-3);\n    color += colorFraction * weight;\n    opacity += opacityFraction * weight;\n    totalWeight += weight;\n  }\n\n  color /= totalWeight;\n  opacity /= totalWeight;\n  \n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface MeshGradientUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_distortion: number;\n  u_swirl: number;\n}\n\nexport interface MeshGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  distortion?: number;\n  swirl?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRandom, colorBandingFix } from '../shader-utils';\n\nexport const smokeRingMeta = {\n  maxColorCount: 10,\n  maxNoiseIterations: 8,\n} as const;\n\n/**\n * Smoke Ring by Ksenia Kondrashova\n * Renders a fractional Brownian motion (fBm) noise over the\n * polar coordinates masked with ring shape\n *\n * Uniforms include:\n * - u_colorBack: the background color of the scene\n * - uColors (vec4[]): Input RGBA colors\n * - uColorsCount (float): Number of active colors (`uColors` length) * u_noiseScale - the resolution of noise texture\n * - u_thickness (float): the thickness of the ring\n * - u_radius (float): the radius of the ring (u_radius = 0.5 to fit in contain mode)\n * - u_innerShape (float): if we fill the shape inside the radius (u_innerShape = 1 to render only the thickness)\n * - u_noiseIterations (float): how detailed is the noise (number of fbm layers)\n */\n\nexport const smokeRingFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${smokeRingMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_noiseScale;\nuniform float u_thickness;\nuniform float u_radius;\nuniform float u_innerShape;\nuniform float u_noiseIterations;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n//$ {declareRandom}\n\nfloat random(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, uv).r;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  // Smoothstep for interpolation\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  // Do the interpolation as two nested mix operations\n  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n\n}\nfloat fbm(in vec2 n) {\n  float total = 0.0, amplitude = .4;\n  for (int i = 0; i < ${smokeRingMeta.maxNoiseIterations}; i++) {\n    if (i >= int(u_noiseIterations)) break;\n    total += noise(n) * amplitude;\n    n *= 1.99;\n    amplitude *= 0.65;\n  }\n  return total;\n}\n\nfloat getNoise(vec2 uv, vec2 pUv, float t) {\n  float noiseLeft = fbm(pUv + .03 * t);\n  pUv.x = mod(pUv.x, u_noiseScale * TWO_PI);\n  float noiseRight = fbm(pUv + .03 * t);\n  return mix(noiseRight, noiseLeft, smoothstep(-.25, .25, uv.x));\n}\n\nfloat getRingShape(vec2 uv) {\n  float radius = u_radius;\n  float thickness = u_thickness;\n\n  float distance = length(uv);\n  float ringValue = 1. - smoothstep(radius, radius + thickness, distance);\n  ringValue *= smoothstep(radius - pow(u_innerShape, 3.) * thickness, radius, distance);\n\n  return ringValue;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float t = u_time;\n\n  float cycleDuration = 3.;\n  float localTime1 = mod(.1 * t + cycleDuration, 2. * cycleDuration);\n  float localTime2 = mod(.1 * t, 2. * cycleDuration);\n  float timeBlend = .5 + .5 * sin(.1 * t * PI / cycleDuration - .5 * PI);\n\n  float atg = atan(shape_uv.y, shape_uv.x) + .001;\n  float l = length(shape_uv);\n  vec2 polar_uv1 = vec2(atg, localTime1 - (.5 * l) + 1. / pow(l, .5));\n  polar_uv1 *= u_noiseScale;\n  float noise1 = getNoise(shape_uv, polar_uv1, t);\n\n  vec2 polar_uv2 = vec2(atg, localTime2 - (.5 * l) + 1. / pow(l, .5));\n  polar_uv2 *= u_noiseScale;\n  float noise2 = getNoise(shape_uv, polar_uv2, t);\n\n  float noise = mix(noise1, noise2, timeBlend);\n\n  shape_uv *= (.8 + 1.2 * noise);\n\n  float ringShape = getRingShape(shape_uv);\n\n  float mixer = pow(ringShape, 3.) * (u_colorsCount - 1.);\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${smokeRingMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      float localT = clamp(mixer - float(i - 1), 0., 1.);\n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n\n  float opacity = gradient.a * ringShape;\n  opacity += u_colorBack.a;\n\n  vec3 color = gradient.rgb * ringShape;\n  color += u_colorBack.rgb * u_colorBack.a * (1. - ringShape);\n  color += u_colorBack.rgb * u_colorBack.a * ringShape * (1. - gradient.a);\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SmokeRingUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_noiseScale: number;\n  u_thickness: number;\n  u_radius: number;\n  u_innerShape: number;\n  u_noiseIterations: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface SmokeRingParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  noiseScale?: number;\n  thickness?: number;\n  radius?: number;\n  innerShape?: number;\n  noiseIterations?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declareRotate, colorBandingFix } from '../shader-utils';\n\n/**\n * Neuro Noise Pattern\n * The original artwork: https://codepen.io/ksenia-k/full/vYwgrWv by Ksenia Kondrashova\n * Renders a fractal-like structure made of several layers of since-arches\n *\n * Uniforms include:\n * u_colorFront - the front color of pattern\n * u_colorBack - the back color of pattern\n * u_brightness - the power (brightness) of pattern lines\n */\nexport const neuroNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform float u_brightness;\n\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declareRotate}\n\nfloat neuro_shape(vec2 uv, float t) {\n  vec2 sine_acc = vec2(0.);\n  vec2 res = vec2(0.);\n  float scale = 8.;\n\n  for (int j = 0; j < 15; j++) {\n    uv = rotate(uv, 1.);\n    sine_acc = rotate(sine_acc, 1.);\n    vec2 layer = uv * scale + float(j) + sine_acc - t;\n    sine_acc += sin(layer);\n    res += (.5 + .5 * cos(layer)) / scale;\n    scale *= (1.2);\n  }\n  return res.x + res.y;\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n\n  shape_uv *= .002;\n\n  float t = .5 * u_time;\n\n  float noise = neuro_shape(shape_uv, t);\n\n  noise = u_brightness * pow(noise, 3.);\n  noise += pow(noise, 12.);\n  noise = max(.0, noise - .5);\n\n  vec3 color = mix(u_colorBack.rgb * u_colorBack.a, u_colorFront.rgb * u_colorFront.a, noise);\n  float opacity = mix(u_colorBack.a, u_colorFront.a, noise);\n  \n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface NeuroNoiseUniforms extends ShaderSizingUniforms {\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_brightness: number;\n}\n\nexport interface NeuroNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colorFront?: string;\n  colorBack?: string;\n  brightness?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRandom, declareRotate } from '../shader-utils';\n\nexport const dotOrbitMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Dot Pattern with dot moving around their grid position\n * The artwork by Ksenia Kondrashova\n * Renders a dot pattern with dot placed in the center of each cell of animated Voronoi diagram\n *\n * Uniforms include:\n * - u_colors (vec4[]): Input RGBA colors\n * - u_colorsCount (float): Number of active colors (`u_colors` length)\n * - u_stepsPerColor (float): Discretization of the color transition\n * - u_size (float, 0 .. 1): Base dot radius (relative to cell size)\n * - u_sizeRange (float, 0 .. 1): Dot radius to vary between the cells\n * - u_spreading (float, 0 .. 1): the distance each dot can move around the regular grid\n */\nexport const dotOrbitFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${dotOrbitMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_stepsPerColor;\nuniform float u_size;\nuniform float u_sizeRange;\nuniform float u_spreading;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRandom}\n${declareRotate}\n\nvec2 random2(vec2 p) {\n  return vec2(random(p), random(200. * p));\n}\n\nvec3 voronoiShape(vec2 uv, float time) {\n  vec2 i_uv = floor(uv);\n  vec2 f_uv = fract(uv);\n  \n  float spreading = .25 * clamp(u_spreading, 0., 1.);\n\n  float minDist = 1.;\n  vec2 randomizer = vec2(0.);\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 tileOffset = vec2(float(x), float(y));\n      vec2 rand = random2(i_uv + tileOffset);\n      vec2 cellCenter = vec2(.5 + 1e-4);\n      cellCenter += spreading * cos(time + TWO_PI * rand);\n      cellCenter -= .5;\n      cellCenter = rotate(cellCenter, random(vec2(rand.x, rand.y)) + .1 * time);\n      cellCenter += .5;\n      float dist = length(tileOffset + cellCenter - f_uv);\n      if (dist < minDist) {\n        minDist = dist;\n        randomizer = rand;\n      }\n      minDist = min(minDist, dist);\n    }\n  }\n\n  return vec3(minDist, randomizer);\n}\n\nvoid main() {\n  \n  vec2 shape_uv = v_patternUV;\n  shape_uv += .5;\n  shape_uv *= .015;\n  \n  float t = u_time;\n\n  vec3 voronoi = voronoiShape(shape_uv, t) + 1e-4;\n\n  float radius = .25 * clamp(u_size, 0., 1.) - .5 * clamp(u_sizeRange, 0., 1.) * voronoi[2];\n  float dist = voronoi[0];\n  float edgeWidth = fwidth(dist);\n  float dots = smoothstep(radius + edgeWidth, radius - edgeWidth, dist);\n\n  float shape = voronoi[1];\n  \n  float mixer = shape * (u_colorsCount - 1.);\n  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  float steps = max(1., u_stepsPerColor);\n  \n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${dotOrbitMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);\n      localT = round(localT * steps) / steps;\n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n\n  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n    float localT = mixer + 1.;\n    if (mixer > (u_colorsCount - 1.)) {\n      localT = mixer - (u_colorsCount - 1.);\n    }\n    localT = round(localT * steps) / steps;\n    vec4 cFst = u_colors[0];\n    cFst.rgb *= cFst.a;\n    vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n    cLast.rgb *= cLast.a;\n    gradient = mix(cLast, cFst, localT);\n  }\n\n  gradient *= dots;\n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DotOrbitUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_size: number;\n  u_sizeRange: number;\n  u_spreading: number;\n  u_stepsPerColor: number;\n}\n\nexport interface DotOrbitParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  size?: number;\n  sizeRange?: number;\n  spreading?: number;\n  stepsPerColor?: number;\n}\n", "import { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareSimplexNoise } from '../shader-utils';\n\n/**\n * Dot Grid Pattern\n * (the size parameters are set in pixels)\n *\n * Uniforms include:\n * u_colorBack - the background color\n * u_colorFill - the fill color\n * u_colorStroke - the stroke color\n * u_dotSize (px) - the base dot radius\n * u_strokeWidth (px) - the stroke (to be subtracted from u_dotSize)\n * u_gapX (px) - horizontal grid spacing\n * u_gapY (px) - vertical grid spacing\n * u_sizeRange (0 .. 1) - variety of dot size\n * u_opacityRange(0 .. 1) - variety of dot opacity to be applied equally to fill and stroke\n * u_shape - shape code (0 - circle, 1 - diamond, 2 - square, 3 - triangle)\n */\nexport const dotGridFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFill;\nuniform vec4 u_colorStroke;\nuniform float u_dotSize;\nuniform float u_gapX;\nuniform float u_gapY;\nuniform float u_strokeWidth;\nuniform float u_sizeRange;\nuniform float u_opacityRange;\nuniform float u_shape;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareSimplexNoise}\n\nfloat polygon(vec2 p, float N, float rot) {\n  float a = atan(p.x, p.y) + rot;\n  float r = TWO_PI / float(N);\n\n  return cos(floor(.5 + a / r) * r - a) * length(p);\n}\n\nvoid main() {\n  \n  vec2 shape_uv = v_patternUV;\n  shape_uv += .5;\n\n  vec2 grid = fract(shape_uv / vec2(u_gapX, u_gapY)) + 1e-4;\n  vec2 grid_idx = floor(shape_uv / vec2(u_gapX, u_gapY));\n  float sizeRandomizer = .5 + .8 * snoise(2. * vec2(grid_idx.x * 100., grid_idx.y));\n  float opacity_randomizer = .5 + .7 * snoise(2. * vec2(grid_idx.y, grid_idx.x));\n\n  vec2 center = vec2(0.5) - 1e-3;\n  vec2 p = (grid - center) * vec2(u_gapX, u_gapY);\n\n  float baseSize = u_dotSize * (1. - sizeRandomizer * u_sizeRange);\n  float strokeWidth = u_strokeWidth * (1. - sizeRandomizer * u_sizeRange);\n\n  float dist;\n  if (u_shape < 0.5) {\n    // Circle\n    dist = length(p);\n  } else if (u_shape < 1.5) {\n    // Diamond\n    strokeWidth *= 1.5;\n    dist = polygon(1.5 * p, 4., .25 * PI);\n  } else if (u_shape < 2.5) {\n    // Square\n    dist = polygon(1.03 * p, 4., 1e-3);\n  } else {\n    // Triangle\n    strokeWidth *= 1.5;\n    p = p * 2. - 1.;\n    p *= .9;\n    p.y -= .75 * baseSize;\n    dist = polygon(p, 3., 1e-3);\n  }\n\n  float edgeWidth = fwidth(dist);\n  float shapeOuter = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist - strokeWidth);\n  float shapeInner = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist);\n  float stroke = shapeOuter - shapeInner;\n\n  float dotOpacity = max(0., 1. - opacity_randomizer * u_opacityRange);\n  stroke *= dotOpacity;\n  shapeInner *= dotOpacity;\n\n  stroke *= u_colorStroke.a;\n  shapeInner *= u_colorFill.a;\n\n  vec3 color = vec3(0.);\n  color += stroke * u_colorStroke.rgb;\n  color += shapeInner * u_colorFill.rgb;\n  color += (1. - shapeInner - stroke) * u_colorBack.rgb * u_colorBack.a;\n\n  float opacity = 0.;\n  opacity += stroke;\n  opacity += shapeInner;\n  opacity += (1. - opacity) * u_colorBack.a;\n  \n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DotGridUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorFill: [number, number, number, number];\n  u_colorStroke: [number, number, number, number];\n  u_dotSize: number;\n  u_gapX: number;\n  u_gapY: number;\n  u_strokeWidth: number;\n  u_sizeRange: number;\n  u_opacityRange: number;\n  u_shape: (typeof DotGridShapes)[DotGridShape];\n}\n\nexport interface DotGridParams extends ShaderSizingParams {\n  colorBack?: string;\n  colorFill?: string;\n  colorStroke?: string;\n  size?: number;\n  gapX?: number;\n  gapY?: number;\n  strokeWidth?: number;\n  sizeRange?: number;\n  opacityRange?: number;\n  shape?: DotGridShape;\n}\n\nexport const DotGridShapes = {\n  circle: 0,\n  diamond: 1,\n  square: 2,\n  triangle: 3,\n} as const;\n\nexport type DotGridShape = keyof typeof DotGridShapes;\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declareSimplexNoise, colorBandingFix } from '../shader-utils';\n\nexport const simplexNoiseMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Simplex Noise animation by Ksenia Kondrashova\n * Calculates a combination of 2 simplex noises with result mapped as\n * a gradient with dynamic number of main colors and steps between them\n *\n * Uniforms include:\n * - u_colors (vec4[]): Input RGBA colors\n * - u_colorsCount (float): Number of active colors (`u_colors` length)\n * - u_stepsPerColor (float, used as int): Number of rendered colors per input color\n * - u_softness (float, 0..1): Amount of blur applied to the color steps\n */\nexport const simplexNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform float u_scale;\n\nuniform vec4 u_colors[${simplexNoiseMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_stepsPerColor;\nuniform float u_softness;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declareSimplexNoise}\n\nfloat getNoise(vec2 uv, float t) {\n  float noise = .5 * snoise(uv - vec2(0., .3 * t));\n  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));\n\n  return noise;\n}\n\nfloat steppedSmooth(float t, float steps, float softness) {\n    float stepT = floor(t * steps) / steps;\n    float f = t * steps - floor(t * steps);\n    \n    float fw = 0.005 / u_scale;\n    float smoothed = smoothstep(.5 - softness * .5 - fw, .5 + softness * .5 + fw, f);\n        \n    return stepT + smoothed / steps;\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n\n  shape_uv *= .001;\n\n  float t = .2 * u_time;\n\n  float shape = .5 + .5 * getNoise(shape_uv, t);\n  \n  bool u_extraSides = true;\n  \n  float mixer = shape * (u_colorsCount - 1.);\n  if (u_extraSides == true) {\n    mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  }\n\n  float steps = max(1., u_stepsPerColor);\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${simplexNoiseMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      \n      float localT = clamp(mixer - float(i - 1), 0., 1.);\n      localT = steppedSmooth(localT, steps, u_softness);   \n      \n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n  \n  if (u_extraSides == true) {\n   if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n     float localT = mixer + 1.;\n     if (mixer > (u_colorsCount - 1.)) {\n       localT = mixer - (u_colorsCount - 1.);\n     }\n     localT = steppedSmooth(localT, steps, u_softness);   \n     vec4 cFst = u_colors[0];\n     cFst.rgb *= cFst.a;\n     vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n     cLast.rgb *= cLast.a;\n     gradient = mix(cLast, cFst, localT);\n   }\n  }\n\n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n  \n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SimplexNoiseUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_stepsPerColor: number;\n  u_softness: number;\n}\n\nexport interface SimplexNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  stepsPerColor?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, colorBandingFix } from '../shader-utils';\n\nexport const metaballsMeta = {\n  maxColorCount: 8,\n  maxBallsCount: 20,\n} as const;\n\n/**\n * Metaballs (circular shapes with gooey effect applied)\n * The artwork by Ksenia Kondrashova\n *\n * Uniforms include:\n * - uColors (vec4[]): Input RGBA colors\n * - uColorsCount (float): Number of active colors (`uColors` length)\n * - u_count (float)\n * - u_size (float)\n */\nexport const metaballsFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${metaballsMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_size;\nuniform float u_sizeRange;\nuniform float u_count;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n\nfloat hash(float x) {\n  return fract(sin(x) * 43758.5453123);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat getBallShape(vec2 uv, vec2 c, float p) {\n  float s = .5 * length(uv - c);\n  s = 1. - clamp(s, 0., 1.);\n  s = pow(s, p);\n  return s;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  float t = .2 * u_time + 1.;\n\n  vec3 totalColor = vec3(0.);\n  float totalShape = 0.;\n  float totalOpacity = 0.;\n  \n  for (int i = 0; i < ${metaballsMeta.maxBallsCount}; i++) {\n    if (i >= int(ceil(u_count))) break;\n  \n    float idxFract = float(i) / float(${metaballsMeta.maxBallsCount});\n    float angle = TWO_PI * idxFract;\n  \n    float speed = 1. - .2 * idxFract;\n    float noiseX = noise(angle * 10. + float(i) + t * speed);\n    float noiseY = noise(angle * 20. + float(i) - t * speed);\n  \n    vec2 pos = vec2(.5) + 1e-4 + .9 * (vec2(noiseX, noiseY) - .5);\n  \n    int safeIndex = i % int(u_colorsCount + 0.5);\n    vec4 ballColor = u_colors[safeIndex];\n    ballColor.rgb *= ballColor.a;\n\n    float sizeFrac = 1.;\n    if (float(i) > floor(u_count - 1.)) {\n      sizeFrac *= fract(u_count);\n    }\n\n    float shape = getBallShape(shape_uv, pos, 45. - 30. * u_size * sizeFrac);\n    shape *= pow(u_size, .2);\n    shape = smoothstep(0., 1., shape);\n\n    totalColor += ballColor.rgb * shape;\n    totalShape += shape;\n    totalOpacity += ballColor.a * shape;\n  }\n\n  totalColor /= max(totalShape, 1e-4);\n  totalOpacity /= max(totalShape, 1e-4);\n\n  float edge_width = fwidth(totalShape);\n  float finalShape = smoothstep(.4, .4 + edge_width, totalShape);\n\n  vec3 color = totalColor * finalShape;\n  float opacity = totalOpacity * finalShape;\n\n  if (opacity < .005) {\n    discard;\n  }\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface MetaballsUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_count: number;\n  u_size: number;\n}\n\nexport interface MetaballsParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  count?: number;\n  size?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, colorBandingFix } from '../shader-utils';\n\n/**\n * 3d Perlin noise with exposed parameters\n * Based on https://www.shadertoy.com/view/NlSGDz\n *\n * Uniforms include:\n * u_color1 - the first mixed color\n * u_color2 - the second mixed color\n * u_proportion (0 .. 1) - the proportion between u_color1 and u_color2;\n * u_softness - the sharpness of the transition between u_color1 and u_color2 in the noise output\n * u_octaveCount - the number of octaves for Perlin noise;\n *    higher values increase the complexity of the noise\n * u_persistence (0 .. 1) - the amplitude of each successive octave of the noise;\n *    lower values make higher octaves less pronounced\n * u_lacunarity - the frequency of each successive octave of the noise;\n *    higher values increase the detail\n */\nexport const perlinNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_color1;\nuniform vec4 u_color2;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_octaveCount;\nuniform float u_persistence;\nuniform float u_lacunarity;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n\nuint hash(uint x, uint seed) {\n  const uint m = 0x5bd1e995U;\n  uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process third vector element\n    k = x.z;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec3 gradientdy(uint hash) {\n    switch (int(hash) & 15) { // look at the last four bits to pick a gradient dy\n    case 0:\n        return vec3(1, 1, 0);\n    case 1:\n        return vec3(-1, 1, 0);\n    case 2:\n        return vec3(1, -1, 0);\n    case 3:\n        return vec3(-1, -1, 0);\n    case 4:\n        return vec3(1, 0, 1);\n    case 5:\n        return vec3(-1, 0, 1);\n    case 6:\n        return vec3(1, 0, -1);\n    case 7:\n        return vec3(-1, 0, -1);\n    case 8:\n        return vec3(0, 1, 1);\n    case 9:\n        return vec3(0, -1, 1);\n    case 10:\n        return vec3(0, 1, -1);\n    case 11:\n        return vec3(0, -1, -1);\n    case 12:\n        return vec3(1, 1, 0);\n    case 13:\n        return vec3(-1, 1, 0);\n    case 14:\n        return vec3(0, -1, 1);\n    case 15:\n        return vec3(0, -1, -1);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(\n        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    position += 1e+4;\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = fract(position);\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientdy(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat p_noise(vec3 position, int octaveCount, float persistence, float lacunarity) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = 10.;\n    uint currentSeed = uint(0);\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U);\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\nfloat get_max_amp(float persistence, float octaveCount) {\n    persistence *= .999;\n    return (1. - pow(persistence, octaveCount)) / (1. - persistence);\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n\n  shape_uv *= .005;\n  float t = .2 * u_time;\n\n    vec3 p = vec3(shape_uv, t);\n\n    float oct_count = max(0., floor(u_octaveCount));\n    float persistence = clamp(u_persistence, 0., 1.);\n    float noise = p_noise(p, int(oct_count), persistence, u_lacunarity);\n\n    float max_amp = get_max_amp(persistence, oct_count);\n    float noise_normalized = (noise + max_amp) / (2. * max_amp) + (u_proportion - .5);\n    float sharpness = clamp(u_softness, 0., 1.);\n    float smooth_w = 0.5 * fwidth(noise_normalized);\n    float sharp_noise = smoothstep(\n        .5 - .5 * sharpness - smooth_w,\n        .5 + .5 * sharpness + smooth_w,\n        noise_normalized\n    );\n\n    vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, sharp_noise);\n    float opacity = mix(u_color1.a, u_color2.a, sharp_noise);\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PerlinNoiseUniforms extends ShaderSizingUniforms {\n  u_color1: [number, number, number, number];\n  u_color2: [number, number, number, number];\n  u_proportion: number;\n  u_softness: number;\n  u_octaveCount: number;\n  u_persistence: number;\n  u_lacunarity: number;\n}\n\nexport interface PerlinNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  color1?: string;\n  color2?: string;\n  proportion?: number;\n  softness?: number;\n  octaveCount?: number;\n  persistence?: number;\n  lacunarity?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI } from '../shader-utils';\n\nexport const voronoiMeta = {\n  maxColorCount: 5,\n} as const;\n\n/**\n * Voronoi pattern by Ksenia Kondrashova\n * The variation of Voronoi pattern with cell edges. Big thanks to Inigo Quilez\n * https://www.shadertoy.com/view/ldl3W8\n *\n * Uniforms include:\n *\n * - `u_colors` (`vec4[]`): Array of RGBA colors used for cell filling\n * - `u_colorsCount` (`float`): Number of active colors in `u_colors`\n * - `u_colorBack` (`vec4`): RGBA color for the gaps between cells\n * - `u_colorGlow` (`vec4`): RGBA color for the radial shape on the cell edges\n * - `u_distortion` (`float`, 0 \u2013 0.5): Controls how far cell centers can be displaced from the regular grid\n * - `u_gap` (`float`): Width of the gaps between cells (gaps can't be removed completely due to artifacts of Voronoi cells)\n * - `u_innerGlow` (`float`): Controls the size of the radial glow inside each cell\n * - `u_stepsPerColor` (`float`): Discretization of the color transition\n * - `u_noiseTexture` (`sampler2D`): Replacement of standard hash function, added for better performance\n */\nexport const voronoiFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform float u_scale;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colors[${voronoiMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_stepsPerColor;\nuniform vec4 u_colorGlow;\nuniform vec4 u_colorBack;\nuniform float u_distortion;\nuniform float u_gap;\nuniform float u_innerGlow;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n\nvec2 hash(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, uv).gb;\n}\n\nvec4 voronoi(vec2 x, float t) {\n  vec2 ip = floor(x);\n  vec2 fp = fract(x);\n\n  vec2 mg, mr;\n  float md = 8.;\n  float rand = 0.;\n\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 g = vec2(float(i), float(j));\n      vec2 raw_hash = hash(ip + g);\n      vec2 o = hash(ip + g);\n      o = .5 + u_distortion * sin(t + TWO_PI * o);\n      vec2 r = g + o - fp;\n      float d = dot(r, r);\n\n      if (d < md) {\n        md = d;\n        mr = r;\n        mg = g;\n        rand = raw_hash.x;\n      }\n    }\n  }\n\n  md = 8.;\n  for (int j = -2; j <= 2; j++) {\n    for (int i = -2; i <= 2; i++) {\n      vec2 g = mg + vec2(float(i), float(j));\n      vec2 o = hash(ip + g);\n      o = .5 + u_distortion * sin(t + TWO_PI * o);\n      vec2 r = g + o - fp;\n      if (dot(mr - r, mr - r) > .00001) {\n        md = min(md, dot(.5 * (mr + r), normalize(r - mr)));\n      }\n    }\n  }\n\n  return vec4(md, mr, rand);\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= .0125;\n\n  float t = u_time;\n\n  vec4 voronoiRes = voronoi(shape_uv, t);\n\n  float shape = clamp(voronoiRes.w, 0., 1.);\n  float mixer = shape * (u_colorsCount - 1.);\n  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  float steps = max(1., u_stepsPerColor);\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${voronoiMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);\n      localT = round(localT * steps) / steps;\n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n\n  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n    float localT = mixer + 1.;\n    if (mixer > (u_colorsCount - 1.)) {\n      localT = mixer - (u_colorsCount - 1.);\n    }\n    localT = round(localT * steps) / steps;\n    vec4 cFst = u_colors[0];\n    cFst.rgb *= cFst.a;\n    vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n    cLast.rgb *= cLast.a;\n    gradient = mix(cLast, cFst, localT);\n  }\n\n  vec3 cellColor = gradient.rgb;\n  float cellOpacity = gradient.a;\n\n  float innerGlows = length(voronoiRes.yz * u_innerGlow + .1);\n  innerGlows = pow(innerGlows, 1.5);\n\n  vec3 color = mix(cellColor, u_colorGlow.rgb * u_colorGlow.a, u_colorGlow.a * innerGlows);\n  float opacity = cellOpacity + u_colorGlow.a * innerGlows;\n\n  float edge = voronoiRes.x;\n  float smoothEdge = .02 / (2. * u_scale) * (1. + .5 * u_gap);\n  edge = smoothstep(u_gap - smoothEdge, u_gap + smoothEdge, edge);\n\n  color = mix(u_colorBack.rgb * u_colorBack.a, color, edge);\n  opacity = mix(u_colorBack.a, opacity, edge);\n\n  fragColor = vec4(color, opacity);  \n}\n`;\n\nexport interface VoronoiUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_stepsPerColor: number;\n  u_colorBack: [number, number, number, number];\n  u_colorGlow: [number, number, number, number];\n  u_distortion: number;\n  u_gap: number;\n  u_innerGlow: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface VoronoiParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  stepsPerColor?: number;\n  colorBack?: string;\n  colorGlow?: string;\n  distortion?: number;\n  gap?: number;\n  innerGlow?: number;\n}\n", "import { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRotate } from '../shader-utils';\n\n/**\n * Waves static pattern on the transparent background\n *\n * Uniforms include:\n * u_color1 - the first color\n * u_color2 - the second color\n * u_shape (0 ... 3) - the line shaping coefficient, non-integer\n   values allowed and produce mixed shapes\n   - u_shape = 0 is zigzag\n   - u_shape = 1 is perfect sine wave\n   - u_shape = 2 is irregular wave #1\n   - u_shape = 3 is irregular wave #2\n * u_frequency - the wave frequency\n * u_amplitude - the wave amplitude\n * u_spacing - the density of pattern lines\n * u_proportion (0 ... 1) - the proportion of stroke width to the pattern step\n * u_softness (0 ... 1) - the blur applied to the lines edges\n */\nexport const wavesFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_scale;\n\nuniform vec4 u_color1;\nuniform vec4 u_color2;\nuniform float u_shape;\nuniform float u_frequency;\nuniform float u_amplitude;\nuniform float u_spacing;\nuniform float u_proportion;\nuniform float u_softness;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRotate}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= .05;\n\n  float wave = .5 * cos(shape_uv.x * u_frequency * TWO_PI);\n  float zigzag = 2. * abs(fract(shape_uv.x * u_frequency) - .5);\n  float irregular = sin(shape_uv.x * .25 * u_frequency * TWO_PI) * cos(shape_uv.x * u_frequency * TWO_PI);\n  float irregular2 = .75 * (sin(shape_uv.x * u_frequency * TWO_PI) + .5 * cos(shape_uv.x * .5 * u_frequency * TWO_PI));\n\n  float offset = mix(zigzag, wave, smoothstep(0., 1., u_shape));\n  offset = mix(offset, irregular, smoothstep(1., 2., u_shape));\n  offset = mix(offset, irregular2, smoothstep(2., 3., u_shape));\n  offset *= 2. * u_amplitude;\n\n  float spacing = .02 + .98 * u_spacing;\n  float shape = .5 + .5 * sin((shape_uv.y + offset) * PI / spacing);\n\n  float edge_width = .02 / (1. + abs(shape)) * (.001 + u_scale);\n  edge_width += .5 * max(0., u_softness);\n  float dc = clamp(u_proportion, 0., 1.);\n  float t = smoothstep(dc - edge_width, dc + edge_width, shape);\n\n  vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, t);\n  float opacity = mix(u_color1.a, u_color2.a, t);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface WavesUniforms extends ShaderSizingUniforms {\n  u_color1: [number, number, number, number];\n  u_color2: [number, number, number, number];\n  u_shape: number;\n  u_frequency: number;\n  u_amplitude: number;\n  u_spacing: number;\n  u_proportion: number;\n  u_softness: number;\n}\n\nexport interface WavesParams extends ShaderSizingParams {\n  color1?: string;\n  color2?: string;\n  rotation?: number;\n  shape?: number;\n  frequency?: number;\n  amplitude?: number;\n  spacing?: number;\n  proportion?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRandom, declareRotate, colorBandingFix } from '../shader-utils';\n\nexport const warpMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * 3d Perlin noise with exposed parameters\n *\n * Uniforms include:\n * - u_colors (vec4[]): Input RGBA colors\n * - u_colorsCount (float): Number of active colors (`u_colors` length)\n * - u_proportion (0 .. 1): the proportion between colors (on 0.5 colors are equally distributed)\n * - u_softness (0 .. 1): the color blur (0 for pronounced edges, 1 for gradient)\n * - u_shape (0 ... 2): the color pattern to be distorted with noise & swirl\n *    - u_shape = 0 is checks\n *    - u_shape = 1 is stripes\n *    - u_shape = 2 is 2 halves of canvas (mapping the canvas height regardless of resolution)\n * - u_shapeScale: the scale of color pattern (appies over the global scaling)\n * - u_distortion: the noisy distortion over the UV coordinate (applied before the overlapping swirl)\n * - u_swirl: the power of swirly distortion\n * - u_swirlIterations: the number of swirl iterations (layering curves effect)\n *\n */\nexport const warpFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform float u_scale;\nuniform vec2 u_resolution;\n\nuniform vec4 u_colors[${warpMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_shape;\nuniform float u_shapeScale;\nuniform float u_distortion;\nuniform float u_swirl;\nuniform float u_swirlIterations;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRandom}\n${declareRotate}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  // Smoothstep for interpolation\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  // Do the interpolation as two nested mix operations\n  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= .005;\n\n  float t = .01 * u_time;\n\n  float noise_scale = .0005 + .006 * u_scale;\n\n  float n1 = noise(shape_uv * 1. + t);\n  float n2 = noise(shape_uv * 2. - t);\n  float angle = n1 * TWO_PI;\n  shape_uv.x += 4. * u_distortion * n2 * cos(angle);\n  shape_uv.y += 4. * u_distortion * n2 * sin(angle);\n\n  float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));\n  for (float i = 1.; i <= iterations_number; i++) {\n    shape_uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * shape_uv.y);\n    shape_uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * shape_uv.x);\n  }\n\n  float proportion = clamp(u_proportion, 0., 1.);\n\n  float shape = 0.;\n  if (u_shape < .5) {\n    vec2 checks_shape_uv = shape_uv * (.5 + 3.5 * u_shapeScale);\n    shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);\n    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n  } else if (u_shape < 1.5) {\n    vec2 stripes_shape_uv = shape_uv * (2. * u_shapeScale);\n    float f = fract(stripes_shape_uv.y);\n    shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);\n    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n  } else {\n    float sh = 1. - shape_uv.y;\n    float shape_scaling = 5. * (1. - u_shapeScale);\n    shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));\n  }\n\n  float mixer = shape * (u_colorsCount - 1.);\n  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${warpMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);\n      localT = smoothstep(.5 - .5 * u_softness, .5 + .5 * u_softness, localT);\n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n\n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface WarpUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_proportion: number;\n  u_softness: number;\n  u_shape: (typeof WarpPatterns)[WarpPattern];\n  u_shapeScale: number;\n  u_distortion: number;\n  u_swirl: number;\n  u_swirlIterations: number;\n}\n\nexport interface WarpParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  rotation?: number;\n  proportion?: number;\n  softness?: number;\n  shape?: WarpPattern;\n  shapeScale?: number;\n  distortion?: number;\n  swirl?: number;\n  swirlIterations?: number;\n}\n\nexport const WarpPatterns = {\n  checks: 0,\n  stripes: 1,\n  edge: 2,\n} as const;\n\nexport type WarpPattern = keyof typeof WarpPatterns;\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRandom, declareRotate, colorBandingFix } from '../shader-utils';\n\nexport const godRaysMeta = {\n  maxColorCount: 5,\n} as const;\n\n/**\n * GodRays pattern\n * The artwork by Ksenia Kondrashova\n * Renders a number of circular shapes with gooey effect applied\n *\n * Uniforms include:\n *\n * - u_colorBack: background RGBA color\n * - uColors (vec4[]): Input RGBA colors\n * - u_frequency: the frequency of rays (the number of sectors)\n * - u_spotty: the density of spots in the rings (higher = more spots)\n * - u_midSize: the size of the central shape within the rings\n * - u_midIntensity: the influence of the central shape on the rings\n * - u_density (0 .. 1): the number of visible rays\n * - u_blending (0 .. 1): normal / additive blending\n */\nexport const godRaysFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${godRaysMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_frequency;\nuniform float u_spotty;\nuniform float u_midSize;\nuniform float u_midIntensity;\nuniform float u_density;\nuniform float u_blending;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRandom}\n${declareRotate}\n\nfloat hash(float n) {\n  return fract(sin(n * 43758.5453123) * 43758.5453123);\n}\n\nfloat valueNoise(vec2 uv) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat raysShape(vec2 uv, float r, float freq, float density, float radius) {\n  float a = atan(uv.y, uv.x);\n  vec2 left = vec2(a * freq, r);\n  vec2 right = vec2(mod(a, TWO_PI) * freq, r);\n  float n_left = pow(valueNoise(left), density);\n  float n_right = pow(valueNoise(right), density);\n  float shape = mix(n_right, n_left, smoothstep(-.15, .15, uv.x));\n  return shape;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float t = .2 * u_time;\n\n  float radius = length(shape_uv);\n  float spots = 5. * abs(u_spotty);\n\n  float density = 4. - 3. * clamp(u_density, 0., 1.);\n\n  float delta = 1. - smoothstep(0., 1., radius);\n\n  float middleShape = pow(u_midIntensity, .3) * smoothstep(abs(u_midSize), 0.02 * abs(u_midSize), 3.0 * radius);\n  middleShape = pow(middleShape, 5.0);\n\n  vec3 accumColor = vec3(0.0);\n  float accumAlpha = 0.0;\n\n  for (int i = 0; i < ${godRaysMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 rotatedUV = rotate(shape_uv, float(i) + 1.0);\n\n    float r1 = radius * (1.0 + 0.4 * float(i)) - 3.0 * t;\n    float r2 = 0.5 * radius * (1.0 + spots) - 2.0 * t;\n    float f = mix(1.0, 3.0 + 0.5 * float(i), hash(float(i) + 10.0)) * u_frequency;\n\n    float ray = raysShape(rotatedUV, r1, 5.0 * f, density, radius);\n    ray *= raysShape(rotatedUV, r2, 4.0 * f, density, radius);\n    ray += (1. + 4. * ray) * middleShape;\n    ray = clamp(ray, 0.0, 1.0);\n\n    float srcAlpha = u_colors[i].a * ray;\n    vec3 srcColor = u_colors[i].rgb * srcAlpha;\n\n    vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * srcColor;\n    float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * srcAlpha;\n\n    vec3 addBlendColor = accumColor + srcColor;\n    float addBlendAlpha = accumAlpha + srcAlpha;\n\n    accumColor = mix(alphaBlendColor, addBlendColor, u_blending);\n    accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);\n  }\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n\n  vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * bgColor;\n  float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * u_colorBack.a;\n\n  vec3 addBlendColor = accumColor + bgColor;\n  float addBlendAlpha = accumAlpha + u_colorBack.a;\n\n  accumColor = mix(alphaBlendColor, addBlendColor, u_blending);\n  accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);\n\n  vec3 color = clamp(accumColor, 0.0, 1.0);\n  float opacity = clamp(accumAlpha, 0.0, 1.0);\n\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface GodRaysUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_spotty: number;\n  u_midSize: number;\n  u_midIntensity: number;\n  u_frequency: number;\n  u_density: number;\n  u_blending: number;\n}\n\nexport interface GodRaysParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  spotty?: number;\n  midSize?: number;\n  midIntensity?: number;\n  frequency?: number;\n  density?: number;\n  blending?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declareSimplexNoise, declarePI, colorBandingFix } from '../shader-utils';\n\n/**\n * Spiral shape by Ksenia Kondrashova\n * Generates a dynamic spiral shape with configurable parameters\n *\n * Uniforms include:\n *\n * u_scale - controls the overall scale of the spiral (u_scale = 1 makes it fit the viewport height)\n * u_offsetX - left / right pan\n * u_offsetY - up / down pan\n * u_color1 - the first color used in the spiral (stroke)\n * u_color2 - the second color used in the spiral (back)\n * u_density (0 .. 1) - the spacing of the spiral arms\n * u_distortion (0 .. 1) - adds a wavy distortion effect to the spiral arms\n * u_strokeWidth (0 .. 1) - defines the thickness of the spiral lines.\n * u_strokeCap (0 .. 1) - adjusts the fading of the spiral edges.\n * u_strokeTaper (0 .. 1) - controls the tapering effect along the spiral arms.\n * u_noiseFrequency - frequency of the noise applied to the spiral.\n * u_noisePower (0 .. 1) - strength of the noise effect.\n * u_softness - softens the edges of the spiral for a smoother appearance.\n */\nexport const spiralFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_color1;\nuniform vec4 u_color2;\nuniform float u_density;\nuniform float u_distortion;\nuniform float u_strokeWidth;\nuniform float u_strokeCap;\nuniform float u_strokeTaper;\n\nuniform float u_noiseFrequency;\nuniform float u_noisePower;\nuniform float u_softness;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareSimplexNoise}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV * .02;\n\n  float t = u_time;\n\n  float l = length(shape_uv);\n  float angle = atan(shape_uv.y, shape_uv.x) - 2. * t;\n  float angle_norm = angle / TWO_PI;\n\n  angle_norm += .125 * u_noisePower * snoise(.5 * u_noiseFrequency * shape_uv);\n\n  float offset = pow(l, 1. - clamp(u_density, 0., 1.)) + angle_norm;\n\n  float stripe_map = fract(offset);\n  stripe_map -= .5 * u_strokeTaper * l;\n\n  stripe_map += .25 * u_noisePower * snoise(u_noiseFrequency * shape_uv);\n\n  float shape = 2. * abs(stripe_map - .5);\n\n  shape *= (1. + u_distortion * sin(4. * l - t) * cos(PI + l + t));\n\n  float stroke_width = clamp(u_strokeWidth, fwidth(l), 1. - fwidth(l));\n\n  float edge_width = min(fwidth(l), fwidth(offset));\n\n  float mid = 1. - smoothstep(.0, .9, l);\n  mid = pow(mid, 2.);\n  shape -= .5 * u_strokeCap * mid;\n\n  shape = smoothstep(stroke_width - edge_width - u_softness, stroke_width + edge_width + u_softness, shape);\n\n  vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, shape);\n  float opacity = mix(u_color1.a, u_color2.a, shape);\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SpiralUniforms extends ShaderSizingUniforms {\n  u_color1: [number, number, number, number];\n  u_color2: [number, number, number, number];\n  u_density: number;\n  u_distortion: number;\n  u_strokeWidth: number;\n  u_strokeTaper: number;\n  u_strokeCap: number;\n  u_noiseFrequency: number;\n  u_noisePower: number;\n  u_softness: number;\n}\n\nexport interface SpiralParams extends ShaderSizingParams, ShaderMotionParams {\n  color1?: string;\n  color2?: string;\n  density?: number;\n  distortion?: number;\n  strokeWidth?: number;\n  strokeTaper?: number;\n  strokeCap?: number;\n  noiseFrequency?: number;\n  noisePower?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declareSimplexNoise, declarePI, declareRotate, colorBandingFix } from '../shader-utils';\n\nexport const swirlMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n */\nexport const swirlFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${swirlMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_bandCount;\nuniform float u_twist;\nuniform float u_softness;\nuniform float u_noisePower;\nuniform float u_noiseFrequency;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareSimplexNoise}\n${declareRotate}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n    \n  float l = length(shape_uv);\n\n  float t = u_time;\n\n  float angle = ceil(u_bandCount) * atan(shape_uv.y, shape_uv.x) + t;\n  float angle_norm = angle / TWO_PI;  \n    \n  float twist = 3. * clamp(u_twist, 0., 1.);\n  float offset = pow(l, -twist) + angle_norm;\n  \n  float shape = fract(offset);\n  shape = 1. - abs(2. * shape - 1.);\n  shape += u_noisePower * snoise(pow(u_noiseFrequency, 2.) * shape_uv);\n\n  float mid = smoothstep(.2, .4, pow(l, twist));\n  shape = mix(0., shape, mid);\n    \n  float mixer = shape * (u_colorsCount - 1.);\n  float softness = u_softness + (.1 + .012 * u_colorsCount) * smoothstep(.6, .2, pow(l, twist));\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${swirlMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n      \n      float localT = clamp(mixer - float(i - 1), 0., 1.);      \n      localT = smoothstep(.5 - .5 * u_softness, .5 + .5 * u_softness, localT);\n\n      vec4 c = u_colors[i];\n      c.rgb *= c.a;\n      gradient = mix(gradient, c, localT);\n  }\n \n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n  \n  ${colorBandingFix}\n  \n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SwirlUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_bandCount: number;\n  u_twist: number;\n  u_softness: number;\n  u_noiseFrequency: number;\n  u_noisePower: number;\n}\n\nexport interface SwirlParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  bandCount?: number;\n  twist?: number;\n  softness?: number;\n  noiseFrequency?: number;\n  noisePower?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount';\nimport {\n  sizingUniformsDeclaration,\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n  sizingUV,\n  drawSizingHelpers,\n} from '../shader-sizing';\nimport { declareSimplexNoise, declarePI, declareRandom } from '../shader-utils';\n\n/**\n * Dithering Fragment Shader by Ksenia Kondrashova\n * Applies dithering (4 dithering types available) over the\n * abstract shapes animation (7 animated shapes available)\n *\n * Uniforms include:\n * - u_color1: background color, RGBA\n * - u_color2: pixels color, RGBA\n *\n * - u_shape (float, used as int, 1 to 7):\n *  --- shape = 1: Simplex noise pattern\n *  --- shape = 2: Warp noise pattern\n *  --- shape = 3: Columns if dots moving vertically\n *  --- shape = 4: Sine wave\n *  --- shape = 5: Ripple effect\n *  --- shape = 6: Swirl animation\n *  --- shape = 7: Rotating sphere\n *\n *  - u_type (float, used as int, 1 to 4):\n *  --- type = 1: Random dithering\n *  --- type = 2: 2x2 Bayer matrix\n *  --- type = 3: 4x4 Bayer matrix\n *  --- type = 4: 8x8 Bayer matrix\n *\n * - pxSize (float), relative to canvas resolution\n *\n */\nexport const ditheringFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\n${sizingUniformsDeclaration}\n\nuniform vec4 u_color1;\nuniform vec4 u_color2;\nuniform float u_shape;\nuniform float u_type;\nuniform float u_pxSize;\n\nout vec4 fragColor;\n\n${declareSimplexNoise}\n${declarePI}\n${declareRandom}\n\nfloat getSimplexNoise(vec2 uv, float t) {\n  float noise = .5 * snoise(uv - vec2(0., .3 * t));\n  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));\n\n  return noise;\n}\n\nconst int bayer2x2[4] = int[4](0, 2, 3, 1);\nconst int bayer4x4[16] = int[16](\n  0,  8,  2, 10,\n 12,  4, 14,  6,\n  3, 11,  1,  9,\n 15,  7, 13,  5\n);\n\nconst int bayer8x8[64] = int[64](\n   0, 32,  8, 40,  2, 34, 10, 42,\n  48, 16, 56, 24, 50, 18, 58, 26,\n  12, 44,  4, 36, 14, 46,  6, 38,\n  60, 28, 52, 20, 62, 30, 54, 22,\n   3, 35, 11, 43,  1, 33,  9, 41,\n  51, 19, 59, 27, 49, 17, 57, 25,\n  15, 47,  7, 39, 13, 45,  5, 37,\n  63, 31, 55, 23, 61, 29, 53, 21\n);\n\nfloat getBayerValue(vec2 uv, int size) {\n  ivec2 pos = ivec2(mod(uv, float(size)));\n  int index = pos.y * size + pos.x;\n\n  if (size == 2) {\n    return float(bayer2x2[index]) / 4.0;\n  } else if (size == 4) {\n    return float(bayer4x4[index]) / 16.0;\n  } else if (size == 8) {\n    return float(bayer8x8[index]) / 64.0;\n  }\n  return 0.0;\n}\n\n\nvoid main() {\n  float t = .5 * u_time;\n\n  #define USE_PATTERN_SIZING\n  #define USE_OBJECT_SIZING\n  #define USE_PIXELIZATION\n  // #define ADD_HELPERS\n\n  ${sizingUV}\n\n  vec2 dithering_uv = pxSizeUv;\n  vec2 ditheringNoise_uv = uv;\n  vec2 shape_uv = objectUV;\n  if (u_shape < 3.5) {\n    shape_uv = patternUV;\n  }\n\n  float shape = 0.;\n  if (u_shape < 1.5) {\n    // Simplex noise\n    shape_uv *= .001;\n\n    shape = 0.5 + 0.5 * getSimplexNoise(shape_uv, t);\n    shape = smoothstep(0.3, 0.9, shape);\n\n  } else if (u_shape < 2.5) {\n    // Warp\n    shape_uv *= .003;\n\n    for (float i = 1.0; i < 6.0; i++) {\n      shape_uv.x += 0.6 / i * cos(i * 2.5 * shape_uv.y + t);\n      shape_uv.y += 0.6 / i * cos(i * 1.5 * shape_uv.x + t);\n    }\n\n    shape = .15 / abs(sin(t - shape_uv.y - shape_uv.x));\n    shape = smoothstep(0.02, 1., shape);\n\n  } else if (u_shape < 3.5) {\n    // Dots\n    shape_uv *= .05;\n\n    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);\n    float rand = fract(sin(stripeIdx * 12.9898) * 43758.5453);\n\n    float speed = sign(rand - .5) * ceil(2. + rand);\n    shape = sin(shape_uv.x) * cos(shape_uv.y + speed * t);\n    shape = pow(shape, 6.);\n\n  } else if (u_shape < 4.5) {\n    // Sine wave\n    shape_uv *= 4.;\n\n    float wave = cos(.5 * shape_uv.x - 2. * t) * sin(1.5 * shape_uv.x + t) * (.75 + .25 * cos(3. * t));\n    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);\n\n  } else if (u_shape < 5.5) {\n    // Ripple\n\n    float dist = length(shape_uv);\n    float waves = sin(pow(dist, 1.7) * 7. - 3. * t) * .5 + .5;\n    shape = waves;\n\n  } else if (u_shape < 6.5) {\n    // Swirl\n\n    float l = length(shape_uv);\n    float angle = 6. * atan(shape_uv.y, shape_uv.x) + 4. * t;\n    float twist = 1.2;\n    float offset = pow(l, -twist) + angle / TWO_PI;\n    float mid = smoothstep(0., 1., pow(l, twist));\n    shape = mix(0., fract(offset), mid);\n\n  } else {\n    // Sphere\n    shape_uv *= 2.;\n\n    vec3 pos = vec3(shape_uv, sqrt(1. - pow(length(shape_uv), 2.)));\n    vec3 lightPos = normalize(vec3(cos(1.5 * t), .8, sin(1.25 * t)));\n    shape = .5 + .5 * dot(lightPos, pos);\n  }\n\n\n  int type = int(floor(u_type));\n  float dithering = 0.0;\n\n  switch (type) {\n    case 1: {\n      dithering = step(random(ditheringNoise_uv), shape);\n    } break;\n    case 2:\n      dithering = getBayerValue(dithering_uv, 2);\n      break;\n    case 3:\n      dithering = getBayerValue(dithering_uv, 4);\n      break;\n    default:\n      dithering = getBayerValue(dithering_uv, 8);\n      break;\n  }\n\n  dithering -= .5;\n  float res = step(.5, shape + dithering);\n\n  vec3 color = mix(u_color1.rgb, u_color2.rgb, res);\n  float opacity = mix(u_color1.a, u_color2.a, res);\n\n  #ifdef ADD_HELPERS\n    vec2 helperBox = objectHelperBox;\n    vec2 boxSize = objectBoxSize;\n    if (u_shape < 3.5) {\n      helperBox = patternHelperBox;\n      boxSize = patternBoxSize;\n    }\n    ${drawSizingHelpers}\n  #endif\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DitheringUniforms extends ShaderSizingUniforms {\n  u_color1: [number, number, number, number];\n  u_color2: [number, number, number, number];\n  u_shape: (typeof DitheringShapes)[DitheringShape];\n  u_type: (typeof DitheringTypes)[DitheringType];\n  u_pxSize: number;\n}\n\nexport interface DitheringParams extends ShaderSizingParams, ShaderMotionParams {\n  color1?: string;\n  color2?: string;\n  shape?: DitheringShape;\n  type?: DitheringType;\n  pxSize?: number;\n}\n\nexport const DitheringShapes = {\n  simplex: 1,\n  warp: 2,\n  dots: 3,\n  wave: 4,\n  ripple: 5,\n  swirl: 6,\n  sphere: 7,\n} as const;\n\nexport type DitheringShape = keyof typeof DitheringShapes;\n\nexport const DitheringTypes = {\n  random: 1,\n  '2x2': 2,\n  '4x4': 3,\n  '8x8': 4,\n} as const;\n\nexport type DitheringType = keyof typeof DitheringTypes;\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declareSimplexNoise, declarePI, declareRandom, colorBandingFix } from '../shader-utils';\n\nexport const grainGradientMeta = {\n  maxColorCount: 7,\n} as const;\n\n/**\n * Grainy Gradient Ksenia Kondrashova\n */\nexport const grainGradientFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform vec4 u_colors[${grainGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_noise;\nuniform float u_shape;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareSimplexNoise}\n${declareRandom}\n\n\nfloat noisenoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  // Smoothstep for interpolation\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  // Do the interpolation as two nested mix operations\n  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat rand(vec2 n) {\n  return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm_4(vec2 n) {\n  float total = 0.0, amplitude = .2;\n  for (int i = 0; i < 4; i++) {\n    total += noise(n) * amplitude;\n    n += n;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\n\nvec2 truchet(vec2 uv, float idx){\n    idx = fract(((idx - .5) * 2.));\n    if (idx > 0.75) {\n        uv = vec2(1.0) - uv;\n    } else if (idx > 0.5) {\n        uv = vec2(1.0 - uv.x, uv.y);\n    } else if (idx > 0.25) {\n        uv = 1.0 - vec2(1.0 - uv.x, uv.y);\n    }\n    return uv;\n}\n\nvoid main() {\n  \n  float t = .1 * u_time;\n  \n  vec2 grain_uv = (gl_FragCoord.xy - .5 * u_resolution) / u_pixelRatio;\n  vec2 shape_uv = v_objectUV;\n  if (u_shape < 3.5) {\n    shape_uv = v_patternUV * .005;\n  }\n  \n  \n  float shape = 0.;\n  \n  if (u_shape < 1.5) {\n    // Sine wave\n    \n    float wave = cos(.5 * shape_uv.x - 2. * t) * sin(1.5 * shape_uv.x + t) * (.75 + .25 * cos(3. * t));\n    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);\n      \n  } else if (u_shape < 2.5) {\n    // Grid (dots)\n\n    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);\n    float rand = fract(sin(stripeIdx * 12.9898) * 43758.5453);\n\n    float speed = sign(rand - .5) * ceil(2. + rand);\n    shape = sin(shape_uv.x) * cos(shape_uv.y + speed * t);  \n    shape = pow(shape, 4.);\n  \n  } else if (u_shape < 3.5) {\n    // Truchet pattern\n    \n    float n2 = noisenoise(shape_uv * .4 - 2.5 * t);\n    shape_uv.x += 10.;\n    shape_uv *= .6;\n\n    vec2 tile = truchet(fract(shape_uv), random(floor(shape_uv)));\n\n    float distance1 = length(tile);\n    float distance2 = length(tile - vec2(1.));\n\n    n2 -= .5;\n    n2 *= .1;\n    shape = smoothstep(.2, .55, distance1 + n2) * smoothstep(.8, .45, distance1 - n2);\n    shape += smoothstep(.2, .55, distance2 + n2) * smoothstep(.8, .45, distance2 - n2);\n    \n    shape = pow(shape, 1.5);\n      \n  } else if (u_shape < 4.5) {  \n    // Corners\n\n    shape_uv *= .6;\n    vec2 outer = vec2(.5);\n    \n    vec2 bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(2. * t), .2 - .1 * sin(3. * t)));\n    vec2 tr = smoothstep(vec2(0.), outer, 1. - shape_uv);\n    shape = 1. - bl.x * bl.y * tr.x * tr.y;\n    \n    shape_uv = -shape_uv;\n    bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(2. * t), .2 - .1 * cos(3. * t)));\n    tr = smoothstep(vec2(0.), outer, 1. - shape_uv);\n    shape -= bl.x * bl.y * tr.x * tr.y; \n    \n    shape = 1. - smoothstep(0., 1., shape);\n    \n  } else if (u_shape < 5.5) {  \n    // Ripple\n  \n    shape_uv *= 2.;\n    float dist = length(.4 * shape_uv);\n    float waves = sin(pow(dist, 1.2) * 5. - 3. * t) * .5 + .5;\n    shape = waves;\n\n  } else if (u_shape < 6.5) {\n    // Blob\n\n    t *= 2.;\n       \n    vec2 f1_traj = .25 * vec2(1.3 * sin(t), .2 + 1.3 * cos(.6 * t + 4.));\n    vec2 f2_traj = .2 * vec2(1.2 * sin(-t), 1.3 * sin(1.6 * t));\n    vec2 f3_traj = .25 * vec2(1.7 * cos(-.6 * t), cos(-1.6 * t));\n    vec2 f4_traj = .3 * vec2(1.4 * cos(.8 * t), 1.2 * sin(-.6 * t - 3.));\n    \n    shape = .5 * pow(1. - clamp(0., 1., length(shape_uv + f1_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f2_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f3_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f4_traj)), 5.);\n    \n    shape = smoothstep(.0, .9, shape);\n    float edge = smoothstep(.25, .3, shape);\n    shape = mix(.0, shape, edge);\n    \n  } else {\n    // Sphere\n\n    shape_uv *= 2.;\n    float d = length(shape_uv);\n    float z = sqrt(1.0 - clamp(pow(d, 2.0), 0.0, 1.0));\n    vec3 pos = vec3(shape_uv, z);\n    vec3 lightPos = normalize(vec3(cos(3. * t), 0.8, sin(2.5 * t)));\n    float lighting = dot(lightPos, pos);\n    float edge = smoothstep(1., .97, d);\n    shape = mix(.1, .5 + .5 * lighting, edge);\n  }\n  \n  float snoise05 = snoise(grain_uv * .5);\n  float grainDist = snoise(grain_uv * .2) * snoise05 - fbm_4(.002 * grain_uv + 10.) - fbm_4(.003 * grain_uv);\n  float noise = clamp(.6 * snoise05 - fbm_4(.4 * grain_uv) - fbm_4(.001 * grain_uv), 0., 1.);\n\n  shape += u_intensity * 2. / u_colorsCount * (grainDist + .5);\n  shape += u_noise * 10. / u_colorsCount * noise;  \n\n  float edge_w = fwidth(shape);\n      \n  float mixer = shape;\n  vec3 gradient = u_colors[0].rgb;\n  for (int i = 1; i < ${grainGradientMeta.maxColorCount}; i++) {\n      if (i >= int(u_colorsCount)) break;\n\n      vec2 borders = vec2(float(i) - u_softness, float(i) + u_softness + edge_w) / u_colorsCount;\n      float localT = smoothstep(borders[0], borders[1], mixer);\n      gradient = mix(gradient, u_colors[i].rgb, localT);\n  }\n\n  vec3 color = gradient;\n  float opacity = 1.;\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface GrainGradientUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_softness: number;\n  u_intensity: number;\n  u_noise: number;\n  u_shape: (typeof GrainGradientShapes)[GrainGradientShape];\n}\n\nexport interface GrainGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  softness?: number;\n  intensity?: number;\n  noise?: number;\n  shape?: GrainGradientShape;\n}\n\nexport const GrainGradientShapes = {\n  wave: 1,\n  dots: 2,\n  truchet: 3,\n  corners: 4,\n  ripple: 5,\n  blob: 6,\n  sphere: 7,\n};\n\nexport type GrainGradientShape = keyof typeof GrainGradientShapes;\n", "import type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, declareRotate, declareSimplexNoise, colorBandingFix } from '../shader-utils';\n\n/**\n */\n\nexport const liquidMetalFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform float u_patternBlur;\nuniform float u_patternScale;\nuniform float u_dispersion;\nuniform float u_liquid;\nuniform float u_shape;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n${declareRotate}\n${declareSimplexNoise}\n\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float bump) {\n\n  float ch = c2;\n  float border = 0.;\n  float blur = u_patternBlur + extra_blur;\n  \n  if (u_shape < 1.) {\n    blur += .1 * smoothstep(-.4, -.6, v_responsiveUV.y);\n  }\n\n  ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\n\n  border = w[0];\n  ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n\n  bump = smoothstep(.2, .8, bump);\n  border = w[0] + .4 * (1. - bump) * w[1];\n  ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n\n  border = w[0] + .5 * (1. - bump) * w[1];\n  ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n\n  border = w[0] + w[1];\n  ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n\n  float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n  float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n  ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\n\n  return ch;\n}\n\nvoid main() {\n  \n  float t = .1 * u_time;\n\n  vec2 uv = v_objectUV;\n  uv += .5;\n  uv.y = 1. - uv.y;\n\n  float cycleWidth = .5 * u_patternScale; \n  \n  float mask = 1.;\n  if (u_shape < 1.) {\n  \n    vec2 borderUV = v_responsiveUV + .5;\n    float ratio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n    vec2 edge = min(borderUV, 1. - borderUV);\n    vec2 pixel_thickness = 250. / v_responsiveBoxGivenSize;\n    float maskX = smoothstep(0.0, pixel_thickness.x, edge.x);\n    float maskY = smoothstep(0.0, pixel_thickness.y, edge.y);\n    maskX = pow(maskX, .25);\n    maskY = pow(maskY, .25);\n    mask = clamp(1. - maskX * maskY, 0., 1.);\n    \n    uv = v_responsiveUV;\n    if (ratio > 1.) {\n      uv.y /= ratio;\n    } else {\n      uv.x *= ratio;\n    }\n    uv += .5;\n    uv.y = 1. - uv.y;\n    \n    cycleWidth *= 2.;\n\n  } else if (u_shape < 2.) {  \n    vec2 shapeUV = uv - .5;\n    shapeUV *= .67;\n    mask = pow(clamp(3. * length(shapeUV), 0., 1.), 8.);\n    \n    uv *= 1.3;\n  } else if (u_shape < 3.) {\n    vec2 shapeUV = uv - .5;\n    shapeUV *= 1.68;\n    \n    float r = length(shapeUV) * 2.;\n    float a = atan(shapeUV.y, shapeUV.x) + .2;\n    r *= (1. + .05 * sin(3. * a + 2. * t));\n    float f = abs(cos(a * 3.));\n    mask = smoothstep(f, f + .7, r);\n    \n    uv *= .8;\n    cycleWidth *= 1.6;\n\n  } else if (u_shape < 4.) {\n    vec2 shapeUV = uv - .5;\n    shapeUV *= 1.3;\n    mask = 0.;\n    for (int i = 0; i < 5; i++) {\n      float fi = float(i);\n      float speed = 4.5 + 2. * sin(fi * 12.345);\n      float angle = -fi * 1.5;\n      vec2 dir1 = vec2(cos(angle), sin(angle));\n      vec2 dir2 = vec2(cos(angle + 1.57), sin(angle + 1.));\n      vec2 traj = .4 * (dir1 * sin(t * speed + fi * 1.23) + dir2 * cos(t * (speed * 0.7) + fi * 2.17));\n      float d = length(shapeUV + traj);\n      mask += pow(1.0 - clamp(d, 0.0, 1.0), 4.0);\n    }\n    mask = 1. - smoothstep(.85, 1., mask);\n    \n    uv *= 1.3;\n    uv.y += .2;\n  }\n\n  float contour = smoothstep(0., 1., mask) * smoothstep(1., 0., mask);\n\n\n  float diagBLtoTR = uv.x - uv.y;    \n  float diagTLtoBR = uv.x + uv.y;\n\n  vec3 color = vec3(0.);\n  float opacity = 1.;\n\n  vec3 color1 = vec3(.98, 0.98, 1.);\n  vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, diagTLtoBR));\n\n  vec2 grad_uv = uv - .5;\n  \n  float dist = length(grad_uv + vec2(0., .2 * diagBLtoTR));\n  grad_uv = rotate(grad_uv, (.25 - .2 * diagBLtoTR) * PI);\n  float direction = grad_uv.x;\n\n  float bump = pow(1.8 * dist, 1.2);\n  bump = 1. - bump;\n  bump *= pow(uv.y, .3);\n\n\n  float thin_strip_1_ratio = .12 / cycleWidth * (1. - .4 * bump);\n  float thin_strip_2_ratio = .07 / cycleWidth * (1. + .4 * bump);\n  float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n\n  float thin_strip_1_width = cycleWidth * thin_strip_1_ratio;\n  float thin_strip_2_width = cycleWidth * thin_strip_2_ratio;\n\n  opacity = 1. - smoothstep(.9, .92, mask);\n\n  float noise = snoise(uv - t);\n\n  mask += (1. - mask) * u_liquid * noise;\n\n  float colorDispersion = 0.;\n  colorDispersion += (1. - bump);\n  colorDispersion = clamp(colorDispersion, 0., 1.);\n\n  direction += diagBLtoTR;\n\n  direction -= 2. * noise * contour;\n\n  bump *= clamp(pow(uv.y, .1), .3, 1.);\n  direction *= (.1 + (1.1 - mask) * bump);\n  direction *= smoothstep(1., .7, mask);\n\n  float ridge = .2 * (smoothstep(.0, .15, uv.y) * smoothstep(.4, .15, uv.y));\n  ridge += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\n  direction += ridge;\n\n  direction *= (.5 + .5 * pow(uv.y, 2.));\n\n  direction *= cycleWidth;\n\n  direction -= t;\n\n  float dispersionRed = colorDispersion;\n  dispersionRed += .03 * bump * noise;\n  float dispersionBlue = 1.3 * colorDispersion;\n\n  dispersionRed += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bump) * smoothstep(1., .4, bump));\n  dispersionRed -= diagBLtoTR;\n\n  dispersionBlue += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bump) * smoothstep(.8, .4, bump));\n  dispersionBlue -= .2 * mask;\n\n  dispersionRed *= u_dispersion;\n  dispersionBlue *= u_dispersion;\n\n  vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n  w[1] -= .02 * smoothstep(.0, 1., mask + bump);\n  float extraBlur = bump;\n  float stripe_r = mod(direction + dispersionRed, 1.);\n  float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_dispersion * bump, extraBlur);\n  float stripe_g = mod(direction, 1.);\n  float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - 0. * diagBLtoTR), extraBlur);\n  float stripe_b = mod(direction - dispersionBlue, 1.);\n  float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, extraBlur);\n\n  color = vec3(r, g, b);\n  color *= opacity;\n\n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface LiquidMetalUniforms extends ShaderSizingUniforms {\n  u_patternBlur: number;\n  u_patternScale: number;\n  u_dispersion: number;\n  u_liquid: number;\n  u_shape: number;\n}\n\nexport interface LiquidMetalParams extends ShaderSizingParams, ShaderMotionParams {\n  patternBlur?: number;\n  patternScale?: number;\n  dispersion?: number;\n  liquid?: number;\n  shape?: number;\n}\n", "import type { vec4 } from '../types';\nimport type { ShaderMotionParams } from '../shader-mount';\nimport { sizingVariablesDeclaration, type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing';\nimport { declarePI, colorBandingFix } from '../shader-utils';\n\nexport const pulsingBorderMeta = {\n  maxColorCount: 5,\n  maxSpotsPerColor: 5,\n} as const;\n\n/**\n * Pulsing Border Pattern with Smoke Effect\n * This shader creates a rounded border mask with multiple color spots\n * traveling along the border\n *\n * Uniforms include:\n * u_colorBack   - The background color of the pattern\n * u_colors      - An array of colors for the pulsing spots (with up to `u_colorsCount` entries)\n * u_colorsCount - The number of colors used in the pattern\n * u_roundness   - The roundness of the border corners\n * u_thickness   - The thickness of the border\n * u_softness    - The blur around the border edges\n * u_intensity   - The intensity multiplier for the pulsing effect\n * u_spotSize    - The size of the color spots\n * u_spotsPerColor - The number of spots for each color (not all the spots are visible all the time)\n * u_pulse     - A multiplier for the pulsing strength (pulsing signal taken from the u_pulseTexture)\n * u_smoke       - The strength of the smoke effect (the noise aroung the border)\n */\n\nexport const pulsingBorderFragmentShader: string = `#version 300 es\nprecision lowp float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${pulsingBorderMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_roundness;\nuniform float u_thickness;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_spotSize;\nuniform float u_spotsPerColor;\nuniform float u_pulse;\nuniform float u_smoke;\nuniform float u_smokeSize;\n\nuniform sampler2D u_pulseTexture;\nuniform sampler2D u_noiseTexture;\n\n${sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${declarePI}\n\nfloat roundedBox(vec2 uv, vec2 halfSize, float radius, float distance, float edgeSoftness) {\n    \n    float borderDistance = abs(distance) - .5 * u_thickness;\n    float border = 1. - smoothstep(-.5 * edgeSoftness, .5 * edgeSoftness, borderDistance);\n    border *= border;\n\n    vec2 v0 = uv + halfSize;\n    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);\n    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);\n    vec2 v3 = uv - halfSize;\n    \n    float mult = (.07 - .25 * radius);\n    float m0 = mult * clamp(pow(1. - abs(v0.x - v0.y), 20.), 0., 1.);\n    float m1 = mult * clamp(pow(1. - abs(v1.x + v1.y), 20.), 0., 1.);\n    float m2 = mult * clamp(pow(1. - abs(v2.x + v2.y), 20.), 0., 1.);\n    float m3 = mult * clamp(pow(1. - abs(v3.x - v3.y), 20.), 0., 1.);\n    \n    float l = edgeSoftness * .5 + .75 * u_thickness;\n    float fade0 = 1. - clamp(length(v0) / l, 0., 1.);\n    float fade1 = 1. - clamp(length(v1) / l, 0., 1.);\n    float fade2 = 1. - clamp(length(v2) / l, 0., 1.);\n    float fade3 = 1. - clamp(length(v3) / l, 0., 1.);\n    \n    m0 *= fade0;\n    m1 *= fade1;\n    m2 *= fade2;\n    m3 *= fade3;\n    \n    float fillFix = m0 + m1 + m2 + m3;\n    fillFix *= step(distance, 0.);\n    fillFix *= (1. + 3. * u_thickness);\n    fillFix *= (1.5 - .5 * smoothstep(0., .5, edgeSoftness));\n    fillFix = clamp(fillFix, 0., 1.);\n\n    return border + fillFix;\n}\n\nfloat roundedBoxSmoke(vec2 uv, vec2 halfSize, float radius, float distance, float size) {\n    float borderDistance = abs(distance);\n    float border = 1. - smoothstep(-.75 * size, .75 * size, borderDistance);\n    border *= border;\n\n    vec2 v0 = uv + halfSize;\n    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);\n    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);\n    vec2 v3 = uv - halfSize;\n    \n    float l_mask = .5;\n    float mask = smoothstep(0., 1., length(v0) / l_mask);\n    mask *= smoothstep(0., 1., length(v1) / l_mask);\n    mask *= smoothstep(0., 1., length(v2) / l_mask);\n    mask *= smoothstep(0., 1., length(v3) / l_mask);\n\n    return border * mask;\n}\n\nvec2 rand(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, uv).gb;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = rand(i).x;\n  float b = rand(i + vec2(1.0, 0.0)).x;\n  float c = rand(i + vec2(0.0, 1.0)).x;\n  float d = rand(i + vec2(1.0, 1.0)).x;\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat getWaveformValue(float time) {\n  float dur = 5.;\n  float wrappedTime = mod(time, dur);\n  float normalizedTime = wrappedTime / dur;\n  float value = texture(u_pulseTexture, vec2(normalizedTime, 0.5)).r;\n  return value * 2. - 1.;\n}\n\nvoid main() {\n\n  float t = .5 * u_time + 20.;\n  \n  vec2 borderUV = v_responsiveUV;\n\n  float angle = atan(borderUV.y, borderUV.x) / TWO_PI;\n  \n  \n  float borderRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  borderUV.x *= borderRatio;\n  vec2 halfSize = vec2(.5);\n  halfSize.x *= borderRatio;\n  float radius = min(.5 * u_roundness, halfSize.x);\n  vec2 d = abs(borderUV) - halfSize + radius;\n  float outsideDistance = length(max(d, 0.)) - radius;\n  float insideDistance = min(max(d.x, d.y), 0.0);\n  float distance = outsideDistance + insideDistance;\n    \n  float border = roundedBox(borderUV, halfSize, radius, distance, .5 * u_softness);\n\n  float pulse = u_pulse * getWaveformValue(.18 * u_time);\n  \n  border *= (1. + .1 * pulse);\n  border *= (1. + u_intensity);\n\n  vec2 smokeUV = .001 * u_smokeSize * v_patternUV;\n  float smoke = clamp(3. * noise(2.7 * smokeUV + .5 * t), 0., 1.);\n  smoke -= noise(3.4 * smokeUV - .5 * t);\n  smoke *= roundedBoxSmoke(borderUV, halfSize, radius, distance, u_smoke);\n  smoke = 50. * pow(smoke, 2.);\n  smoke *= u_smoke;\n  smoke *= (.8 + .4 * pulse);\n  smoke = clamp(smoke, 0., 1.);\n\n  border += smoke;\n\n  float sectorsTotal = 0.;\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  \n  vec3 accumColor = vec3(0.);\n  float accumAlpha = 0.;\n  \n  for (int i = 0; i < ${pulsingBorderMeta.maxSpotsPerColor}; i++) {\n    if (i >= int(u_spotsPerColor)) break;\n    float idx = float(i);\n  \n    for (int j = 0; j < ${pulsingBorderMeta.maxColorCount}; j++) {\n      if (j >= int(u_colorsCount)) break;\n      float colorIdx = float(j);\n\n      vec2 randVal = rand(vec2(idx * 10. + 2., 40. + colorIdx));\n  \n      float time = (.1 + .15 * abs(sin(idx * (2. + colorIdx)) * cos(idx * (2. + 2.5 * colorIdx)))) * t + randVal.x * 3.;\n      time *= mix(1., -1., step(.5, randVal.y));\n  \n      float mask = .2 + mix(\n        sin(t + idx * (5. - 1.5 * colorIdx)),\n        cos(t + idx * (3. + 1.3 * colorIdx)),\n        step(mod(colorIdx, 2.), .5)\n      );\n      \n      mask += pulse;\n      if (mask < 0.) continue;\n  \n      float atg1 = fract(angle + time);\n      float sector = smoothstep(.5 - u_spotSize, .5, atg1) * smoothstep(.5 + u_spotSize, .5, atg1);\n      sector *= border;\n      sector *= mask;\n      sector = clamp(sector, 0., 1.);\n      \n      sectorsTotal += sector;\n      \n      float alpha = sector * u_colors[j].a;\n      accumColor += u_colors[j].rgb * alpha;\n      accumAlpha += alpha;\n    }\n  }\n  \n  color = accumColor;\n  opacity = clamp(accumAlpha, 0., 1.);\n  \n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n  \n  ${colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PulsingBorderUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_roundness: number;\n  u_thickness: number;\n  u_softness: number;\n  u_intensity: number;\n  u_spotsPerColor: number;\n  u_spotSize: number;\n  u_pulse: number;\n  u_smoke: number;\n  u_smokeSize: number;\n  u_pulseTexture?: HTMLImageElement;\n}\n\nexport interface PulsingBorderParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  roundness?: number;\n  thickness?: number;\n  softness?: number;\n  intensity?: number;\n  spotsPerColor?: number;\n  spotSize?: number;\n  pulse?: number;\n  smoke?: number;\n  smokeSize?: number;\n}\n", "/**  Convert color string from HSL, RGB, or hex to 0-to-1-range-RGBA array */\nexport function getShaderColorFromString(\n  colorString: string | [number, number, number] | [number, number, number, number] | undefined\n): [number, number, number, number] {\n  // If the color string is already an array of 3 or 4 numbers, return it (with alpha=1 if needed)\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString as [number, number, number, number];\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n\n  // If the color string is not a string, return the fallback\n  if (typeof colorString !== 'string') {\n    return fallbackColor;\n  }\n\n  let r: number,\n    g: number,\n    b: number,\n    a = 1;\n  if (colorString.startsWith('#')) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith('rgb')) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith('hsl')) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error('Unsupported color format', colorString);\n    return fallbackColor;\n  }\n\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\n\n/** Convert hex to RGBA (0 to 1 range) */\nfunction hexToRgba(hex: string): [number, number, number, number] {\n  // Remove # if present\n  hex = hex.replace(/^#/, '');\n\n  // Expand three-letter hex to six-letter\n  if (hex.length === 3) {\n    hex = hex\n      .split('')\n      .map((char) => char + char)\n      .join('');\n  }\n  // Expand six-letter hex to eight-letter (add full opacity if no alpha)\n  if (hex.length === 6) {\n    hex = hex + 'ff';\n  }\n\n  // Parse the components\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n\n  return [r, g, b, a];\n}\n\n/** Parse RGBA string to RGBA (0 to 1 range) */\nfunction parseRgba(rgba: string): [number, number, number, number] {\n  // Match both rgb and rgba patterns\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n\n  return [\n    parseInt(match[1] ?? '0') / 255,\n    parseInt(match[2] ?? '0') / 255,\n    parseInt(match[3] ?? '0') / 255,\n    match[4] === undefined ? 1 : parseFloat(match[4]),\n  ];\n}\n\n/** Parse HSLA string */\nfunction parseHsla(hsla: string): [number, number, number, number] {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n\n  return [\n    parseInt(match[1] ?? '0'),\n    parseInt(match[2] ?? '0'),\n    parseInt(match[3] ?? '0'),\n    match[4] === undefined ? 1 : parseFloat(match[4]),\n  ];\n}\n\n/** Convert HSLA to RGBA (0 to 1 range) */\nfunction hslaToRgba(hsla: [number, number, number, number]): [number, number, number, number] {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n\n  if (s === 0) {\n    r = g = b = lDecimal; // achromatic\n  } else {\n    const hue2rgb = (p: number, q: number, t: number) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n\n  return [r, g, b, a];\n}\n\nexport const clamp = (n: number, min: number, max: number): number => Math.min(Math.max(n, min), max);\n\nconst fallbackColor = [0, 0, 0, 1] as [0, 0, 0, 1];\n", "export function getShaderNoiseTexture(texture = 0): HTMLImageElement {\n  if (typeof window === 'undefined') {\n    throw new Error('Paper Shaders: can\u2019t create a texture on the server');\n  }\n\n  let src = '';\n  if (texture === 0) {\n    // RGB randomizer\n    src =\n      'data:image/png;base64,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';\n  } else if (texture === 1) {\n    // pulsing signal\n    src =\n      'data:image/png;base64,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';\n  }\n\n  const img = new Image();\n  img.src = src;\n  return img;\n}\n", "import * as React from 'react';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nexport function useMergeRefs<Instance>(refs: Array<React.Ref<Instance> | undefined>): null | React.Ref<Instance> {\n  const cleanupRef = React.useRef<void | (() => void)>(undefined);\n\n  const refEffect = React.useCallback((instance: Instance | null) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n\n      if (typeof ref === 'function') {\n        const refCallback = ref;\n        const refCleanup: void | (() => void) = refCallback(instance);\n        return typeof refCleanup === 'function'\n          ? refCleanup\n          : () => {\n              refCallback(null);\n            };\n      }\n\n      (ref as React.RefObject<Instance | null>).current = instance;\n      return () => {\n        (ref as React.RefObject<Instance | null>).current = null;\n      };\n    });\n\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n\n  return React.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        (cleanupRef as React.RefObject<void | (() => void)>).current = undefined;\n      }\n\n      if (value != null) {\n        (cleanupRef as React.RefObject<void | (() => void)>).current = refEffect(value);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  meshGradientFragmentShader,\n  ShaderFitOptions,\n  type MeshGradientParams,\n  type MeshGradientUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface MeshGradientProps extends ShaderComponentProps, MeshGradientParams {}\n\ntype MeshGradientPreset = ShaderPreset<MeshGradientParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: MeshGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 40000,\n    colors: ['#5100ff', '#00ff80', '#ffcc00', '#ea00ff'],\n    distortion: 0.8,\n    swirl: 0.1,\n  },\n};\n\nexport const purplePreset: MeshGradientPreset = {\n  name: 'Purple',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.6,\n    frame: 100,\n    colors: ['#aaa7d7', '#3c2b8e', '#f4eabb', '#c99cd5'],\n    distortion: 0.3,\n    swirl: 0.5,\n  },\n};\n\nexport const beachPreset: MeshGradientPreset = {\n  name: 'Beach',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.1,\n    frame: 0,\n    colors: ['#bcecf6', '#80c3e4', '#f3eccb', '#f3d987'],\n    distortion: 0.8,\n    swirl: 0.35,\n  },\n};\n\nexport const meshGradientPresets: MeshGradientPreset[] = [defaultPreset, purplePreset, beachPreset];\n\nexport const MeshGradient: React.FC<MeshGradientProps> = memo(function MeshGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: MeshGradientProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_distortion: distortion,\n    u_swirl: swirl,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies MeshGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={meshGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "interface PropsWithColors {\n  colors?: string[];\n  [key: string]: unknown;\n}\n\nexport function colorPropsAreEqual(prevProps: PropsWithColors, nextProps: PropsWithColors): boolean {\n  for (const key in prevProps) {\n    if (key === 'colors') {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n\n        continue;\n      }\n\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  smokeRingFragmentShader,\n  ShaderFitOptions,\n  type ShaderPreset,\n  type SmokeRingParams,\n  type SmokeRingUniforms,\n} from '@paper-design/shaders';\n\nexport interface SmokeRingProps extends ShaderComponentProps, SmokeRingParams {}\n\ntype SmokeRingPreset = ShaderPreset<SmokeRingParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: SmokeRingPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.4,\n    frame: 0,\n    colorBack: '#ffffff',\n    colors: ['#136c5e', '#0f0224'],\n    noiseScale: 5,\n    noiseIterations: 10,\n    radius: 0.5,\n    thickness: 0.25,\n    innerShape: 1.2,\n  },\n};\n\nexport const poisonPreset: SmokeRingPreset = {\n  name: 'Poison',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#d4ff00', '#0c7f08'],\n    noiseScale: 2.2,\n    noiseIterations: 10,\n    radius: 0.4,\n    thickness: 0.2,\n    innerShape: 0.6,\n  },\n};\n\nexport const linePreset: SmokeRingPreset = {\n  name: 'Line',\n  params: {\n    ...defaultObjectSizing,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#1fe8ff', '#4540a4'],\n    noiseScale: 1.1,\n    noiseIterations: 2,\n    radius: 0.38,\n    thickness: 0.01,\n    innerShape: 0.88,\n    speed: 4,\n  },\n};\n\nexport const cloudPreset: SmokeRingPreset = {\n  name: 'Cloud',\n  params: {\n    ...defaultObjectSizing,\n    frame: 0,\n    colorBack: '#3b9bff',\n    colors: ['#ffffff'],\n    noiseScale: 1.5,\n    noiseIterations: 10,\n    radius: 0.5,\n    thickness: 0.65,\n    innerShape: 0.9,\n    speed: 0.5,\n  },\n};\n\nexport const smokeRingPresets: SmokeRingPreset[] = [defaultPreset, linePreset, poisonPreset, cloudPreset];\n\nexport const SmokeRing: React.FC<SmokeRingProps> = memo(function SmokeRingImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  noiseScale = defaultPreset.params.noiseScale,\n  thickness = defaultPreset.params.thickness,\n  radius = defaultPreset.params.radius,\n  innerShape = defaultPreset.params.innerShape,\n  noiseIterations = defaultPreset.params.noiseIterations,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SmokeRingProps) {\n  const noiseTexture = typeof window !== 'undefined' && { u_noiseTexture: getShaderNoiseTexture() };\n\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_noiseScale: noiseScale,\n    u_thickness: thickness,\n    u_radius: radius,\n    u_innerShape: innerShape,\n    u_noiseIterations: noiseIterations,\n    ...noiseTexture,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SmokeRingUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={smokeRingFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  neuroNoiseFragmentShader,\n  ShaderFitOptions,\n  type NeuroNoiseParams,\n  type NeuroNoiseUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface NeuroNoiseProps extends ShaderComponentProps, NeuroNoiseParams {}\n\ntype NeuroNoisePreset = ShaderPreset<NeuroNoiseParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: NeuroNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorFront: '#bf9eff',\n    colorBack: '#000000',\n    brightness: 1.3,\n  },\n};\n\nconst marblePreset: NeuroNoisePreset = {\n  name: 'Marble',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.4,\n    speed: 0,\n    frame: 0,\n    colorFront: '#1d2131',\n    colorBack: '#f7f7f7',\n    brightness: 1.1,\n  },\n};\n\nexport const neuroNoisePresets: NeuroNoisePreset[] = [defaultPreset, marblePreset] as const;\n\nexport const NeuroNoise: React.FC<NeuroNoiseProps> = memo(function NeuroNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  brightness = defaultPreset.params.brightness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: NeuroNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_brightness: brightness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies NeuroNoiseUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={neuroNoiseFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  getShaderColorFromString,\n  dotOrbitFragmentShader,\n  ShaderFitOptions,\n  type DotOrbitParams,\n  type DotOrbitUniforms,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\nexport interface DotOrbitProps extends ShaderComponentProps, DotOrbitParams {}\n\ntype DotOrbitPreset = ShaderPreset<DotOrbitParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: DotOrbitPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 2,\n    frame: 0,\n    colors: ['#661400', '#ccbb00', '#cc0088'],\n    size: 1,\n    sizeRange: 0,\n    spreading: 1,\n    stepsPerColor: 2,\n  },\n};\n\nexport const dotOrbitPresets: DotOrbitPreset[] = [defaultPreset];\n\nexport const DotOrbit: React.FC<DotOrbitProps> = memo(function DotOrbitImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  size = defaultPreset.params.size,\n  sizeRange = defaultPreset.params.sizeRange,\n  spreading = defaultPreset.params.spreading,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: DotOrbitProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_size: size,\n    u_sizeRange: sizeRange,\n    u_spreading: spreading,\n    u_stepsPerColor: stepsPerColor,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DotOrbitUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={dotOrbitFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  getShaderColorFromString,\n  dotGridFragmentShader,\n  DotGridShapes,\n  ShaderFitOptions,\n  type DotGridParams,\n  type DotGridUniforms,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport interface DotGridProps extends ShaderComponentProps, DotGridParams {}\n\ntype DotGridPreset = ShaderPreset<DotGridParams>;\n\nexport const defaultPreset: DotGridPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#000000',\n    colorFill: '#ffffff',\n    colorStroke: '#00000000',\n    size: 2,\n    gapX: 50,\n    gapY: 50,\n    strokeWidth: 0,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'circle',\n  },\n};\n\nexport const macrodataPreset: DotGridPreset = {\n  name: 'Macrodata',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#15212d',\n    colorFill: '#5794ff',\n    colorStroke: '#00000000',\n    size: 3,\n    gapX: 25,\n    gapY: 25,\n    strokeWidth: 0,\n    sizeRange: 0.25,\n    opacityRange: 0.9,\n    shape: 'circle',\n  },\n};\n\nconst trianglesPreset: DotGridPreset = {\n  name: 'Triangles',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#ffffff',\n    colorFill: '#ffffff',\n    colorStroke: '#808080',\n    size: 5,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'triangle',\n  },\n};\n\nconst bubblesPreset: DotGridPreset = {\n  name: 'Bubbles',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#002c9e80',\n    colorFill: '#ffffff',\n    colorStroke: '#000000',\n    size: 15,\n    gapX: 60,\n    gapY: 60,\n    strokeWidth: 12,\n    sizeRange: 0.7,\n    opacityRange: 1.3,\n    shape: 'circle',\n  },\n};\n\nconst treeLinePreset: DotGridPreset = {\n  name: 'Tree line',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#f4fce7',\n    colorFill: '#052e19',\n    colorStroke: '#00000000',\n    size: 8,\n    gapX: 20,\n    gapY: 90,\n    strokeWidth: 0,\n    sizeRange: 1,\n    opacityRange: 0.6,\n    shape: 'circle',\n  },\n};\n\nconst diamondsPreset: DotGridPreset = {\n  name: 'Diamonds',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#ffffff',\n    colorFill: '#ff0000',\n    colorStroke: '#00000000',\n    size: 15,\n    gapX: 30,\n    gapY: 30,\n    strokeWidth: 0,\n    sizeRange: 0,\n    opacityRange: 2,\n    shape: 'diamond',\n  },\n};\n\nconst wallpaperPreset: DotGridPreset = {\n  name: 'Wallpaper',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#204030',\n    colorFill: '#00000000',\n    colorStroke: '#bd955b',\n    size: 9,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'diamond',\n  },\n};\n\nconst matrixPreset: DotGridPreset = {\n  name: 'Enter the Matrix',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#000000',\n    colorFill: '#47ffea',\n    colorStroke: '#00000000',\n    size: 2,\n    gapX: 10,\n    gapY: 10,\n    strokeWidth: 0.5,\n    sizeRange: 0.25,\n    opacityRange: 1,\n    shape: 'triangle',\n  },\n};\n\nconst waveformPreset: DotGridPreset = {\n  name: 'Waveform',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#ffffff',\n    colorFill: '#0934b8',\n    colorStroke: '#00000000',\n    size: 100,\n    gapX: 2,\n    gapY: 215,\n    strokeWidth: 0,\n    sizeRange: 1,\n    opacityRange: 0,\n    shape: 'square',\n  },\n};\n\nexport const dotGridPresets: DotGridPreset[] = [\n  defaultPreset,\n  macrodataPreset,\n  trianglesPreset,\n  bubblesPreset,\n  treeLinePreset,\n  diamondsPreset,\n  wallpaperPreset,\n  matrixPreset,\n  waveformPreset,\n];\n\nexport const DotGrid: React.FC<DotGridProps> = memo(function DotGridImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorFill = defaultPreset.params.colorFill,\n  colorStroke = defaultPreset.params.colorStroke,\n  size = defaultPreset.params.size,\n  gapX = defaultPreset.params.gapX,\n  gapY = defaultPreset.params.gapY,\n  strokeWidth = defaultPreset.params.strokeWidth,\n  sizeRange = defaultPreset.params.sizeRange,\n  opacityRange = defaultPreset.params.opacityRange,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n\n  // Other props\n  maxPixelCount = 6016 * 3384, // Higher max resolution for this shader\n  ...props\n}: DotGridProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorFill: getShaderColorFromString(colorFill),\n    u_colorStroke: getShaderColorFromString(colorStroke),\n    u_dotSize: size,\n    u_gapX: gapX,\n    u_gapY: gapY,\n    u_strokeWidth: strokeWidth,\n    u_sizeRange: sizeRange,\n    u_opacityRange: opacityRange,\n    u_shape: DotGridShapes[shape],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DotGridUniforms;\n\n  return (\n    <ShaderMount {...props} maxPixelCount={maxPixelCount} fragmentShader={dotGridFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  getShaderColorFromString,\n  simplexNoiseFragmentShader,\n  ShaderFitOptions,\n  type SimplexNoiseUniforms,\n  type SimplexNoiseParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\nexport interface SimplexNoiseProps extends ShaderComponentProps, SimplexNoiseParams {}\n\ntype SimplexNoisePreset = ShaderPreset<SimplexNoiseParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: SimplexNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#40a0bf', '#bf4040', '#ffcc00'],\n    stepsPerColor: 3,\n    softness: 0,\n  },\n};\n\nexport const simplexNoisePresets: SimplexNoisePreset[] = [defaultPreset];\n\nexport const SimplexNoise: React.FC<SimplexNoiseProps> = memo(function SimplexNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SimplexNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_stepsPerColor: stepsPerColor,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SimplexNoiseUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={simplexNoiseFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  metaballsFragmentShader,\n  ShaderFitOptions,\n  type MetaballsParams,\n  type MetaballsUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface MetaballsProps extends ShaderComponentProps, MetaballsParams {}\n\ntype MetaballsPreset = ShaderPreset<MetaballsParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: MetaballsPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 1,\n    frame: 0,\n    colors: ['#b399ff', '#99ffc4', '#ffe699', '#e099ff'],\n    count: 7,\n    size: 1,\n  },\n};\n\nexport const metaballsPresets: MetaballsPreset[] = [defaultPreset];\n\nexport const Metaballs: React.FC<MetaballsProps> = memo(function MetaballsImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  size = defaultPreset.params.size,\n  count = defaultPreset.params.count,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: MetaballsProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_size: size,\n    u_count: count,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies MetaballsUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={metaballsFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  wavesFragmentShader,\n  ShaderFitOptions,\n  type WavesParams,\n  type WavesUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface WavesProps extends ShaderComponentProps, WavesParams {}\n\ntype WavesPreset = ShaderPreset<WavesParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: WavesPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.6,\n    rotation: 0,\n    color1: '#ffffff',\n    color2: '#102c70',\n    shape: 0,\n    frequency: 0.5,\n    amplitude: 0.6,\n    spacing: 0.65,\n    proportion: 0.15,\n    softness: 0,\n  },\n};\n\nexport const spikesPreset: WavesPreset = {\n  name: 'Spikes',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 2.3,\n    rotation: 0,\n    color1: '#fdffe6',\n    color2: '#34123b',\n    shape: 0,\n    frequency: 0.5,\n    amplitude: 0.9,\n    spacing: 0.37,\n    proportion: 0.93,\n    softness: 0.15,\n  },\n};\n\nexport const groovyPreset: WavesPreset = {\n  name: 'Groovy',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.5,\n    rotation: 1,\n    color1: '#fcfcee',\n    color2: '#ff896b',\n    shape: 2.37,\n    frequency: 0.2,\n    amplitude: 0.67,\n    spacing: 1.17,\n    proportion: 0.57,\n    softness: 0,\n  },\n};\n\nexport const tangledUpPreset: WavesPreset = {\n  name: 'Tangled up',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 3.04,\n    rotation: 1,\n    color1: '#133a41',\n    color2: '#c2d8b6',\n    shape: 3,\n    frequency: 0.44,\n    amplitude: 0.57,\n    spacing: 1.05,\n    proportion: 0.97,\n    softness: 0,\n  },\n};\n\nexport const zigZagPreset: WavesPreset = {\n  name: 'Zig zag',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 2.7,\n    rotation: 1,\n    color1: '#000000',\n    color2: '#e6e6e6',\n    shape: 0,\n    frequency: 0.6,\n    amplitude: 0.8,\n    spacing: 0.5,\n    proportion: 1,\n    softness: 0.5,\n  },\n};\n\nexport const waveRidePreset: WavesPreset = {\n  name: 'Ride the wave',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.84,\n    rotation: 0,\n    color1: '#fdffe6',\n    color2: '#1f1f1f',\n    shape: 2.23,\n    frequency: 0.1,\n    amplitude: 0.6,\n    spacing: 0.41,\n    proportion: 0.99,\n    softness: 0,\n  },\n};\n\nexport const wavesPresets: WavesPreset[] = [\n  defaultPreset,\n  spikesPreset,\n  groovyPreset,\n  tangledUpPreset,\n  zigZagPreset,\n  waveRidePreset,\n];\n\nexport const Waves: React.FC<WavesProps> = memo(function WavesImpl({\n  // Own props\n  color1 = defaultPreset.params.color1,\n  color2 = defaultPreset.params.color2,\n  shape = defaultPreset.params.shape,\n  frequency = defaultPreset.params.frequency,\n  amplitude = defaultPreset.params.amplitude,\n  spacing = defaultPreset.params.spacing,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n\n  // Other props\n  maxPixelCount = 6016 * 3384, // Higher max resolution for this shader\n  ...props\n}: WavesProps) {\n  const uniforms = {\n    // Own uniforms\n    u_color1: getShaderColorFromString(color1),\n    u_color2: getShaderColorFromString(color2),\n    u_shape: shape,\n    u_frequency: frequency,\n    u_amplitude: amplitude,\n    u_spacing: spacing,\n    u_proportion: proportion,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies WavesUniforms;\n\n  return <ShaderMount {...props} fragmentShader={wavesFragmentShader} uniforms={uniforms} />;\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  perlinNoiseFragmentShader,\n  ShaderFitOptions,\n  type PerlinNoiseParams,\n  type PerlinNoiseUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface PerlinNoiseProps extends ShaderComponentProps, PerlinNoiseParams {}\n\ntype PerlinNoisePreset = ShaderPreset<PerlinNoiseParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: PerlinNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.5,\n    frame: 0,\n    color1: '#262626',\n    color2: '#d9d9d9',\n    proportion: 0.35,\n    softness: 0.1,\n    octaveCount: 2,\n    persistence: 1,\n    lacunarity: 1.5,\n  },\n};\n\nexport const nintendoWaterPreset: PerlinNoisePreset = {\n  name: 'Nintendo Water',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.2,\n    speed: 0.4,\n    frame: 0,\n    color1: '#2d69d4',\n    color2: '#d1eefc',\n    proportion: 0.42,\n    softness: 0,\n    octaveCount: 2,\n    persistence: 0.55,\n    lacunarity: 1.8,\n  },\n};\n\nexport const colonyPreset: PerlinNoisePreset = {\n  name: 'Colony',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.15,\n    speed: 0,\n    frame: 0,\n    color1: '#f4f0ae',\n    color2: '#0a1a5e',\n    octaveCount: 6,\n    persistence: 1,\n    lacunarity: 2.55,\n    proportion: 0.65,\n    softness: 0.35,\n  },\n};\n\nexport const phosphenesPreset: PerlinNoisePreset = {\n  name: 'Phosphenes',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.03,\n    speed: 0.15,\n    frame: 0,\n    color1: '#ec7c8b',\n    color2: '#66cc99',\n    proportion: 0.45,\n    softness: 0.45,\n    octaveCount: 6,\n    persistence: 0.3,\n    lacunarity: 3,\n  },\n};\n\nexport const mossPreset: PerlinNoisePreset = {\n  name: 'Moss',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.15,\n    speed: 0.02,\n    frame: 0,\n    color1: '#05ff4a',\n    color2: '#262626',\n    proportion: 0.65,\n    softness: 0.35,\n    octaveCount: 6,\n    persistence: 1,\n    lacunarity: 2.55,\n  },\n};\n\nexport const wormsPreset: PerlinNoisePreset = {\n  name: 'Worms',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 2,\n    speed: 0,\n    frame: 0,\n    color1: '#ffffff',\n    color2: '#595959',\n    proportion: 0.5,\n    softness: 0,\n    octaveCount: 1,\n    persistence: 1,\n    lacunarity: 1.5,\n  },\n};\n\nexport const perlinNoisePresets: PerlinNoisePreset[] = [\n  defaultPreset,\n  nintendoWaterPreset,\n  colonyPreset,\n  phosphenesPreset,\n  mossPreset,\n  wormsPreset,\n];\n\nexport const PerlinNoise: React.FC<PerlinNoiseProps> = memo(function PerlinNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  color1 = defaultPreset.params.color1,\n  color2 = defaultPreset.params.color2,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  octaveCount = defaultPreset.params.octaveCount,\n  persistence = defaultPreset.params.persistence,\n  lacunarity,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  ...props\n}: PerlinNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_color1: getShaderColorFromString(color1),\n    u_color2: getShaderColorFromString(color2),\n    u_proportion: proportion,\n    u_softness: softness ?? defaultPreset.params.softness,\n    u_octaveCount: octaveCount ?? defaultPreset.params.octaveCount,\n    u_persistence: persistence ?? defaultPreset.params.persistence,\n    u_lacunarity: lacunarity ?? defaultPreset.params.lacunarity,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies PerlinNoiseUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={perlinNoiseFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  voronoiFragmentShader,\n  ShaderFitOptions,\n  type VoronoiParams,\n  type VoronoiUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface VoronoiProps extends ShaderComponentProps, VoronoiParams {}\n\ntype VoronoiPreset = ShaderPreset<VoronoiParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: VoronoiPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#e65c1a', '#e6c31a', '#1aace6'],\n    stepsPerColor: 1,\n    colorGlow: '#5500ff',\n    colorBack: '#ffffff',\n    distortion: 0.42,\n    gap: 0.06,\n    innerGlow: 0,\n  },\n};\n\nexport const shadowPreset: VoronoiPreset = {\n  name: 'Shadow',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#faf7fe', '#fefdf7', '#fbf7fe'],\n    stepsPerColor: 1,\n    colorGlow: '#76587a',\n    colorBack: '#ffffff',\n    distortion: 0.23,\n    gap: 0,\n    innerGlow: 0.8,\n  },\n};\n\nexport const voronoiPresets: VoronoiPreset[] = [defaultPreset, shadowPreset];\n\nexport const Voronoi: React.FC<VoronoiProps> = memo(function VoronoiImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n  colorGlow = defaultPreset.params.colorGlow,\n  colorBack = defaultPreset.params.colorBack,\n  distortion = defaultPreset.params.distortion,\n  gap = defaultPreset.params.gap,\n  innerGlow = defaultPreset.params.innerGlow,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: VoronoiProps) {\n  const noiseTexture = typeof window !== 'undefined' && { u_noiseTexture: getShaderNoiseTexture() };\n\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_stepsPerColor: stepsPerColor,\n    u_colorGlow: getShaderColorFromString(colorGlow),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_distortion: distortion,\n    u_gap: gap,\n    u_innerGlow: innerGlow,\n    ...noiseTexture,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies VoronoiUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={voronoiFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  warpFragmentShader,\n  ShaderFitOptions,\n  type WarpParams,\n  type WarpUniforms,\n  type ShaderPreset,\n  WarpPatterns,\n} from '@paper-design/shaders';\n\nexport interface WarpProps extends ShaderComponentProps, WarpParams {}\n\ntype WarpPreset = ShaderPreset<WarpParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: WarpPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    rotation: 0,\n    speed: 1,\n    frame: 0,\n    colors: ['#262626', '#7accf2', '#ffffff'],\n    proportion: 0.35,\n    softness: 1,\n    distortion: 0.25,\n    swirl: 0.8,\n    swirlIterations: 10,\n    shapeScale: 0.1,\n    shape: 'checks',\n  },\n};\n\nexport const presetAbyss: WarpPreset = {\n  name: 'The Abyss',\n  params: {\n    ...defaultPatternSizing,\n    scale: 3,\n    rotation: 2,\n    speed: 0.6,\n    frame: 0,\n    colors: ['#15122e', '#7b89f2', '#ffffff'],\n    proportion: 0,\n    softness: 1,\n    distortion: 0.09,\n    swirl: 0.48,\n    swirlIterations: 5,\n    shapeScale: 0.85,\n    shape: 'edge',\n  },\n};\n\nexport const presetCauldron: WarpPreset = {\n  name: 'Cauldron Pot',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.9,\n    rotation: 160,\n    speed: 20,\n    frame: 0,\n    colors: ['#a7e58b', '#324472', '#0a180d'],\n    proportion: 0.64,\n    softness: 1.5,\n    distortion: 0.2,\n    swirl: 0.86,\n    swirlIterations: 7,\n    shapeScale: 0.6,\n    shape: 'edge',\n  },\n};\n\nexport const presetFilteredLight: WarpPreset = {\n  name: 'Filtered Light',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.3,\n    rotation: 45,\n    speed: 3.2,\n    frame: 0,\n    colors: ['#171714', '#d4d8be', '#f9f9e0'],\n    proportion: 0.4,\n    softness: 1,\n    distortion: 0.09,\n    swirl: 0.1,\n    swirlIterations: 0,\n    shapeScale: 0.1,\n    shape: 'stripes',\n  },\n};\n\nexport const presetIceberg: WarpPreset = {\n  name: 'Iceberg',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.8,\n    rotation: 190,\n    offsetX: 0.3,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#ffffff', '#324771', '#0a180d'],\n    proportion: 0.3,\n    softness: 1.2,\n    distortion: 0.2,\n    swirl: 0.86,\n    swirlIterations: 7,\n    shapeScale: 0,\n    shape: 'checks',\n  },\n};\n\nexport const presetInk: WarpPreset = {\n  name: 'Live Ink',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.2,\n    rotation: 44,\n    offsetY: -0.3,\n    speed: 10,\n    frame: 0,\n    colors: ['#111314', '#9faeab', '#f3fee7'],\n    proportion: 0.35,\n    softness: 0,\n    distortion: 0.25,\n    swirl: 0.8,\n    swirlIterations: 10,\n    shapeScale: 0.28,\n    shape: 'checks',\n  },\n};\n\nexport const presetKelp: WarpPreset = {\n  name: 'Kelp',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.88,\n    rotation: 50,\n    speed: 80,\n    frame: 0,\n    colors: ['#dbff8f', '#404f3e', '#091316'],\n    proportion: 0.93,\n    softness: 0.05,\n    distortion: 0,\n    swirl: 0.15,\n    swirlIterations: 0,\n    shapeScale: 0.74,\n    shape: 'stripes',\n  },\n};\n\nexport const presetNectar: WarpPreset = {\n  name: 'Nectar',\n  params: {\n    ...defaultPatternSizing,\n    scale: 2,\n    offsetY: 0.6,\n    rotation: 0,\n    speed: 30,\n    frame: 0,\n    colors: ['#151310', '#d3a86b', '#f0edea'],\n    proportion: 0.24,\n    softness: 1,\n    distortion: 0.21,\n    swirl: 0.57,\n    swirlIterations: 10,\n    shapeScale: 0.75,\n    shape: 'edge',\n  },\n};\n\nexport const presetPassion: WarpPreset = {\n  name: 'Passion',\n  params: {\n    ...defaultPatternSizing,\n    scale: 2.5,\n    rotation: 1.35,\n    speed: 15,\n    frame: 0,\n    colors: ['#3b1515', '#954751', '#ffc085'],\n    proportion: 0.5,\n    softness: 1,\n    distortion: 0.09,\n    swirl: 0.9,\n    swirlIterations: 6,\n    shapeScale: 0.25,\n    shape: 'checks',\n  },\n};\n\nexport const presetPhantom: WarpPreset = {\n  name: 'Phantom',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.2,\n    rotation: 180,\n    offsetY: -0.2,\n    speed: 30,\n    frame: 0,\n    colors: ['#12112c', '#7b89f2', '#d7dcfb'],\n    proportion: 0.5,\n    softness: 1,\n    distortion: 0.2,\n    swirl: 0.3,\n    swirlIterations: 7,\n    shapeScale: 0.1,\n    shape: 'checks',\n  },\n};\n\nexport const presetSilk: WarpPreset = {\n  name: 'Silk',\n  params: {\n    ...defaultPatternSizing,\n    scale: 2,\n    rotation: 0,\n    speed: 5,\n    frame: 0,\n    colors: ['#141111', '#665551', '#baaea9'],\n    proportion: 0,\n    softness: 1,\n    distortion: 0.3,\n    swirl: 0.6,\n    swirlIterations: 11,\n    shapeScale: 0.25,\n    shape: 'stripes',\n  },\n};\n\nexport const warpPresets: WarpPreset[] = [\n  defaultPreset,\n  presetAbyss,\n  presetCauldron,\n  presetFilteredLight,\n  presetIceberg,\n  presetInk,\n  presetKelp,\n  presetNectar,\n  presetPassion,\n  presetPhantom,\n  presetSilk,\n];\n\nexport const Warp: React.FC<WarpProps> = memo(function WarpImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n  swirlIterations = defaultPreset.params.swirlIterations,\n  shapeScale = defaultPreset.params.shapeScale,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: WarpProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_proportion: proportion,\n    u_softness: softness,\n    u_distortion: distortion,\n    u_swirl: swirl,\n    u_swirlIterations: swirlIterations,\n    u_shapeScale: shapeScale,\n    u_shape: WarpPatterns[shape],\n\n    // Sizing uniforms\n    u_scale: scale,\n    u_rotation: rotation,\n    u_fit: ShaderFitOptions[fit],\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies WarpUniforms;\n\n  return <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={warpFragmentShader} uniforms={uniforms} />;\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  godRaysFragmentShader,\n  ShaderFitOptions,\n  type GodRaysParams,\n  type GodRaysUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface GodRaysProps extends ShaderComponentProps, GodRaysParams {}\n\ntype GodRaysPreset = ShaderPreset<GodRaysParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highmidIntensity bug)\n\nexport const defaultPreset: GodRaysPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: -0.4,\n    offsetY: -0.4,\n    colorBack: '#002238',\n    colors: ['#ffcd66', '#ffb899', '#a8fffb'],\n    frequency: 6,\n    spotty: 0.28,\n    midIntensity: 1,\n    midSize: 3,\n    density: 0.3,\n    blending: 0,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const auroraPreset: GodRaysPreset = {\n  name: 'Aurora',\n  params: {\n    ...defaultObjectSizing,\n    offsetY: 1,\n    colorBack: '#404040',\n    colors: ['#666eff', '#66ff99', '#66d9ff'],\n    frequency: 2.4,\n    spotty: 0.9,\n    midIntensity: 0.8,\n    midSize: 2.1,\n    density: 0.5,\n    blending: 1,\n    speed: 0.5,\n    frame: 0,\n  },\n};\n\nexport const warpPreset: GodRaysPreset = {\n  name: 'Warp',\n  params: {\n    ...defaultObjectSizing,\n    colorBack: '#000000',\n    colors: ['#ff00c4', '#ff8c00', '#ffffff'],\n    frequency: 1.2,\n    spotty: 0.15,\n    midIntensity: 0,\n    midSize: 0,\n    density: 0.79,\n    blending: 0.4,\n    speed: 2,\n    frame: 0,\n  },\n};\n\nexport const linearPreset: GodRaysPreset = {\n  name: 'Linear',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: 0.2,\n    offsetY: -0.7,\n    colorBack: '#000000',\n    colors: ['#ffffff1f', '#ffffff3d', '#ffffff29'],\n    frequency: 1.2,\n    spotty: 0.25,\n    midSize: 1.1,\n    midIntensity: 0.75,\n    density: 0.79,\n    blending: 1,\n    speed: 0.5,\n    frame: 0,\n  },\n};\n\nexport const etherPreset: GodRaysPreset = {\n  name: 'Ether',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: -0.6,\n    colorBack: '#090f1d',\n    colors: ['#148effa6', '#c4dffebe', '#232a47'],\n    frequency: 0.3,\n    spotty: 0.77,\n    midSize: 1.1,\n    midIntensity: 0.5,\n    density: 0.6,\n    blending: 0.6,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const godRaysPresets: GodRaysPreset[] = [defaultPreset, auroraPreset, warpPreset, linearPreset, etherPreset];\n\nexport const GodRays: React.FC<GodRaysProps> = memo(function GodRaysImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  frequency = defaultPreset.params.frequency,\n  spotty = defaultPreset.params.spotty,\n  midIntensity = defaultPreset.params.midIntensity,\n  midSize = defaultPreset.params.midSize,\n  density = defaultPreset.params.density,\n  blending = defaultPreset.params.blending,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: GodRaysProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_frequency: frequency,\n    u_spotty: spotty,\n    u_midIntensity: midIntensity,\n    u_midSize: midSize,\n    u_density: density,\n    u_blending: blending,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies GodRaysUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={godRaysFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  spiralFragmentShader,\n  type ShaderPreset,\n  type SpiralParams,\n  type SpiralUniforms,\n} from '@paper-design/shaders';\n\nexport interface SpiralProps extends ShaderComponentProps, SpiralParams {}\n\ntype SpiralPreset = ShaderPreset<SpiralParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highmidIntensity bug)\n\nexport const defaultPreset: SpiralPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#fafafa',\n    color2: '#808080',\n    density: 0,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noiseFrequency: 0,\n    noisePower: 0,\n    softness: 0.01,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const noisyPreset: SpiralPreset = {\n  name: 'Noisy',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#a1ef2a',\n    color2: '#288918',\n    scale: 1.3,\n    density: 0.5,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0.5,\n    noiseFrequency: 0.1,\n    noisePower: 1,\n    softness: 0,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const dropletPreset: SpiralPreset = {\n  name: 'Droplet',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#bf40a0',\n    color2: '#effafe',\n    scale: 0.65,\n    density: 0,\n    distortion: 0,\n    strokeWidth: 0.05,\n    strokeTaper: 0,\n    strokeCap: 1,\n    noiseFrequency: 0,\n    noisePower: 0,\n    softness: 0,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const sandPreset: SpiralPreset = {\n  name: 'Sand',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#a09560',\n    color2: '#dedede',\n    scale: 3,\n    density: 0,\n    distortion: 0,\n    strokeWidth: 0.15,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noiseFrequency: 30,\n    noisePower: 1,\n    softness: 0.2,\n    speed: 0,\n    frame: 0,\n  },\n};\n\nexport const swirlPreset: SpiralPreset = {\n  name: 'Swirl',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#b3e6d9',\n    color2: '#1a2b4d',\n    scale: 4,\n    density: 0.8,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noiseFrequency: 0,\n    noisePower: 0,\n    softness: 0.5,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const hookPreset: SpiralPreset = {\n  name: 'Hook',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#000000',\n    color2: '#85c2e0',\n    scale: 0.8,\n    density: 0,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0.5,\n    strokeCap: 0,\n    noiseFrequency: 0,\n    noisePower: 0,\n    softness: 0.02,\n    speed: 3,\n    frame: 0,\n  },\n};\n\nexport const vinylPreset: SpiralPreset = {\n  name: 'Vinyl',\n  params: {\n    ...defaultPatternSizing,\n    color1: '#262626',\n    color2: '#c2babb',\n    density: 0,\n    distortion: 0.3,\n    strokeWidth: 0.95,\n    strokeTaper: 0,\n    strokeCap: 1,\n    noiseFrequency: 0,\n    noisePower: 0,\n    softness: 0.11,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const spiralPresets: SpiralPreset[] = [\n  defaultPreset,\n  noisyPreset,\n  dropletPreset,\n  swirlPreset,\n  sandPreset,\n  hookPreset,\n  vinylPreset,\n];\n\nexport const Spiral: React.FC<SpiralProps> = memo(function SpiralImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  color1 = defaultPreset.params.color1,\n  color2 = defaultPreset.params.color2,\n  density = defaultPreset.params.density,\n  distortion = defaultPreset.params.distortion,\n  strokeWidth = defaultPreset.params.strokeWidth,\n  strokeTaper = defaultPreset.params.strokeTaper,\n  strokeCap = defaultPreset.params.strokeCap,\n  noiseFrequency = defaultPreset.params.noiseFrequency,\n  noisePower = defaultPreset.params.noisePower,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SpiralProps) {\n  const uniforms = {\n    // Own uniforms\n    u_color1: getShaderColorFromString(color1),\n    u_color2: getShaderColorFromString(color2),\n    u_density: density,\n    u_distortion: distortion,\n    u_strokeWidth: strokeWidth,\n    u_strokeTaper: strokeTaper,\n    u_strokeCap: strokeCap,\n    u_noiseFrequency: noiseFrequency,\n    u_noisePower: noisePower,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SpiralUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={spiralFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  swirlFragmentShader,\n  type ShaderPreset,\n  type SwirlParams,\n  type SwirlUniforms,\n} from '@paper-design/shaders';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\n\nexport interface SwirlProps extends ShaderComponentProps, SwirlParams {}\n\ntype SwirlPreset = ShaderPreset<SwirlParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highmidIntensity bug)\n\nexport const defaultPreset: SwirlPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 2.28,\n    offsetX: -0.4,\n    offsetY: 0.3,\n    speed: 0.32,\n    frame: 0,\n    colors: ['#452424', '#0b7f05', '#ffe785', '#ff335c'],\n    bandCount: 5,\n    twist: 0.11,\n    softness: 0.01,\n    noiseFrequency: 1.2,\n    noisePower: 0.46,\n  },\n};\n\nexport const openingPreset: SwirlPreset = {\n  name: 'Opening',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: -0.4,\n    offsetY: 0.86,\n    speed: 0.6,\n    frame: 0,\n    colors: ['#8b2e5f', '#b14467', '#e67a62', '#ff715c', '#ffc55c', '#f9f97c'],\n    bandCount: 3,\n    twist: 0.3,\n    softness: 0,\n    noiseFrequency: 2,\n    noisePower: 0,\n  },\n} as const;\n\nexport const jamesBondPreset: SwirlPreset = {\n  name: '007',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#000000', '#2e2e2e', '#000000', '#ffffff'],\n    bandCount: 4,\n    twist: 0.4,\n    softness: 0,\n    noiseFrequency: 0,\n    noisePower: 0,\n  },\n} as const;\n\nexport const candyPreset: SwirlPreset = {\n  name: 'Candy',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#ffcd66', '#6bbceb', '#8a1fff'],\n    bandCount: 2.5,\n    twist: 0.2,\n    softness: 1,\n    noiseFrequency: 0,\n    noisePower: 0,\n  },\n} as const;\n\nexport const swirlPresets: SwirlPreset[] = [defaultPreset, openingPreset, jamesBondPreset, candyPreset];\n\nexport const Swirl: React.FC<SwirlProps> = memo(function SwirlImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  bandCount = defaultPreset.params.bandCount,\n  twist = defaultPreset.params.twist,\n  softness = defaultPreset.params.softness,\n  noiseFrequency = defaultPreset.params.noiseFrequency,\n  noisePower = defaultPreset.params.noisePower,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SwirlProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_bandCount: bandCount,\n    u_twist: twist,\n    u_softness: softness,\n    u_noiseFrequency: noiseFrequency,\n    u_noisePower: noisePower,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SwirlUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={swirlFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport {\n  getShaderColorFromString,\n  ditheringFragmentShader,\n  ShaderFitOptions,\n  type DitheringUniforms,\n  type DitheringParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n  defaultObjectSizing,\n  DitheringTypes,\n} from '@paper-design/shaders';\nimport { DitheringShapes } from '@paper-design/shaders';\n\nexport interface DitheringProps extends ShaderComponentProps, DitheringParams {}\n\ntype DitheringPreset = ShaderPreset<DitheringParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: DitheringPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#252531',\n    color2: '#b59f82',\n    shape: 'simplex',\n    type: '4x4',\n    pxSize: 2,\n  },\n};\n\nexport const warpPreset: DitheringPreset = {\n  name: 'Warp',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#2f6e83',\n    color2: '#dceae8',\n    shape: 'warp',\n    type: '4x4',\n    pxSize: 2,\n  },\n} as const;\n\nexport const sinePreset: DitheringPreset = {\n  name: 'Sine Wave',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#730d54',\n    color2: '#00becc',\n    shape: 'wave',\n    type: '4x4',\n    pxSize: 11,\n  },\n} as const;\n\nexport const bugsPreset: DitheringPreset = {\n  name: 'Bugs',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#000000',\n    color2: '#008000',\n    shape: 'dots',\n    type: 'random',\n    pxSize: 9,\n  },\n} as const;\n\nexport const ripplePreset: DitheringPreset = {\n  name: 'Ripple',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#603520',\n    color2: '#c67953',\n    shape: 'ripple',\n    type: '2x2',\n    pxSize: 3,\n  },\n} as const;\n\nexport const swirlPreset: DitheringPreset = {\n  name: 'Swirl',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#000000',\n    color2: '#263740',\n    shape: 'swirl',\n    type: '8x8',\n    pxSize: 2,\n  },\n} as const;\n\nexport const spherePreset: DitheringPreset = {\n  name: 'Sphere',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    color1: '#301c2a',\n    color2: '#366341',\n    shape: 'sphere',\n    type: '4x4',\n    pxSize: 2.5,\n  },\n} as const;\n\nexport const ditheringPresets: DitheringPreset[] = [\n  defaultPreset,\n  spherePreset,\n  sinePreset,\n  warpPreset,\n  ripplePreset,\n  bugsPreset,\n  swirlPreset,\n];\n\nexport const Dithering: React.FC<DitheringProps> = memo(function DitheringImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  color1 = defaultPreset.params.color1,\n  color2 = defaultPreset.params.color2,\n  shape = defaultPreset.params.shape,\n  type = defaultPreset.params.type,\n  pxSize = defaultPreset.params.pxSize,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_color1: getShaderColorFromString(color1),\n    u_color2: getShaderColorFromString(color2),\n    u_shape: DitheringShapes[shape],\n    u_type: DitheringTypes[type],\n    u_pxSize: pxSize,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DitheringUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={ditheringFragmentShader} uniforms={uniforms} />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport {\n  getShaderColorFromString,\n  grainGradientFragmentShader,\n  ShaderFitOptions,\n  type GrainGradientUniforms,\n  type GrainGradientParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n  defaultObjectSizing,\n  GrainGradientShapes,\n} from '@paper-design/shaders';\n\nexport interface GrainGradientProps extends ShaderComponentProps, GrainGradientParams {}\n\ntype GrainGradientPreset = ShaderPreset<GrainGradientParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: GrainGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#000a0f', '#c4730b', '#bdad5f', '#d8ccc7'],\n    softness: 0.7,\n    intensity: 0.15,\n    noise: 0.5,\n    shape: 'wave',\n  },\n};\n\nexport const dotsPreset: GrainGradientPreset = {\n  name: 'Dots',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colors: ['#0a0000', '#6f0000', '#0080ff', '#f2ebc9'],\n    softness: 0.75,\n    intensity: 0.15,\n    noise: 0.7,\n    shape: 'dots',\n  },\n};\n\nexport const truchetPreset: GrainGradientPreset = {\n  name: 'Truchet',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#0a0000', '#6f2200', '#eabb7c', '#39b523'],\n    softness: 0,\n    intensity: 0.2,\n    noise: 1,\n    shape: 'truchet',\n  },\n};\n\nexport const cornersPreset: GrainGradientPreset = {\n  name: 'Corners',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#031018', '#00aeff', '#00ffcc', '#ffc800'],\n    softness: 0.4,\n    intensity: 0.35,\n    noise: 0.35,\n    shape: 'corners',\n  },\n};\n\nexport const ripplePreset: GrainGradientPreset = {\n  name: 'Ripple',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.5,\n    speed: 1,\n    frame: 0,\n    colors: ['#140a00', '#6f2d00', '#88ddae', '#2c0b1d'],\n    softness: 0.5,\n    intensity: 0.5,\n    noise: 0.5,\n    shape: 'ripple',\n  },\n};\n\nexport const blobPreset: GrainGradientPreset = {\n  name: 'Blob',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1.3,\n    speed: 1,\n    frame: 0,\n    colors: ['#0f0e18', '#3e6172', '#a49b74', '#568c50'],\n    softness: 0,\n    intensity: 0.15,\n    noise: 0.5,\n    shape: 'blob',\n  },\n};\n\nexport const spherePreset: GrainGradientPreset = {\n  name: 'Sphere',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#000319', '#0059b3', '#37f5f5', '#18c039'],\n    softness: 1,\n    intensity: 0.15,\n    noise: 0.5,\n    shape: 'sphere',\n  },\n};\n\nexport const moonPreset: GrainGradientPreset = {\n  name: 'Moon',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colors: ['#000000', '#000000', '#28272d', '#ffeccc'],\n    softness: 1,\n    intensity: 0.56,\n    noise: 1,\n    shape: 'sphere',\n  },\n};\n\nexport const grainGradientPresets: GrainGradientPreset[] = [\n  cornersPreset,\n  defaultPreset,\n  dotsPreset,\n  truchetPreset,\n  ripplePreset,\n  blobPreset,\n  spherePreset,\n  moonPreset,\n];\n\nexport const GrainGradient: React.FC<GrainGradientProps> = memo(function GrainGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  softness = defaultPreset.params.softness,\n  intensity = defaultPreset.params.intensity,\n  noise = defaultPreset.params.noise,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_softness: softness,\n    u_intensity: intensity,\n    u_noise: noise,\n    u_shape: GrainGradientShapes[shape],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies GrainGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={grainGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  getShaderColorFromString,\n  liquidMetalFragmentShader,\n  ShaderFitOptions,\n  type LiquidMetalUniforms,\n  type LiquidMetalParams,\n  type ShaderPreset,\n  defaultObjectSizing,\n} from '@paper-design/shaders';\n\nexport interface LiquidMetalProps extends ShaderComponentProps, LiquidMetalParams {}\n\ntype LiquidMetalPreset = ShaderPreset<LiquidMetalParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: LiquidMetalPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    patternBlur: 0.005,\n    patternScale: 3,\n    dispersion: 0.015,\n    liquid: 0.07,\n    shape: 0,\n    worldWidth: 0,\n    worldHeight: 0,\n  },\n};\n\nexport const liquidMetalPresets: LiquidMetalPreset[] = [defaultPreset];\n\nexport const LiquidMetal: React.FC<LiquidMetalProps> = memo(function LiquidMetalImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  patternBlur = defaultPreset.params.patternBlur,\n  patternScale = defaultPreset.params.patternScale,\n  dispersion = defaultPreset.params.dispersion,\n  liquid = defaultPreset.params.liquid,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: LiquidMetalProps) {\n  const uniforms = {\n    // Own uniforms\n    u_patternBlur: patternBlur,\n    u_patternScale: patternScale,\n    u_dispersion: dispersion,\n    u_liquid: liquid,\n    u_shape: shape,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies LiquidMetalUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={liquidMetalFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount';\nimport { colorPropsAreEqual } from '../color-props-are-equal';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  pulsingBorderFragmentShader,\n  ShaderFitOptions,\n  type PulsingBorderParams,\n  type PulsingBorderUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface PulsingBorderProps extends ShaderComponentProps, PulsingBorderParams {}\n\ntype PulsingBorderPreset = ShaderPreset<PulsingBorderParams>;\n\n// Due to Leva controls limitation:\n// 1) keep default colors in HSLA format to keep alpha channel\n// 2) don't use decimal values on HSL values (to avoid button highlight bug)\n\nexport const defaultPreset: PulsingBorderPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.7,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#f2244f', '#4da6e6'],\n    roundness: 0.5,\n    thickness: 0.02,\n    softness: 0.5,\n    intensity: 2.4,\n    spotsPerColor: 4,\n    spotSize: 0.15,\n    pulse: 0,\n    smoke: 1,\n    smokeSize: 1.3,\n  },\n};\n\nexport const circlePreset: PulsingBorderPreset = {\n  name: 'Circle',\n  params: {\n    ...defaultObjectSizing,\n    worldWidth: 200,\n    worldHeight: 200,\n    scale: 0.5,\n    speed: 1,\n    frame: 0,\n    colorBack: '#0f191f',\n    colors: ['#ffdd33', '#ff8c00', '#ff002b'],\n    roundness: 1,\n    thickness: 0.03,\n    softness: 0.2,\n    intensity: 2,\n    spotsPerColor: 4,\n    spotSize: 0.15,\n    pulse: 0,\n    smoke: 0,\n    smokeSize: 1,\n  },\n};\n\nexport const innerBorderPreset: PulsingBorderPreset = {\n  name: 'Inner Border',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1.0,\n    frame: 0,\n    colorBack: '#181821',\n    colors: ['#f5ad2b', '#2294d9', '#bf00ff'],\n    roundness: 0,\n    thickness: 0,\n    softness: 0.4,\n    intensity: 0,\n    spotsPerColor: 3,\n    spotSize: 0.18,\n    pulse: 0.04,\n    smoke: 0.75,\n    smokeSize: 0.92,\n  },\n};\n\nexport const pulsingBorderPresets: PulsingBorderPreset[] = [defaultPreset, circlePreset, innerBorderPreset];\n\nexport const PulsingBorder: React.FC<PulsingBorderProps> = memo(function PulsingBorderImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  colorBack = defaultPreset.params.colorBack,\n  roundness = defaultPreset.params.roundness,\n  thickness = defaultPreset.params.thickness,\n  softness = defaultPreset.params.softness,\n  intensity = defaultPreset.params.intensity,\n  spotsPerColor = defaultPreset.params.spotsPerColor,\n  spotSize = defaultPreset.params.spotSize,\n  pulse = defaultPreset.params.pulse,\n  smoke = defaultPreset.params.smoke,\n  smokeSize = defaultPreset.params.smokeSize,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: PulsingBorderProps) {\n  const noiseTexture = typeof window !== 'undefined' && { u_noiseTexture: getShaderNoiseTexture(0) };\n  const pulseTexture = typeof window !== 'undefined' && { u_pulseTexture: getShaderNoiseTexture(1) };\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_roundness: roundness,\n    u_thickness: thickness,\n    u_softness: softness,\n    u_intensity: intensity,\n    u_spotsPerColor: spotsPerColor,\n    u_spotSize: spotSize,\n    u_pulse: pulse,\n    u_smoke: smoke,\n    u_smokeSize: smokeSize,\n    ...pulseTexture,\n    ...noiseTexture,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies PulsingBorderUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={pulsingBorderFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n"],
  "mappings": "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",
  "names": ["vertexShaderSource", "p", "q", "ShaderMount", "import_react", "_a", "import_jsx_runtime", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "warpPreset", "swirlPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ripplePreset", "spherePreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount"]
}
