import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@paper-design/shaders-react/dist/shader-mount.js
var import_react = __toESM(require_react(), 1);

// node_modules/@paper-design/shaders/dist/shader-mount.js
var DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;
var ShaderMount = class {
  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {
    __publicField(this, "parentElement");
    __publicField(this, "canvasElement");
    __publicField(this, "gl");
    __publicField(this, "program", null);
    __publicField(this, "uniformLocations", {});
    /** The fragment shader that we are using */
    __publicField(this, "fragmentShader");
    /** Stores the RAF for the render loop */
    __publicField(this, "rafId", null);
    /** Time of the last rendered frame */
    __publicField(this, "lastRenderTime", 0);
    /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */
    __publicField(this, "totalFrameTime", 0);
    /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */
    __publicField(this, "speed", 0);
    /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */
    __publicField(this, "providedUniforms");
    /** Just a sanity check to make sure frames don't run after we're disposed */
    __publicField(this, "hasBeenDisposed", false);
    /** If the resolution of the canvas has changed since the last render */
    __publicField(this, "resolutionChanged", true);
    /** Store textures that are provided by the user */
    __publicField(this, "textures", /* @__PURE__ */ new Map());
    __publicField(this, "minPixelRatio");
    __publicField(this, "maxPixelCount");
    __publicField(this, "isSafari", isSafari());
    __publicField(this, "initProgram", () => {
      const program = createProgram(this.gl, vertexShaderSource, this.fragmentShader);
      if (!program) return;
      this.program = program;
    });
    __publicField(this, "setupPositionAttribute", () => {
      const positionAttributeLocation = this.gl.getAttribLocation(this.program, "a_position");
      const positionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      this.gl.enableVertexAttribArray(positionAttributeLocation);
      this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);
    });
    __publicField(this, "setupUniforms", () => {
      const uniformLocations = {
        u_time: this.gl.getUniformLocation(this.program, "u_time"),
        u_pixelRatio: this.gl.getUniformLocation(this.program, "u_pixelRatio"),
        u_resolution: this.gl.getUniformLocation(this.program, "u_resolution")
      };
      Object.entries(this.providedUniforms).forEach(([key, value]) => {
        uniformLocations[key] = this.gl.getUniformLocation(this.program, key);
        if (value instanceof HTMLImageElement) {
          const aspectRatioUniformName = `${key}_aspect_ratio`;
          uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);
        }
      });
      this.uniformLocations = uniformLocations;
    });
    /**
     * The scale that we should render at.
     * - Used to target 2x rendering even on 1x screens for better antialiasing
     * - Prevents the virtual resolution from going beyond the maximum resolution
     * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels
     */
    __publicField(this, "renderScale", 1);
    __publicField(this, "parentWidth", 0);
    __publicField(this, "parentHeight", 0);
    __publicField(this, "resizeObserver", null);
    __publicField(this, "setupResizeObserver", () => {
      this.resizeObserver = new ResizeObserver(([entry]) => {
        if (entry == null ? void 0 : entry.borderBoxSize[0]) {
          this.parentWidth = entry.borderBoxSize[0].inlineSize;
          this.parentHeight = entry.borderBoxSize[0].blockSize;
        }
        this.handleResize();
      });
      this.resizeObserver.observe(this.parentElement);
      visualViewport == null ? void 0 : visualViewport.addEventListener("resize", this.handleVisualViewportChange);
      const rect = this.parentElement.getBoundingClientRect();
      this.parentWidth = rect.width;
      this.parentHeight = rect.height;
      this.handleResize();
    });
    // Visual viewport resize handler, mainly used to react to browser zoom changes.
    // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):
    // - Frame 1: a paint after the visual viewport resize
    // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered
    //
    // Both resize observer and visual viewport will react to classic browser zoom changes,
    // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.
    __publicField(this, "resizeRafId", null);
    __publicField(this, "handleVisualViewportChange", () => {
      if (this.resizeRafId !== null) {
        cancelAnimationFrame(this.resizeRafId);
      }
      this.resizeRafId = requestAnimationFrame(() => {
        this.resizeRafId = requestAnimationFrame(() => {
          this.handleResize();
        });
      });
    });
    /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */
    __publicField(this, "handleResize", () => {
      if (this.resizeRafId !== null) {
        cancelAnimationFrame(this.resizeRafId);
      }
      const pinchZoom = (visualViewport == null ? void 0 : visualViewport.scale) ?? 1;
      const innerWidth = visualViewport ? visualViewport.width * visualViewport.scale : window.innerWidth;
      const classicZoom = Math.round(1e4 * window.outerWidth / innerWidth) / 1e4;
      const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;
      const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);
      const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;
      const targetPixelWidth = this.parentWidth * targetRenderScale;
      const targetPixelHeight = this.parentHeight * targetRenderScale;
      const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);
      const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);
      const newWidth = Math.round(this.parentWidth * newRenderScale);
      const newHeight = Math.round(this.parentHeight * newRenderScale);
      if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {
        this.renderScale = newRenderScale;
        this.canvasElement.width = newWidth;
        this.canvasElement.height = newHeight;
        this.resolutionChanged = true;
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        this.render(performance.now());
      }
    });
    __publicField(this, "render", (currentTime) => {
      if (this.hasBeenDisposed) return;
      if (this.program === null) {
        console.warn("Tried to render before program or gl was initialized");
        return;
      }
      const dt = currentTime - this.lastRenderTime;
      this.lastRenderTime = currentTime;
      if (this.speed !== 0) {
        this.totalFrameTime += dt * this.speed;
      }
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.useProgram(this.program);
      this.gl.uniform1f(this.uniformLocations.u_time, this.totalFrameTime * 1e-3);
      if (this.resolutionChanged) {
        this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);
        this.resolutionChanged = false;
      }
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      if (this.speed !== 0) {
        this.requestRender();
      } else {
        this.rafId = null;
      }
    });
    __publicField(this, "requestRender", () => {
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
      }
      this.rafId = requestAnimationFrame(this.render);
    });
    /** Creates a texture from an image and sets it into a uniform value */
    __publicField(this, "setTextureUniform", (uniformName, image) => {
      if (!image.complete || image.naturalWidth === 0) {
        throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);
      }
      const existingTexture = this.textures.get(uniformName);
      if (existingTexture) {
        this.gl.deleteTexture(existingTexture);
      }
      const texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
      const error = this.gl.getError();
      if (error !== this.gl.NO_ERROR || texture === null) {
        console.error("Paper Shaders: WebGL error when uploading texture:", error);
        return;
      }
      this.textures.set(uniformName, texture);
      const location = this.uniformLocations[uniformName];
      if (location) {
        const textureUnit = this.textures.size - 1;
        this.gl.useProgram(this.program);
        this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.uniform1i(location, textureUnit);
        const aspectRatioUniformName = `${uniformName}_aspect_ratio`;
        const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];
        if (aspectRatioLocation) {
          const aspectRatio = image.naturalWidth / image.naturalHeight;
          this.gl.uniform1f(aspectRatioLocation, aspectRatio);
        }
      }
    });
    /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */
    __publicField(this, "setUniformValues", (updatedUniforms) => {
      this.gl.useProgram(this.program);
      Object.entries(updatedUniforms).forEach(([key, value]) => {
        const location = this.uniformLocations[key];
        if (!location) {
          console.warn(`Uniform location for ${key} not found`);
          return;
        }
        if (value instanceof HTMLImageElement) {
          this.setTextureUniform(key, value);
        } else if (Array.isArray(value)) {
          let flatArray = null;
          let valueLength = null;
          if (value[0] !== void 0 && Array.isArray(value[0])) {
            const firstChildLength = value[0].length;
            if (value.every((arr) => arr.length === firstChildLength)) {
              flatArray = value.flat();
              valueLength = firstChildLength;
            } else {
              console.warn(`All child arrays must be the same length for ${key}`);
              return;
            }
          } else {
            flatArray = value;
            valueLength = flatArray.length;
          }
          switch (valueLength) {
            case 2:
              this.gl.uniform2fv(location, flatArray);
              break;
            case 3:
              this.gl.uniform3fv(location, flatArray);
              break;
            case 4:
              this.gl.uniform4fv(location, flatArray);
              break;
            case 9:
              this.gl.uniformMatrix3fv(location, false, flatArray);
              break;
            case 16:
              this.gl.uniformMatrix4fv(location, false, flatArray);
              break;
            default:
              console.warn(`Unsupported uniform array length: ${valueLength}`);
          }
        } else if (typeof value === "number") {
          this.gl.uniform1f(location, value);
        } else if (typeof value === "boolean") {
          this.gl.uniform1i(location, value ? 1 : 0);
        } else {
          console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);
        }
      });
    });
    /** Gets the current total animation time from 0ms */
    __publicField(this, "getCurrentFrameTime", () => {
      return this.totalFrameTime;
    });
    /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */
    __publicField(this, "setFrame", (newFrame) => {
      this.totalFrameTime = newFrame;
      this.lastRenderTime = performance.now();
      this.render(performance.now());
    });
    /** Set an animation speed (or 0 to stop animation) */
    __publicField(this, "setSpeed", (newSpeed = 1) => {
      this.speed = newSpeed;
      if (this.rafId === null && newSpeed !== 0) {
        this.lastRenderTime = performance.now();
        this.rafId = requestAnimationFrame(this.render);
      }
      if (this.rafId !== null && newSpeed === 0) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
    });
    /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */
    __publicField(this, "setMaxPixelCount", (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {
      this.maxPixelCount = newMaxPixelCount;
      this.handleResize();
    });
    /** Set the minimum pixel ratio for the shader */
    __publicField(this, "setMinPixelRatio", (newMinPixelRatio = 2) => {
      this.minPixelRatio = newMinPixelRatio;
      this.handleResize();
    });
    /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */
    __publicField(this, "setUniforms", (newUniforms) => {
      this.providedUniforms = { ...this.providedUniforms, ...newUniforms };
      this.setUniformValues(newUniforms);
      this.render(performance.now());
    });
    /** Dispose of the shader mount, cleaning up all of the WebGL resources */
    __publicField(this, "dispose", () => {
      this.hasBeenDisposed = true;
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      if (this.gl && this.program) {
        this.textures.forEach((texture) => {
          this.gl.deleteTexture(texture);
        });
        this.textures.clear();
        this.gl.deleteProgram(this.program);
        this.program = null;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.getError();
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }
      visualViewport == null ? void 0 : visualViewport.removeEventListener("resize", this.handleVisualViewportChange);
      this.uniformLocations = {};
      this.parentElement.paperShaderMount = void 0;
    });
    if (parentElement instanceof HTMLElement) {
      this.parentElement = parentElement;
    } else {
      throw new Error("Paper Shaders: parent element must be an HTMLElement");
    }
    if (!document.querySelector("style[data-paper-shaders]")) {
      const styleElement = document.createElement("style");
      styleElement.innerHTML = defaultStyle;
      styleElement.setAttribute("data-paper-shaders", "");
      document.head.prepend(styleElement);
    }
    const canvasElement = document.createElement("canvas");
    this.canvasElement = canvasElement;
    this.parentElement.prepend(canvasElement);
    this.fragmentShader = fragmentShader;
    this.providedUniforms = uniforms;
    this.totalFrameTime = frame;
    this.minPixelRatio = minPixelRatio;
    this.maxPixelCount = maxPixelCount;
    const gl = canvasElement.getContext("webgl2", webGlContextAttributes);
    if (!gl) {
      throw new Error("Paper Shaders: WebGL is not supported in this browser");
    }
    this.gl = gl;
    this.initProgram();
    this.setupPositionAttribute();
    this.setupUniforms();
    this.setUniformValues(this.providedUniforms);
    this.setupResizeObserver();
    this.setSpeed(speed);
    this.parentElement.setAttribute("data-paper-shaders", "");
    this.parentElement.paperShaderMount = this;
  }
};
var vertexShaderSource = `#version 300 es
precision mediump float;

layout(location = 0) in vec4 a_position;

uniform vec2 u_resolution;
uniform float u_pixelRatio;

uniform float u_originX;
uniform float u_originY;
uniform float u_worldWidth;
uniform float u_worldHeight;
uniform float u_fit;

uniform float u_scale;
uniform float u_rotation;
uniform float u_offsetX;
uniform float u_offsetY;

uniform float u_pxSize;

out vec2 v_objectUV;
out vec2 v_objectBoxSize;
out vec2 v_objectHelperBox;

out vec2 v_responsiveUV;
out vec2 v_responsiveBoxSize;
out vec2 v_responsiveHelperBox;
out vec2 v_responsiveBoxGivenSize;

out vec2 v_patternUV;
out vec2 v_patternBoxSize;
out vec2 v_patternHelperBox;

// #define ADD_HELPERS

vec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {
  vec2 box = vec2(0.);
  // fit = none
  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);
  float noFitBoxWidth = box.x;
  if (u_fit == 1.) { // fit = contain
    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);
  } else if (u_fit == 2.) { // fit = cover
    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);
  }
  box.y = box.x / boxRatio;
  return vec3(box, noFitBoxWidth);
}

void main() {
  gl_Position = a_position;

  vec2 uv = gl_Position.xy * .5;
  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);
  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);
  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;
  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));
  float r = u_rotation * 3.14159265358979323846 / 180.;
  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));
  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);


  // ===================================================
  // Sizing api for graphic objects with fixed ratio
  // (currently supports only ratio = 1)

  float fixedRatio = 1.;
  vec2 fixedRatioBoxGivenSize = vec2(
    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,
    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y
  );

  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;
  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;

  #ifdef ADD_HELPERS
    v_objectHelperBox = uv;
    v_objectHelperBox *= objectWorldScale;
    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);
  #endif

  v_objectUV = uv;
  v_objectUV *= objectWorldScale;
  v_objectUV += boxOrigin * (objectWorldScale - 1.);
  v_objectUV += graphicOffset;
  v_objectUV /= u_scale;
  v_objectUV = graphicRotation * v_objectUV;


  // ===================================================


  // ===================================================
  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.
  // Full-screen mode available with u_worldWidth = u_worldHeight = 0

  v_responsiveBoxGivenSize = vec2(
    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,
    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y
  );
  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;
  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;
  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;

  #ifdef ADD_HELPERS
    v_responsiveHelperBox = uv;
    v_responsiveHelperBox *= responsiveBoxScale;
    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);
  #endif

  v_responsiveUV = uv;
  v_responsiveUV *= responsiveBoxScale;
  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);
  v_responsiveUV += graphicOffset;
  v_responsiveUV /= u_scale;
  v_responsiveUV.x *= responsiveRatio;
  v_responsiveUV = graphicRotation * v_responsiveUV;
  v_responsiveUV.x /= responsiveRatio;

  // ===================================================


  // ===================================================
  // Sizing api for patterns
  // (treating graphics as a image u_worldWidth x u_worldHeight size)

  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;
  vec2 patternBoxGivenSize = vec2(
    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,
    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y
  );
  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;

  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);
  v_patternBoxSize = boxSizeData.xy;
  float patternBoxNoFitBoxWidth = boxSizeData.z;
  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;

  #ifdef ADD_HELPERS
    v_patternHelperBox = uv;
    v_patternHelperBox *= patternBoxScale;
    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);
  #endif

  v_patternUV = uv;
  v_patternUV += graphicOffset / patternBoxScale;
  v_patternUV += boxOrigin;
  v_patternUV -= boxOrigin / patternBoxScale;
  v_patternUV *= u_resolution.xy;
  v_patternUV /= u_pixelRatio;
  if (u_fit > 0.) {
    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);
  }
  v_patternUV /= u_scale;
  v_patternUV = graphicRotation * v_patternUV;
  v_patternUV += boxOrigin / patternBoxScale;
  v_patternUV -= boxOrigin;
  v_patternUV += .5;

  // ===================================================

}`;
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  if (!shader) return null;
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}
function createProgram(gl, vertexShaderSource2, fragmentShaderSource) {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  if (!vertexShader || !fragmentShader) return null;
  const program = gl.createProgram();
  if (!program) return null;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return null;
  }
  gl.detachShader(program, vertexShader);
  gl.detachShader(program, fragmentShader);
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  return program;
}
var defaultStyle = `@layer paper-shaders {
  :where([data-paper-shaders]) {
    isolation: isolate;
    position: relative;

    & canvas {
      contain: strict;
      display: block;
      position: absolute;
      inset: 0;
      z-index: -1;
      width: 100%;
      height: 100%;
      border-radius: inherit;
    }
  }
}`;
function isPaperShaderElement(element) {
  return "paperShaderMount" in element;
}
function isSafari() {
  const ua = navigator.userAgent.toLowerCase();
  return ua.includes("safari") && !ua.includes("chrome") && !ua.includes("android");
}

// node_modules/@paper-design/shaders/dist/shader-sizing.js
var sizingVariablesDeclaration = `
in vec2 v_objectUV;
in vec2 v_responsiveUV;
in vec2 v_responsiveBoxGivenSize;
in vec2 v_patternUV;`;
var sizingUniformsDeclaration = `
uniform float u_originX;
uniform float u_originY;
uniform float u_worldWidth;
uniform float u_worldHeight;
uniform float u_fit;

uniform float u_scale;
uniform float u_rotation;
uniform float u_offsetX;
uniform float u_offsetY;`;
var sizingUV = `

  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  #ifdef USE_PIXELIZATION
    float pxSize = u_pxSize * u_pixelRatio;
    vec2 pxSizeUv = gl_FragCoord.xy;
    pxSizeUv -= .5 * u_resolution;
    pxSizeUv /= pxSize;
    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    
    uv += .5;
  #endif
  uv -= .5;

  
  // ===================================================
  // sizing params shared between objects and patterns
  
  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);
  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);
  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;
  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));
  float r = u_rotation * 3.14159265358979323846 / 180.;
  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));
  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);

  
  // ===================================================
  // Sizing api for objects (graphics with fixed ratio)

  #ifdef USE_OBJECT_SIZING
    float fixedRatio = 1.;
    vec2 fixedRatioBoxGivenSize = vec2(
      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,
      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y
    );
    vec2 objectBoxSize = vec2(0.);
    // fit = none
    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);
    if (u_fit == 1.) { // fit = contain
      objectBoxSize.x = fixedRatio * min(maxBoxSize.x / fixedRatio, maxBoxSize.y);
    } else if (u_fit == 2.) {  // fit = cover
      objectBoxSize.x = fixedRatio * max(maxBoxSize.x / fixedRatio, maxBoxSize.y);
    }
    objectBoxSize.y = objectBoxSize.x / fixedRatio;
    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;
  
    #ifdef ADD_HELPERS
      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;
      objectHelperBox -= .5;
      objectHelperBox *= objectWorldScale;
      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  
    #endif
  
    vec2 objectUV = uv;
    objectUV *= objectWorldScale;
    objectUV += boxOrigin * (objectWorldScale - 1.);
    objectUV += vec2(-u_offsetX, u_offsetY);
    objectUV /= u_scale;
    objectUV = graphicRotation * objectUV;
  #endif
  
  // ===================================================
 
  // ===================================================
  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)
  
  #ifdef USE_PATTERN_SIZING
    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;
    vec2 patternBoxGivenSize = vec2(
      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,
      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y
    );
    vec2 patternBoxSize = vec2(0.);
    // fit = none
    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);
    float patternWorldNoFitBoxWidth = patternBoxSize.x;
    if (u_fit == 1.) {  // fit = contain
      patternBoxSize.x = patternBoxRatio * min(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);
    } else if (u_fit == 2.) {  // fit = cover
      patternBoxSize.x = patternBoxRatio * max(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);
    }
    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;
    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;
  
    #ifdef ADD_HELPERS  
      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;
      patternHelperBox -= .5;
      patternHelperBox *= patternWorldScale;
      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  
    #endif
  
    vec2 patternUV = uv;
    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;
    patternUV += boxOrigin;
    patternUV -= boxOrigin / patternWorldScale;
    patternUV *= u_resolution.xy;
    patternUV /= u_pixelRatio;
    if (u_fit > 0.) {
      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);
    }
    patternUV /= u_scale;
    patternUV = graphicRotation * patternUV;
    patternUV += boxOrigin / patternWorldScale;
    patternUV -= boxOrigin;
    patternUV += .5;
  #endif
`;
var drawSizingHelpers = `
  vec2 worldBoxDist = abs(helperBox);
  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));
  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);
  opacity += boxStroke;

  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);
  vec2 boxOriginDist = helperBox + boxOriginCopy;
  boxOriginDist.x *= (boxSize.x / boxSize.y);
  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));
  
  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);
  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);
  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));
  
  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);
  opacity += boxOriginPoint;
  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);
  opacity += graphicOriginPoint;
`;
var defaultObjectSizing = {
  fit: "contain",
  scale: 1,
  rotation: 0,
  offsetX: 0,
  offsetY: 0,
  originX: 0.5,
  originY: 0.5,
  worldWidth: 0,
  worldHeight: 0
};
var defaultPatternSizing = {
  fit: "none",
  scale: 1,
  rotation: 0,
  offsetX: 0,
  offsetY: 0,
  originX: 0.5,
  originY: 0.5,
  worldWidth: 0,
  worldHeight: 0
};
var ShaderFitOptions = {
  none: 0,
  contain: 1,
  cover: 2
};

// node_modules/@paper-design/shaders/dist/shader-utils.js
var declarePI = `
#define TWO_PI 6.28318530718
#define PI 3.14159265358979323846
`;
var declareRotate = `
vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}
`;
var declareRandom = `
float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
`;
var colorBandingFix = `
  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);
`;
var declareSimplexNoise = `
vec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
    -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
    + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),
      dot(x12.zw, x12.zw)), 0.0);
  m = m * m;
  m = m * m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js
var meshGradientMeta = {
  maxColorCount: 10
};
var meshGradientFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colors[${meshGradientMeta.maxColorCount}];
uniform float u_colorsCount;

uniform float u_distortion;
uniform float u_swirl;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRotate}

vec2 getPosition(int i, float t) {
  float a = float(i) * .37;
  float b = .6 + mod(float(i), 3.) * .3;
  float c = .8 + mod(float(i + 1), 4.) * 0.25;

  float x = sin(t * b + a);
  float y = cos(t * c + a * 1.5);

  return .5 + .5 * vec2(x, y);
}

void main() {
  vec2 shape_uv = v_objectUV;

  shape_uv += .5;

  float t = .5 * u_time;

  float radius = smoothstep(0., 1., length(shape_uv - .5));
  float center = 1. - radius;
  for (float i = 1.; i <= 2.; i++) {
    shape_uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., shape_uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., shape_uv.y));
    shape_uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., shape_uv.x));
  }

  vec2 uvRotated = shape_uv;
  uvRotated -= vec2(.5);
  float angle = 3. * u_swirl * radius;
  uvRotated = rotate(uvRotated, -angle);
  uvRotated += vec2(.5);

  vec3 color = vec3(0.);
  float opacity = 0.;
  float totalWeight = 0.;
  
  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {
    if (i >= int(u_colorsCount)) break;
    
    vec2 pos = getPosition(i, t);
    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;
    float opacityFraction = u_colors[i].a;
      
    float dist = 0.;
    if (mod(float(i), 2.) > 1.) {
      dist = length(shape_uv - pos);
    } else {
      dist = length(uvRotated - pos);
    }

    dist = pow(dist, 3.5);
    float weight = 1. / (dist + 1e-3);
    color += colorFraction * weight;
    opacity += opacityFraction * weight;
    totalWeight += weight;
  }

  color /= totalWeight;
  opacity /= totalWeight;
  
  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/smoke-ring.js
var smokeRingMeta = {
  maxColorCount: 10,
  maxNoiseIterations: 8
};
var smokeRingFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform sampler2D u_noiseTexture;

uniform vec4 u_colorBack;
uniform vec4 u_colors[${smokeRingMeta.maxColorCount}];
uniform float u_colorsCount;

uniform float u_noiseScale;
uniform float u_thickness;
uniform float u_radius;
uniform float u_innerShape;
uniform float u_noiseIterations;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
//$ {declareRandom}

float random(vec2 p) {
  vec2 uv = floor(p) / 100. + .5;
  return texture(u_noiseTexture, uv).r;
}

float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smoothstep for interpolation
  vec2 u = f * f * (3.0 - 2.0 * f);

  // Do the interpolation as two nested mix operations
  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);

}
float fbm(in vec2 n) {
  float total = 0.0, amplitude = .4;
  for (int i = 0; i < ${smokeRingMeta.maxNoiseIterations}; i++) {
    if (i >= int(u_noiseIterations)) break;
    total += noise(n) * amplitude;
    n *= 1.99;
    amplitude *= 0.65;
  }
  return total;
}

float getNoise(vec2 uv, vec2 pUv, float t) {
  float noiseLeft = fbm(pUv + .03 * t);
  pUv.x = mod(pUv.x, u_noiseScale * TWO_PI);
  float noiseRight = fbm(pUv + .03 * t);
  return mix(noiseRight, noiseLeft, smoothstep(-.25, .25, uv.x));
}

float getRingShape(vec2 uv) {
  float radius = u_radius;
  float thickness = u_thickness;

  float distance = length(uv);
  float ringValue = 1. - smoothstep(radius, radius + thickness, distance);
  ringValue *= smoothstep(radius - pow(u_innerShape, 3.) * thickness, radius, distance);

  return ringValue;
}

void main() {
  vec2 shape_uv = v_objectUV;

  float t = u_time;

  float cycleDuration = 3.;
  float localTime1 = mod(.1 * t + cycleDuration, 2. * cycleDuration);
  float localTime2 = mod(.1 * t, 2. * cycleDuration);
  float timeBlend = .5 + .5 * sin(.1 * t * PI / cycleDuration - .5 * PI);

  float atg = atan(shape_uv.y, shape_uv.x) + .001;
  float l = length(shape_uv);
  vec2 polar_uv1 = vec2(atg, localTime1 - (.5 * l) + 1. / pow(l, .5));
  polar_uv1 *= u_noiseScale;
  float noise1 = getNoise(shape_uv, polar_uv1, t);

  vec2 polar_uv2 = vec2(atg, localTime2 - (.5 * l) + 1. / pow(l, .5));
  polar_uv2 *= u_noiseScale;
  float noise2 = getNoise(shape_uv, polar_uv2, t);

  float noise = mix(noise1, noise2, timeBlend);

  shape_uv *= (.8 + 1.2 * noise);

  float ringShape = getRingShape(shape_uv);

  float mixer = pow(ringShape, 3.) * (u_colorsCount - 1.);
  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${smokeRingMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      float localT = clamp(mixer - float(i - 1), 0., 1.);
      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }

  float opacity = gradient.a * ringShape;
  opacity += u_colorBack.a;

  vec3 color = gradient.rgb * ringShape;
  color += u_colorBack.rgb * u_colorBack.a * (1. - ringShape);
  color += u_colorBack.rgb * u_colorBack.a * ringShape * (1. - gradient.a);

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/neuro-noise.js
var neuroNoiseFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_pixelRatio;

uniform vec4 u_colorFront;
uniform vec4 u_colorBack;
uniform float u_brightness;


${sizingVariablesDeclaration}

out vec4 fragColor;

${declareRotate}

float neuro_shape(vec2 uv, float t) {
  vec2 sine_acc = vec2(0.);
  vec2 res = vec2(0.);
  float scale = 8.;

  for (int j = 0; j < 15; j++) {
    uv = rotate(uv, 1.);
    sine_acc = rotate(sine_acc, 1.);
    vec2 layer = uv * scale + float(j) + sine_acc - t;
    sine_acc += sin(layer);
    res += (.5 + .5 * cos(layer)) / scale;
    scale *= (1.2);
  }
  return res.x + res.y;
}

void main() {
  vec2 shape_uv = v_patternUV;

  shape_uv *= .002;

  float t = .5 * u_time;

  float noise = neuro_shape(shape_uv, t);

  noise = u_brightness * pow(noise, 3.);
  noise += pow(noise, 12.);
  noise = max(.0, noise - .5);

  vec3 color = mix(u_colorBack.rgb * u_colorBack.a, u_colorFront.rgb * u_colorFront.a, noise);
  float opacity = mix(u_colorBack.a, u_colorFront.a, noise);
  
  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/dot-orbit.js
var dotOrbitMeta = {
  maxColorCount: 10
};
var dotOrbitFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colors[${dotOrbitMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_stepsPerColor;
uniform float u_size;
uniform float u_sizeRange;
uniform float u_spreading;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRandom}
${declareRotate}

vec2 random2(vec2 p) {
  return vec2(random(p), random(200. * p));
}

vec3 voronoiShape(vec2 uv, float time) {
  vec2 i_uv = floor(uv);
  vec2 f_uv = fract(uv);
  
  float spreading = .25 * clamp(u_spreading, 0., 1.);

  float minDist = 1.;
  vec2 randomizer = vec2(0.);
  for (int y = -1; y <= 1; y++) {
    for (int x = -1; x <= 1; x++) {
      vec2 tileOffset = vec2(float(x), float(y));
      vec2 rand = random2(i_uv + tileOffset);
      vec2 cellCenter = vec2(.5 + 1e-4);
      cellCenter += spreading * cos(time + TWO_PI * rand);
      cellCenter -= .5;
      cellCenter = rotate(cellCenter, random(vec2(rand.x, rand.y)) + .1 * time);
      cellCenter += .5;
      float dist = length(tileOffset + cellCenter - f_uv);
      if (dist < minDist) {
        minDist = dist;
        randomizer = rand;
      }
      minDist = min(minDist, dist);
    }
  }

  return vec3(minDist, randomizer);
}

void main() {
  
  vec2 shape_uv = v_patternUV;
  shape_uv += .5;
  shape_uv *= .015;
  
  float t = u_time;

  vec3 voronoi = voronoiShape(shape_uv, t) + 1e-4;

  float radius = .25 * clamp(u_size, 0., 1.) - .5 * clamp(u_sizeRange, 0., 1.) * voronoi[2];
  float dist = voronoi[0];
  float edgeWidth = fwidth(dist);
  float dots = smoothstep(radius + edgeWidth, radius - edgeWidth, dist);

  float shape = voronoi[1];
  
  float mixer = shape * (u_colorsCount - 1.);
  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;
  float steps = max(1., u_stepsPerColor);
  
  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${dotOrbitMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);
      localT = round(localT * steps) / steps;
      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }

  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {
    float localT = mixer + 1.;
    if (mixer > (u_colorsCount - 1.)) {
      localT = mixer - (u_colorsCount - 1.);
    }
    localT = round(localT * steps) / steps;
    vec4 cFst = u_colors[0];
    cFst.rgb *= cFst.a;
    vec4 cLast = u_colors[int(u_colorsCount - 1.)];
    cLast.rgb *= cLast.a;
    gradient = mix(cLast, cFst, localT);
  }

  gradient *= dots;
  vec3 color = gradient.rgb;
  float opacity = gradient.a;

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/dot-grid.js
var dotGridFragmentShader = `#version 300 es
precision mediump float;

uniform vec4 u_colorBack;
uniform vec4 u_colorFill;
uniform vec4 u_colorStroke;
uniform float u_dotSize;
uniform float u_gapX;
uniform float u_gapY;
uniform float u_strokeWidth;
uniform float u_sizeRange;
uniform float u_opacityRange;
uniform float u_shape;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareSimplexNoise}

float polygon(vec2 p, float N, float rot) {
  float a = atan(p.x, p.y) + rot;
  float r = TWO_PI / float(N);

  return cos(floor(.5 + a / r) * r - a) * length(p);
}

void main() {
  
  vec2 shape_uv = v_patternUV;
  shape_uv += .5;

  vec2 grid = fract(shape_uv / vec2(u_gapX, u_gapY)) + 1e-4;
  vec2 grid_idx = floor(shape_uv / vec2(u_gapX, u_gapY));
  float sizeRandomizer = .5 + .8 * snoise(2. * vec2(grid_idx.x * 100., grid_idx.y));
  float opacity_randomizer = .5 + .7 * snoise(2. * vec2(grid_idx.y, grid_idx.x));

  vec2 center = vec2(0.5) - 1e-3;
  vec2 p = (grid - center) * vec2(u_gapX, u_gapY);

  float baseSize = u_dotSize * (1. - sizeRandomizer * u_sizeRange);
  float strokeWidth = u_strokeWidth * (1. - sizeRandomizer * u_sizeRange);

  float dist;
  if (u_shape < 0.5) {
    // Circle
    dist = length(p);
  } else if (u_shape < 1.5) {
    // Diamond
    strokeWidth *= 1.5;
    dist = polygon(1.5 * p, 4., .25 * PI);
  } else if (u_shape < 2.5) {
    // Square
    dist = polygon(1.03 * p, 4., 1e-3);
  } else {
    // Triangle
    strokeWidth *= 1.5;
    p = p * 2. - 1.;
    p *= .9;
    p.y -= .75 * baseSize;
    dist = polygon(p, 3., 1e-3);
  }

  float edgeWidth = fwidth(dist);
  float shapeOuter = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist - strokeWidth);
  float shapeInner = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist);
  float stroke = shapeOuter - shapeInner;

  float dotOpacity = max(0., 1. - opacity_randomizer * u_opacityRange);
  stroke *= dotOpacity;
  shapeInner *= dotOpacity;

  stroke *= u_colorStroke.a;
  shapeInner *= u_colorFill.a;

  vec3 color = vec3(0.);
  color += stroke * u_colorStroke.rgb;
  color += shapeInner * u_colorFill.rgb;
  color += (1. - shapeInner - stroke) * u_colorBack.rgb * u_colorBack.a;

  float opacity = 0.;
  opacity += stroke;
  opacity += shapeInner;
  opacity += (1. - opacity) * u_colorBack.a;
  
  fragColor = vec4(color, opacity);
}
`;
var DotGridShapes = {
  circle: 0,
  diamond: 1,
  square: 2,
  triangle: 3
};

// node_modules/@paper-design/shaders/dist/shaders/simplex-noise.js
var simplexNoiseMeta = {
  maxColorCount: 10
};
var simplexNoiseFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform float u_scale;

uniform vec4 u_colors[${simplexNoiseMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_stepsPerColor;
uniform float u_softness;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declareSimplexNoise}

float getNoise(vec2 uv, float t) {
  float noise = .5 * snoise(uv - vec2(0., .3 * t));
  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));

  return noise;
}

float steppedSmooth(float t, float steps, float softness) {
    float stepT = floor(t * steps) / steps;
    float f = t * steps - floor(t * steps);
    
    float fw = 0.005 / u_scale;
    float smoothed = smoothstep(.5 - softness * .5 - fw, .5 + softness * .5 + fw, f);
        
    return stepT + smoothed / steps;
}

void main() {
  vec2 shape_uv = v_patternUV;

  shape_uv *= .001;

  float t = .2 * u_time;

  float shape = .5 + .5 * getNoise(shape_uv, t);
  
  bool u_extraSides = true;
  
  float mixer = shape * (u_colorsCount - 1.);
  if (u_extraSides == true) {
    mixer = (shape - .5 / u_colorsCount) * u_colorsCount;
  }

  float steps = max(1., u_stepsPerColor);

  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${simplexNoiseMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      
      float localT = clamp(mixer - float(i - 1), 0., 1.);
      localT = steppedSmooth(localT, steps, u_softness);   
      
      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }
  
  if (u_extraSides == true) {
   if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {
     float localT = mixer + 1.;
     if (mixer > (u_colorsCount - 1.)) {
       localT = mixer - (u_colorsCount - 1.);
     }
     localT = steppedSmooth(localT, steps, u_softness);   
     vec4 cFst = u_colors[0];
     cFst.rgb *= cFst.a;
     vec4 cLast = u_colors[int(u_colorsCount - 1.)];
     cLast.rgb *= cLast.a;
     gradient = mix(cLast, cFst, localT);
   }
  }

  vec3 color = gradient.rgb;
  float opacity = gradient.a;
  
  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/metaballs.js
var metaballsMeta = {
  maxColorCount: 8,
  maxBallsCount: 20
};
var metaballsFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colors[${metaballsMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_size;
uniform float u_sizeRange;
uniform float u_count;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}

float hash(float x) {
  return fract(sin(x) * 43758.5453123);
}
float noise(float x) {
  float i = floor(x);
  float f = fract(x);
  float u = f * f * (3.0 - 2.0 * f);
  return mix(hash(i), hash(i + 1.0), u);
}

float getBallShape(vec2 uv, vec2 c, float p) {
  float s = .5 * length(uv - c);
  s = 1. - clamp(s, 0., 1.);
  s = pow(s, p);
  return s;
}

void main() {
  vec2 shape_uv = v_objectUV;

  shape_uv += .5;

  float t = .2 * u_time + 1.;

  vec3 totalColor = vec3(0.);
  float totalShape = 0.;
  float totalOpacity = 0.;
  
  for (int i = 0; i < ${metaballsMeta.maxBallsCount}; i++) {
    if (i >= int(ceil(u_count))) break;
  
    float idxFract = float(i) / float(${metaballsMeta.maxBallsCount});
    float angle = TWO_PI * idxFract;
  
    float speed = 1. - .2 * idxFract;
    float noiseX = noise(angle * 10. + float(i) + t * speed);
    float noiseY = noise(angle * 20. + float(i) - t * speed);
  
    vec2 pos = vec2(.5) + 1e-4 + .9 * (vec2(noiseX, noiseY) - .5);
  
    int safeIndex = i % int(u_colorsCount + 0.5);
    vec4 ballColor = u_colors[safeIndex];
    ballColor.rgb *= ballColor.a;

    float sizeFrac = 1.;
    if (float(i) > floor(u_count - 1.)) {
      sizeFrac *= fract(u_count);
    }

    float shape = getBallShape(shape_uv, pos, 45. - 30. * u_size * sizeFrac);
    shape *= pow(u_size, .2);
    shape = smoothstep(0., 1., shape);

    totalColor += ballColor.rgb * shape;
    totalShape += shape;
    totalOpacity += ballColor.a * shape;
  }

  totalColor /= max(totalShape, 1e-4);
  totalOpacity /= max(totalShape, 1e-4);

  float edge_width = fwidth(totalShape);
  float finalShape = smoothstep(.4, .4 + edge_width, totalShape);

  vec3 color = totalColor * finalShape;
  float opacity = totalOpacity * finalShape;

  if (opacity < .005) {
    discard;
  }

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/perlin-noise.js
var perlinNoiseFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_color1;
uniform vec4 u_color2;
uniform float u_proportion;
uniform float u_softness;
uniform float u_octaveCount;
uniform float u_persistence;
uniform float u_lacunarity;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}

uint hash(uint x, uint seed) {
  const uint m = 0x5bd1e995U;
  uint hash = seed;
    // process input
    uint k = x;
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // some final mixing
    hash ^= hash >> 13;
    hash *= m;
    hash ^= hash >> 15;
    return hash;
}

uint hash(uvec3 x, uint seed){
    const uint m = 0x5bd1e995U;
    uint hash = seed;
    // process first vector element
    uint k = x.x;
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // process second vector element
    k = x.y;
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // process third vector element
    k = x.z;
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // some final mixing
    hash ^= hash >> 13;
    hash *= m;
    hash ^= hash >> 15;
    return hash;
}


vec3 gradientdy(uint hash) {
    switch (int(hash) & 15) { // look at the last four bits to pick a gradient dy
    case 0:
        return vec3(1, 1, 0);
    case 1:
        return vec3(-1, 1, 0);
    case 2:
        return vec3(1, -1, 0);
    case 3:
        return vec3(-1, -1, 0);
    case 4:
        return vec3(1, 0, 1);
    case 5:
        return vec3(-1, 0, 1);
    case 6:
        return vec3(1, 0, -1);
    case 7:
        return vec3(-1, 0, -1);
    case 8:
        return vec3(0, 1, 1);
    case 9:
        return vec3(0, -1, 1);
    case 10:
        return vec3(0, 1, -1);
    case 11:
        return vec3(0, -1, -1);
    case 12:
        return vec3(1, 1, 0);
    case 13:
        return vec3(-1, 1, 0);
    case 14:
        return vec3(0, -1, 1);
    case 15:
        return vec3(0, -1, -1);
    }
}

float interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {
    return mix(
        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),
        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),
        t.z
    );
}

vec3 fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlinNoise(vec3 position, uint seed) {
    position += 1e+4;
    vec3 floorPosition = floor(position);
    vec3 fractPosition = fract(position);
    uvec3 cellCoordinates = uvec3(floorPosition);
    float value1 = dot(gradientdy(hash(cellCoordinates, seed)), fractPosition);
    float value2 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));
    float value3 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));
    float value4 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));
    float value5 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));
    float value6 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));
    float value7 = dot(gradientdy(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));
    float value8 = dot(gradientdy(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));
    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));
}

float p_noise(vec3 position, int octaveCount, float persistence, float lacunarity) {
    float value = 0.0;
    float amplitude = 1.0;
    float currentFrequency = 10.;
    uint currentSeed = uint(0);
    for (int i = 0; i < octaveCount; i++) {
        currentSeed = hash(currentSeed, 0x0U);
        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;
        amplitude *= persistence;
        currentFrequency *= lacunarity;
    }
    return value;
}

float get_max_amp(float persistence, float octaveCount) {
    persistence *= .999;
    return (1. - pow(persistence, octaveCount)) / (1. - persistence);
}

void main() {
  vec2 shape_uv = v_patternUV;

  shape_uv *= .005;
  float t = .2 * u_time;

    vec3 p = vec3(shape_uv, t);

    float oct_count = max(0., floor(u_octaveCount));
    float persistence = clamp(u_persistence, 0., 1.);
    float noise = p_noise(p, int(oct_count), persistence, u_lacunarity);

    float max_amp = get_max_amp(persistence, oct_count);
    float noise_normalized = (noise + max_amp) / (2. * max_amp) + (u_proportion - .5);
    float sharpness = clamp(u_softness, 0., 1.);
    float smooth_w = 0.5 * fwidth(noise_normalized);
    float sharp_noise = smoothstep(
        .5 - .5 * sharpness - smooth_w,
        .5 + .5 * sharpness + smooth_w,
        noise_normalized
    );

    vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, sharp_noise);
    float opacity = mix(u_color1.a, u_color2.a, sharp_noise);

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/voronoi.js
var voronoiMeta = {
  maxColorCount: 5
};
var voronoiFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform float u_scale;

uniform sampler2D u_noiseTexture;

uniform vec4 u_colors[${voronoiMeta.maxColorCount}];
uniform float u_colorsCount;

uniform float u_stepsPerColor;
uniform vec4 u_colorGlow;
uniform vec4 u_colorBack;
uniform float u_distortion;
uniform float u_gap;
uniform float u_innerGlow;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}

vec2 hash(vec2 p) {
  vec2 uv = floor(p) / 100. + .5;
  return texture(u_noiseTexture, uv).gb;
}

vec4 voronoi(vec2 x, float t) {
  vec2 ip = floor(x);
  vec2 fp = fract(x);

  vec2 mg, mr;
  float md = 8.;
  float rand = 0.;

  for (int j = -1; j <= 1; j++) {
    for (int i = -1; i <= 1; i++) {
      vec2 g = vec2(float(i), float(j));
      vec2 raw_hash = hash(ip + g);
      vec2 o = hash(ip + g);
      o = .5 + u_distortion * sin(t + TWO_PI * o);
      vec2 r = g + o - fp;
      float d = dot(r, r);

      if (d < md) {
        md = d;
        mr = r;
        mg = g;
        rand = raw_hash.x;
      }
    }
  }

  md = 8.;
  for (int j = -2; j <= 2; j++) {
    for (int i = -2; i <= 2; i++) {
      vec2 g = mg + vec2(float(i), float(j));
      vec2 o = hash(ip + g);
      o = .5 + u_distortion * sin(t + TWO_PI * o);
      vec2 r = g + o - fp;
      if (dot(mr - r, mr - r) > .00001) {
        md = min(md, dot(.5 * (mr + r), normalize(r - mr)));
      }
    }
  }

  return vec4(md, mr, rand);
}

void main() {
  vec2 shape_uv = v_patternUV;
  shape_uv *= .0125;

  float t = u_time;

  vec4 voronoiRes = voronoi(shape_uv, t);

  float shape = clamp(voronoiRes.w, 0., 1.);
  float mixer = shape * (u_colorsCount - 1.);
  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;
  float steps = max(1., u_stepsPerColor);

  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${voronoiMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);
      localT = round(localT * steps) / steps;
      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }

  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {
    float localT = mixer + 1.;
    if (mixer > (u_colorsCount - 1.)) {
      localT = mixer - (u_colorsCount - 1.);
    }
    localT = round(localT * steps) / steps;
    vec4 cFst = u_colors[0];
    cFst.rgb *= cFst.a;
    vec4 cLast = u_colors[int(u_colorsCount - 1.)];
    cLast.rgb *= cLast.a;
    gradient = mix(cLast, cFst, localT);
  }

  vec3 cellColor = gradient.rgb;
  float cellOpacity = gradient.a;

  float innerGlows = length(voronoiRes.yz * u_innerGlow + .1);
  innerGlows = pow(innerGlows, 1.5);

  vec3 color = mix(cellColor, u_colorGlow.rgb * u_colorGlow.a, u_colorGlow.a * innerGlows);
  float opacity = cellOpacity + u_colorGlow.a * innerGlows;

  float edge = voronoiRes.x;
  float smoothEdge = .02 / (2. * u_scale) * (1. + .5 * u_gap);
  edge = smoothstep(u_gap - smoothEdge, u_gap + smoothEdge, edge);

  color = mix(u_colorBack.rgb * u_colorBack.a, color, edge);
  opacity = mix(u_colorBack.a, opacity, edge);

  fragColor = vec4(color, opacity);  
}
`;

// node_modules/@paper-design/shaders/dist/shaders/waves.js
var wavesFragmentShader = `#version 300 es
precision mediump float;

uniform float u_scale;

uniform vec4 u_color1;
uniform vec4 u_color2;
uniform float u_shape;
uniform float u_frequency;
uniform float u_amplitude;
uniform float u_spacing;
uniform float u_proportion;
uniform float u_softness;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRotate}

void main() {
  vec2 shape_uv = v_patternUV;
  shape_uv *= .05;

  float wave = .5 * cos(shape_uv.x * u_frequency * TWO_PI);
  float zigzag = 2. * abs(fract(shape_uv.x * u_frequency) - .5);
  float irregular = sin(shape_uv.x * .25 * u_frequency * TWO_PI) * cos(shape_uv.x * u_frequency * TWO_PI);
  float irregular2 = .75 * (sin(shape_uv.x * u_frequency * TWO_PI) + .5 * cos(shape_uv.x * .5 * u_frequency * TWO_PI));

  float offset = mix(zigzag, wave, smoothstep(0., 1., u_shape));
  offset = mix(offset, irregular, smoothstep(1., 2., u_shape));
  offset = mix(offset, irregular2, smoothstep(2., 3., u_shape));
  offset *= 2. * u_amplitude;

  float spacing = .02 + .98 * u_spacing;
  float shape = .5 + .5 * sin((shape_uv.y + offset) * PI / spacing);

  float edge_width = .02 / (1. + abs(shape)) * (.001 + u_scale);
  edge_width += .5 * max(0., u_softness);
  float dc = clamp(u_proportion, 0., 1.);
  float t = smoothstep(dc - edge_width, dc + edge_width, shape);

  vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, t);
  float opacity = mix(u_color1.a, u_color2.a, t);

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/warp.js
var warpMeta = {
  maxColorCount: 10
};
var warpFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform float u_scale;
uniform vec2 u_resolution;

uniform vec4 u_colors[${warpMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_proportion;
uniform float u_softness;
uniform float u_shape;
uniform float u_shapeScale;
uniform float u_distortion;
uniform float u_swirl;
uniform float u_swirlIterations;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRandom}
${declareRotate}

float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smoothstep for interpolation
  vec2 u = f * f * (3.0 - 2.0 * f);

  // Do the interpolation as two nested mix operations
  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);

}

void main() {
  vec2 shape_uv = v_patternUV;
  shape_uv *= .005;

  float t = .01 * u_time;

  float noise_scale = .0005 + .006 * u_scale;

  float n1 = noise(shape_uv * 1. + t);
  float n2 = noise(shape_uv * 2. - t);
  float angle = n1 * TWO_PI;
  shape_uv.x += 4. * u_distortion * n2 * cos(angle);
  shape_uv.y += 4. * u_distortion * n2 * sin(angle);

  float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));
  for (float i = 1.; i <= iterations_number; i++) {
    shape_uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * shape_uv.y);
    shape_uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * shape_uv.x);
  }

  float proportion = clamp(u_proportion, 0., 1.);

  float shape = 0.;
  if (u_shape < .5) {
    vec2 checks_shape_uv = shape_uv * (.5 + 3.5 * u_shapeScale);
    shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);
    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
  } else if (u_shape < 1.5) {
    vec2 stripes_shape_uv = shape_uv * (2. * u_shapeScale);
    float f = fract(stripes_shape_uv.y);
    shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);
    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
  } else {
    float sh = 1. - shape_uv.y;
    float shape_scaling = 5. * (1. - u_shapeScale);
    shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));
  }

  float mixer = shape * (u_colorsCount - 1.);
  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;
  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${warpMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      float localT = clamp(mixer - float(i - 1), 0.0, 1.0);
      localT = smoothstep(.5 - .5 * u_softness, .5 + .5 * u_softness, localT);
      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }

  vec3 color = gradient.rgb;
  float opacity = gradient.a;

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;
var WarpPatterns = {
  checks: 0,
  stripes: 1,
  edge: 2
};

// node_modules/@paper-design/shaders/dist/shaders/god-rays.js
var godRaysMeta = {
  maxColorCount: 5
};
var godRaysFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colorBack;
uniform vec4 u_colors[${godRaysMeta.maxColorCount}];
uniform float u_colorsCount;

uniform float u_frequency;
uniform float u_spotty;
uniform float u_midSize;
uniform float u_midIntensity;
uniform float u_density;
uniform float u_blending;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRandom}
${declareRotate}

float hash(float n) {
  return fract(sin(n * 43758.5453123) * 43758.5453123);
}

float valueNoise(vec2 uv) {
  vec2 i = floor(uv);
  vec2 f = fract(uv);

  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  vec2 u = f * f * (3.0 - 2.0 * f);

  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

float raysShape(vec2 uv, float r, float freq, float density, float radius) {
  float a = atan(uv.y, uv.x);
  vec2 left = vec2(a * freq, r);
  vec2 right = vec2(mod(a, TWO_PI) * freq, r);
  float n_left = pow(valueNoise(left), density);
  float n_right = pow(valueNoise(right), density);
  float shape = mix(n_right, n_left, smoothstep(-.15, .15, uv.x));
  return shape;
}

void main() {
  vec2 shape_uv = v_objectUV;

  float t = .2 * u_time;

  float radius = length(shape_uv);
  float spots = 5. * abs(u_spotty);

  float density = 4. - 3. * clamp(u_density, 0., 1.);

  float delta = 1. - smoothstep(0., 1., radius);

  float middleShape = pow(u_midIntensity, .3) * smoothstep(abs(u_midSize), 0.02 * abs(u_midSize), 3.0 * radius);
  middleShape = pow(middleShape, 5.0);

  vec3 accumColor = vec3(0.0);
  float accumAlpha = 0.0;

  for (int i = 0; i < ${godRaysMeta.maxColorCount}; i++) {
    if (i >= int(u_colorsCount)) break;

    vec2 rotatedUV = rotate(shape_uv, float(i) + 1.0);

    float r1 = radius * (1.0 + 0.4 * float(i)) - 3.0 * t;
    float r2 = 0.5 * radius * (1.0 + spots) - 2.0 * t;
    float f = mix(1.0, 3.0 + 0.5 * float(i), hash(float(i) + 10.0)) * u_frequency;

    float ray = raysShape(rotatedUV, r1, 5.0 * f, density, radius);
    ray *= raysShape(rotatedUV, r2, 4.0 * f, density, radius);
    ray += (1. + 4. * ray) * middleShape;
    ray = clamp(ray, 0.0, 1.0);

    float srcAlpha = u_colors[i].a * ray;
    vec3 srcColor = u_colors[i].rgb * srcAlpha;

    vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * srcColor;
    float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * srcAlpha;

    vec3 addBlendColor = accumColor + srcColor;
    float addBlendAlpha = accumAlpha + srcAlpha;

    accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
    accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);
  }

  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;

  vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * bgColor;
  float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * u_colorBack.a;

  vec3 addBlendColor = accumColor + bgColor;
  float addBlendAlpha = accumAlpha + u_colorBack.a;

  accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
  accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);

  vec3 color = clamp(accumColor, 0.0, 1.0);
  float opacity = clamp(accumAlpha, 0.0, 1.0);


  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/spiral.js
var spiralFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_color1;
uniform vec4 u_color2;
uniform float u_density;
uniform float u_distortion;
uniform float u_strokeWidth;
uniform float u_strokeCap;
uniform float u_strokeTaper;

uniform float u_noiseFrequency;
uniform float u_noisePower;
uniform float u_softness;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareSimplexNoise}

void main() {
  vec2 shape_uv = v_patternUV * .02;

  float t = u_time;

  float l = length(shape_uv);
  float angle = atan(shape_uv.y, shape_uv.x) - 2. * t;
  float angle_norm = angle / TWO_PI;

  angle_norm += .125 * u_noisePower * snoise(.5 * u_noiseFrequency * shape_uv);

  float offset = pow(l, 1. - clamp(u_density, 0., 1.)) + angle_norm;

  float stripe_map = fract(offset);
  stripe_map -= .5 * u_strokeTaper * l;

  stripe_map += .25 * u_noisePower * snoise(u_noiseFrequency * shape_uv);

  float shape = 2. * abs(stripe_map - .5);

  shape *= (1. + u_distortion * sin(4. * l - t) * cos(PI + l + t));

  float stroke_width = clamp(u_strokeWidth, fwidth(l), 1. - fwidth(l));

  float edge_width = min(fwidth(l), fwidth(offset));

  float mid = 1. - smoothstep(.0, .9, l);
  mid = pow(mid, 2.);
  shape -= .5 * u_strokeCap * mid;

  shape = smoothstep(stroke_width - edge_width - u_softness, stroke_width + edge_width + u_softness, shape);

  vec3 color = mix(u_color1.rgb * u_color1.a, u_color2.rgb * u_color2.a, shape);
  float opacity = mix(u_color1.a, u_color2.a, shape);

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/swirl.js
var swirlMeta = {
  maxColorCount: 10
};
var swirlFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colors[${swirlMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_bandCount;
uniform float u_twist;
uniform float u_softness;
uniform float u_noisePower;
uniform float u_noiseFrequency;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareSimplexNoise}
${declareRotate}

void main() {
  vec2 shape_uv = v_objectUV;
    
  float l = length(shape_uv);

  float t = u_time;

  float angle = ceil(u_bandCount) * atan(shape_uv.y, shape_uv.x) + t;
  float angle_norm = angle / TWO_PI;  
    
  float twist = 3. * clamp(u_twist, 0., 1.);
  float offset = pow(l, -twist) + angle_norm;
  
  float shape = fract(offset);
  shape = 1. - abs(2. * shape - 1.);
  shape += u_noisePower * snoise(pow(u_noiseFrequency, 2.) * shape_uv);

  float mid = smoothstep(.2, .4, pow(l, twist));
  shape = mix(0., shape, mid);
    
  float mixer = shape * (u_colorsCount - 1.);
  float softness = u_softness + (.1 + .012 * u_colorsCount) * smoothstep(.6, .2, pow(l, twist));

  vec4 gradient = u_colors[0];
  gradient.rgb *= gradient.a;
  for (int i = 1; i < ${swirlMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;
      
      float localT = clamp(mixer - float(i - 1), 0., 1.);      
      localT = smoothstep(.5 - .5 * u_softness, .5 + .5 * u_softness, localT);

      vec4 c = u_colors[i];
      c.rgb *= c.a;
      gradient = mix(gradient, c, localT);
  }
 
  vec3 color = gradient.rgb;
  float opacity = gradient.a;
  
  ${colorBandingFix}
  
  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/dithering.js
var ditheringFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_pixelRatio;

${sizingUniformsDeclaration}

uniform vec4 u_color1;
uniform vec4 u_color2;
uniform float u_shape;
uniform float u_type;
uniform float u_pxSize;

out vec4 fragColor;

${declareSimplexNoise}
${declarePI}
${declareRandom}

float getSimplexNoise(vec2 uv, float t) {
  float noise = .5 * snoise(uv - vec2(0., .3 * t));
  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));

  return noise;
}

const int bayer2x2[4] = int[4](0, 2, 3, 1);
const int bayer4x4[16] = int[16](
  0,  8,  2, 10,
 12,  4, 14,  6,
  3, 11,  1,  9,
 15,  7, 13,  5
);

const int bayer8x8[64] = int[64](
   0, 32,  8, 40,  2, 34, 10, 42,
  48, 16, 56, 24, 50, 18, 58, 26,
  12, 44,  4, 36, 14, 46,  6, 38,
  60, 28, 52, 20, 62, 30, 54, 22,
   3, 35, 11, 43,  1, 33,  9, 41,
  51, 19, 59, 27, 49, 17, 57, 25,
  15, 47,  7, 39, 13, 45,  5, 37,
  63, 31, 55, 23, 61, 29, 53, 21
);

float getBayerValue(vec2 uv, int size) {
  ivec2 pos = ivec2(mod(uv, float(size)));
  int index = pos.y * size + pos.x;

  if (size == 2) {
    return float(bayer2x2[index]) / 4.0;
  } else if (size == 4) {
    return float(bayer4x4[index]) / 16.0;
  } else if (size == 8) {
    return float(bayer8x8[index]) / 64.0;
  }
  return 0.0;
}


void main() {
  float t = .5 * u_time;

  #define USE_PATTERN_SIZING
  #define USE_OBJECT_SIZING
  #define USE_PIXELIZATION
  // #define ADD_HELPERS

  ${sizingUV}

  vec2 dithering_uv = pxSizeUv;
  vec2 ditheringNoise_uv = uv;
  vec2 shape_uv = objectUV;
  if (u_shape < 3.5) {
    shape_uv = patternUV;
  }

  float shape = 0.;
  if (u_shape < 1.5) {
    // Simplex noise
    shape_uv *= .001;

    shape = 0.5 + 0.5 * getSimplexNoise(shape_uv, t);
    shape = smoothstep(0.3, 0.9, shape);

  } else if (u_shape < 2.5) {
    // Warp
    shape_uv *= .003;

    for (float i = 1.0; i < 6.0; i++) {
      shape_uv.x += 0.6 / i * cos(i * 2.5 * shape_uv.y + t);
      shape_uv.y += 0.6 / i * cos(i * 1.5 * shape_uv.x + t);
    }

    shape = .15 / abs(sin(t - shape_uv.y - shape_uv.x));
    shape = smoothstep(0.02, 1., shape);

  } else if (u_shape < 3.5) {
    // Dots
    shape_uv *= .05;

    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);
    float rand = fract(sin(stripeIdx * 12.9898) * 43758.5453);

    float speed = sign(rand - .5) * ceil(2. + rand);
    shape = sin(shape_uv.x) * cos(shape_uv.y + speed * t);
    shape = pow(shape, 6.);

  } else if (u_shape < 4.5) {
    // Sine wave
    shape_uv *= 4.;

    float wave = cos(.5 * shape_uv.x - 2. * t) * sin(1.5 * shape_uv.x + t) * (.75 + .25 * cos(3. * t));
    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);

  } else if (u_shape < 5.5) {
    // Ripple

    float dist = length(shape_uv);
    float waves = sin(pow(dist, 1.7) * 7. - 3. * t) * .5 + .5;
    shape = waves;

  } else if (u_shape < 6.5) {
    // Swirl

    float l = length(shape_uv);
    float angle = 6. * atan(shape_uv.y, shape_uv.x) + 4. * t;
    float twist = 1.2;
    float offset = pow(l, -twist) + angle / TWO_PI;
    float mid = smoothstep(0., 1., pow(l, twist));
    shape = mix(0., fract(offset), mid);

  } else {
    // Sphere
    shape_uv *= 2.;

    vec3 pos = vec3(shape_uv, sqrt(1. - pow(length(shape_uv), 2.)));
    vec3 lightPos = normalize(vec3(cos(1.5 * t), .8, sin(1.25 * t)));
    shape = .5 + .5 * dot(lightPos, pos);
  }


  int type = int(floor(u_type));
  float dithering = 0.0;

  switch (type) {
    case 1: {
      dithering = step(random(ditheringNoise_uv), shape);
    } break;
    case 2:
      dithering = getBayerValue(dithering_uv, 2);
      break;
    case 3:
      dithering = getBayerValue(dithering_uv, 4);
      break;
    default:
      dithering = getBayerValue(dithering_uv, 8);
      break;
  }

  dithering -= .5;
  float res = step(.5, shape + dithering);

  vec3 color = mix(u_color1.rgb, u_color2.rgb, res);
  float opacity = mix(u_color1.a, u_color2.a, res);

  #ifdef ADD_HELPERS
    vec2 helperBox = objectHelperBox;
    vec2 boxSize = objectBoxSize;
    if (u_shape < 3.5) {
      helperBox = patternHelperBox;
      boxSize = patternBoxSize;
    }
    ${drawSizingHelpers}
  #endif

  fragColor = vec4(color, opacity);
}
`;
var DitheringShapes = {
  simplex: 1,
  warp: 2,
  dots: 3,
  wave: 4,
  ripple: 5,
  swirl: 6,
  sphere: 7
};
var DitheringTypes = {
  random: 1,
  "2x2": 2,
  "4x4": 3,
  "8x8": 4
};

// node_modules/@paper-design/shaders/dist/shaders/grain-gradient.js
var grainGradientMeta = {
  maxColorCount: 7
};
var grainGradientFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_pixelRatio;

uniform vec4 u_colors[${grainGradientMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_softness;
uniform float u_intensity;
uniform float u_noise;
uniform float u_shape;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareSimplexNoise}
${declareRandom}


float noisenoise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smoothstep for interpolation
  vec2 u = f * f * (3.0 - 2.0 * f);

  // Do the interpolation as two nested mix operations
  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

float rand(vec2 n) {
  return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}
float noise(vec2 n) {
  const vec2 d = vec2(0.0, 1.0);
  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
  return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}
float fbm_4(vec2 n) {
  float total = 0.0, amplitude = .2;
  for (int i = 0; i < 4; i++) {
    total += noise(n) * amplitude;
    n += n;
    amplitude *= 0.6;
  }
  return total;
}


vec2 truchet(vec2 uv, float idx){
    idx = fract(((idx - .5) * 2.));
    if (idx > 0.75) {
        uv = vec2(1.0) - uv;
    } else if (idx > 0.5) {
        uv = vec2(1.0 - uv.x, uv.y);
    } else if (idx > 0.25) {
        uv = 1.0 - vec2(1.0 - uv.x, uv.y);
    }
    return uv;
}

void main() {
  
  float t = .1 * u_time;
  
  vec2 grain_uv = (gl_FragCoord.xy - .5 * u_resolution) / u_pixelRatio;
  vec2 shape_uv = v_objectUV;
  if (u_shape < 3.5) {
    shape_uv = v_patternUV * .005;
  }
  
  
  float shape = 0.;
  
  if (u_shape < 1.5) {
    // Sine wave
    
    float wave = cos(.5 * shape_uv.x - 2. * t) * sin(1.5 * shape_uv.x + t) * (.75 + .25 * cos(3. * t));
    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);
      
  } else if (u_shape < 2.5) {
    // Grid (dots)

    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);
    float rand = fract(sin(stripeIdx * 12.9898) * 43758.5453);

    float speed = sign(rand - .5) * ceil(2. + rand);
    shape = sin(shape_uv.x) * cos(shape_uv.y + speed * t);  
    shape = pow(shape, 4.);
  
  } else if (u_shape < 3.5) {
    // Truchet pattern
    
    float n2 = noisenoise(shape_uv * .4 - 2.5 * t);
    shape_uv.x += 10.;
    shape_uv *= .6;

    vec2 tile = truchet(fract(shape_uv), random(floor(shape_uv)));

    float distance1 = length(tile);
    float distance2 = length(tile - vec2(1.));

    n2 -= .5;
    n2 *= .1;
    shape = smoothstep(.2, .55, distance1 + n2) * smoothstep(.8, .45, distance1 - n2);
    shape += smoothstep(.2, .55, distance2 + n2) * smoothstep(.8, .45, distance2 - n2);
    
    shape = pow(shape, 1.5);
      
  } else if (u_shape < 4.5) {  
    // Corners

    shape_uv *= .6;
    vec2 outer = vec2(.5);
    
    vec2 bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(2. * t), .2 - .1 * sin(3. * t)));
    vec2 tr = smoothstep(vec2(0.), outer, 1. - shape_uv);
    shape = 1. - bl.x * bl.y * tr.x * tr.y;
    
    shape_uv = -shape_uv;
    bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(2. * t), .2 - .1 * cos(3. * t)));
    tr = smoothstep(vec2(0.), outer, 1. - shape_uv);
    shape -= bl.x * bl.y * tr.x * tr.y; 
    
    shape = 1. - smoothstep(0., 1., shape);
    
  } else if (u_shape < 5.5) {  
    // Ripple
  
    shape_uv *= 2.;
    float dist = length(.4 * shape_uv);
    float waves = sin(pow(dist, 1.2) * 5. - 3. * t) * .5 + .5;
    shape = waves;

  } else if (u_shape < 6.5) {
    // Blob

    t *= 2.;
       
    vec2 f1_traj = .25 * vec2(1.3 * sin(t), .2 + 1.3 * cos(.6 * t + 4.));
    vec2 f2_traj = .2 * vec2(1.2 * sin(-t), 1.3 * sin(1.6 * t));
    vec2 f3_traj = .25 * vec2(1.7 * cos(-.6 * t), cos(-1.6 * t));
    vec2 f4_traj = .3 * vec2(1.4 * cos(.8 * t), 1.2 * sin(-.6 * t - 3.));
    
    shape = .5 * pow(1. - clamp(0., 1., length(shape_uv + f1_traj)), 5.);
    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f2_traj)), 5.);
    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f3_traj)), 5.);
    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f4_traj)), 5.);
    
    shape = smoothstep(.0, .9, shape);
    float edge = smoothstep(.25, .3, shape);
    shape = mix(.0, shape, edge);
    
  } else {
    // Sphere

    shape_uv *= 2.;
    float d = length(shape_uv);
    float z = sqrt(1.0 - clamp(pow(d, 2.0), 0.0, 1.0));
    vec3 pos = vec3(shape_uv, z);
    vec3 lightPos = normalize(vec3(cos(3. * t), 0.8, sin(2.5 * t)));
    float lighting = dot(lightPos, pos);
    float edge = smoothstep(1., .97, d);
    shape = mix(.1, .5 + .5 * lighting, edge);
  }
  
  float snoise05 = snoise(grain_uv * .5);
  float grainDist = snoise(grain_uv * .2) * snoise05 - fbm_4(.002 * grain_uv + 10.) - fbm_4(.003 * grain_uv);
  float noise = clamp(.6 * snoise05 - fbm_4(.4 * grain_uv) - fbm_4(.001 * grain_uv), 0., 1.);

  shape += u_intensity * 2. / u_colorsCount * (grainDist + .5);
  shape += u_noise * 10. / u_colorsCount * noise;  

  float edge_w = fwidth(shape);
      
  float mixer = shape;
  vec3 gradient = u_colors[0].rgb;
  for (int i = 1; i < ${grainGradientMeta.maxColorCount}; i++) {
      if (i >= int(u_colorsCount)) break;

      vec2 borders = vec2(float(i) - u_softness, float(i) + u_softness + edge_w) / u_colorsCount;
      float localT = smoothstep(borders[0], borders[1], mixer);
      gradient = mix(gradient, u_colors[i].rgb, localT);
  }

  vec3 color = gradient;
  float opacity = 1.;

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;
var GrainGradientShapes = {
  wave: 1,
  dots: 2,
  truchet: 3,
  corners: 4,
  ripple: 5,
  blob: 6,
  sphere: 7
};

// node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js
var liquidMetalFragmentShader = `#version 300 es
precision mediump float;

uniform float u_time;

uniform float u_patternBlur;
uniform float u_patternScale;
uniform float u_dispersion;
uniform float u_liquid;
uniform float u_shape;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}
${declareRotate}
${declareSimplexNoise}

float get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float bump) {

  float ch = c2;
  float border = 0.;
  float blur = u_patternBlur + extra_blur;
  
  if (u_shape < 1.) {
    blur += .1 * smoothstep(-.4, -.6, v_responsiveUV.y);
  }

  ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));

  border = w[0];
  ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));

  bump = smoothstep(.2, .8, bump);
  border = w[0] + .4 * (1. - bump) * w[1];
  ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));

  border = w[0] + .5 * (1. - bump) * w[1];
  ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));

  border = w[0] + w[1];
  ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));

  float gradient_t = (stripe_p - w[0] - w[1]) / w[2];
  float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));
  ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));

  return ch;
}

void main() {
  
  float t = .1 * u_time;

  vec2 uv = v_objectUV;
  uv += .5;
  uv.y = 1. - uv.y;

  float cycleWidth = .5 * u_patternScale; 
  
  float mask = 1.;
  if (u_shape < 1.) {
  
    vec2 borderUV = v_responsiveUV + .5;
    float ratio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;
    vec2 edge = min(borderUV, 1. - borderUV);
    vec2 pixel_thickness = 250. / v_responsiveBoxGivenSize;
    float maskX = smoothstep(0.0, pixel_thickness.x, edge.x);
    float maskY = smoothstep(0.0, pixel_thickness.y, edge.y);
    maskX = pow(maskX, .25);
    maskY = pow(maskY, .25);
    mask = clamp(1. - maskX * maskY, 0., 1.);
    
    uv = v_responsiveUV;
    if (ratio > 1.) {
      uv.y /= ratio;
    } else {
      uv.x *= ratio;
    }
    uv += .5;
    uv.y = 1. - uv.y;
    
    cycleWidth *= 2.;

  } else if (u_shape < 2.) {  
    vec2 shapeUV = uv - .5;
    shapeUV *= .67;
    mask = pow(clamp(3. * length(shapeUV), 0., 1.), 8.);
    
    uv *= 1.3;
  } else if (u_shape < 3.) {
    vec2 shapeUV = uv - .5;
    shapeUV *= 1.68;
    
    float r = length(shapeUV) * 2.;
    float a = atan(shapeUV.y, shapeUV.x) + .2;
    r *= (1. + .05 * sin(3. * a + 2. * t));
    float f = abs(cos(a * 3.));
    mask = smoothstep(f, f + .7, r);
    
    uv *= .8;
    cycleWidth *= 1.6;

  } else if (u_shape < 4.) {
    vec2 shapeUV = uv - .5;
    shapeUV *= 1.3;
    mask = 0.;
    for (int i = 0; i < 5; i++) {
      float fi = float(i);
      float speed = 4.5 + 2. * sin(fi * 12.345);
      float angle = -fi * 1.5;
      vec2 dir1 = vec2(cos(angle), sin(angle));
      vec2 dir2 = vec2(cos(angle + 1.57), sin(angle + 1.));
      vec2 traj = .4 * (dir1 * sin(t * speed + fi * 1.23) + dir2 * cos(t * (speed * 0.7) + fi * 2.17));
      float d = length(shapeUV + traj);
      mask += pow(1.0 - clamp(d, 0.0, 1.0), 4.0);
    }
    mask = 1. - smoothstep(.85, 1., mask);
    
    uv *= 1.3;
    uv.y += .2;
  }

  float contour = smoothstep(0., 1., mask) * smoothstep(1., 0., mask);


  float diagBLtoTR = uv.x - uv.y;    
  float diagTLtoBR = uv.x + uv.y;

  vec3 color = vec3(0.);
  float opacity = 1.;

  vec3 color1 = vec3(.98, 0.98, 1.);
  vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, diagTLtoBR));

  vec2 grad_uv = uv - .5;
  
  float dist = length(grad_uv + vec2(0., .2 * diagBLtoTR));
  grad_uv = rotate(grad_uv, (.25 - .2 * diagBLtoTR) * PI);
  float direction = grad_uv.x;

  float bump = pow(1.8 * dist, 1.2);
  bump = 1. - bump;
  bump *= pow(uv.y, .3);


  float thin_strip_1_ratio = .12 / cycleWidth * (1. - .4 * bump);
  float thin_strip_2_ratio = .07 / cycleWidth * (1. + .4 * bump);
  float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);

  float thin_strip_1_width = cycleWidth * thin_strip_1_ratio;
  float thin_strip_2_width = cycleWidth * thin_strip_2_ratio;

  opacity = 1. - smoothstep(.9, .92, mask);

  float noise = snoise(uv - t);

  mask += (1. - mask) * u_liquid * noise;

  float colorDispersion = 0.;
  colorDispersion += (1. - bump);
  colorDispersion = clamp(colorDispersion, 0., 1.);

  direction += diagBLtoTR;

  direction -= 2. * noise * contour;

  bump *= clamp(pow(uv.y, .1), .3, 1.);
  direction *= (.1 + (1.1 - mask) * bump);
  direction *= smoothstep(1., .7, mask);

  float ridge = .2 * (smoothstep(.0, .15, uv.y) * smoothstep(.4, .15, uv.y));
  ridge += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));
  direction += ridge;

  direction *= (.5 + .5 * pow(uv.y, 2.));

  direction *= cycleWidth;

  direction -= t;

  float dispersionRed = colorDispersion;
  dispersionRed += .03 * bump * noise;
  float dispersionBlue = 1.3 * colorDispersion;

  dispersionRed += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bump) * smoothstep(1., .4, bump));
  dispersionRed -= diagBLtoTR;

  dispersionBlue += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bump) * smoothstep(.8, .4, bump));
  dispersionBlue -= .2 * mask;

  dispersionRed *= u_dispersion;
  dispersionBlue *= u_dispersion;

  vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);
  w[1] -= .02 * smoothstep(.0, 1., mask + bump);
  float extraBlur = bump;
  float stripe_r = mod(direction + dispersionRed, 1.);
  float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_dispersion * bump, extraBlur);
  float stripe_g = mod(direction, 1.);
  float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - 0. * diagBLtoTR), extraBlur);
  float stripe_b = mod(direction - dispersionBlue, 1.);
  float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, extraBlur);

  color = vec3(r, g, b);
  color *= opacity;

  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/shaders/pulsing-border.js
var pulsingBorderMeta = {
  maxColorCount: 5,
  maxSpotsPerColor: 5
};
var pulsingBorderFragmentShader = `#version 300 es
precision lowp float;

uniform float u_time;

uniform vec4 u_colorBack;
uniform vec4 u_colors[${pulsingBorderMeta.maxColorCount}];
uniform float u_colorsCount;
uniform float u_roundness;
uniform float u_thickness;
uniform float u_softness;
uniform float u_intensity;
uniform float u_spotSize;
uniform float u_spotsPerColor;
uniform float u_pulse;
uniform float u_smoke;
uniform float u_smokeSize;

uniform sampler2D u_pulseTexture;
uniform sampler2D u_noiseTexture;

${sizingVariablesDeclaration}

out vec4 fragColor;

${declarePI}

float roundedBox(vec2 uv, vec2 halfSize, float radius, float distance, float edgeSoftness) {
    
    float borderDistance = abs(distance) - .5 * u_thickness;
    float border = 1. - smoothstep(-.5 * edgeSoftness, .5 * edgeSoftness, borderDistance);
    border *= border;

    vec2 v0 = uv + halfSize;
    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);
    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);
    vec2 v3 = uv - halfSize;
    
    float mult = (.07 - .25 * radius);
    float m0 = mult * clamp(pow(1. - abs(v0.x - v0.y), 20.), 0., 1.);
    float m1 = mult * clamp(pow(1. - abs(v1.x + v1.y), 20.), 0., 1.);
    float m2 = mult * clamp(pow(1. - abs(v2.x + v2.y), 20.), 0., 1.);
    float m3 = mult * clamp(pow(1. - abs(v3.x - v3.y), 20.), 0., 1.);
    
    float l = edgeSoftness * .5 + .75 * u_thickness;
    float fade0 = 1. - clamp(length(v0) / l, 0., 1.);
    float fade1 = 1. - clamp(length(v1) / l, 0., 1.);
    float fade2 = 1. - clamp(length(v2) / l, 0., 1.);
    float fade3 = 1. - clamp(length(v3) / l, 0., 1.);
    
    m0 *= fade0;
    m1 *= fade1;
    m2 *= fade2;
    m3 *= fade3;
    
    float fillFix = m0 + m1 + m2 + m3;
    fillFix *= step(distance, 0.);
    fillFix *= (1. + 3. * u_thickness);
    fillFix *= (1.5 - .5 * smoothstep(0., .5, edgeSoftness));
    fillFix = clamp(fillFix, 0., 1.);

    return border + fillFix;
}

float roundedBoxSmoke(vec2 uv, vec2 halfSize, float radius, float distance, float size) {
    float borderDistance = abs(distance);
    float border = 1. - smoothstep(-.75 * size, .75 * size, borderDistance);
    border *= border;

    vec2 v0 = uv + halfSize;
    vec2 v1 = uv - vec2(-halfSize.x, halfSize.y);
    vec2 v2 = uv - vec2(halfSize.x, -halfSize.y);
    vec2 v3 = uv - halfSize;
    
    float l_mask = .5;
    float mask = smoothstep(0., 1., length(v0) / l_mask);
    mask *= smoothstep(0., 1., length(v1) / l_mask);
    mask *= smoothstep(0., 1., length(v2) / l_mask);
    mask *= smoothstep(0., 1., length(v3) / l_mask);

    return border * mask;
}

vec2 rand(vec2 p) {
  vec2 uv = floor(p) / 100. + .5;
  return texture(u_noiseTexture, uv).gb;
}

float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = rand(i).x;
  float b = rand(i + vec2(1.0, 0.0)).x;
  float c = rand(i + vec2(0.0, 1.0)).x;
  float d = rand(i + vec2(1.0, 1.0)).x;
  vec2 u = f * f * (3.0 - 2.0 * f);
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

float getWaveformValue(float time) {
  float dur = 5.;
  float wrappedTime = mod(time, dur);
  float normalizedTime = wrappedTime / dur;
  float value = texture(u_pulseTexture, vec2(normalizedTime, 0.5)).r;
  return value * 2. - 1.;
}

void main() {

  float t = .5 * u_time + 20.;
  
  vec2 borderUV = v_responsiveUV;

  float angle = atan(borderUV.y, borderUV.x) / TWO_PI;
  
  
  float borderRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;
  borderUV.x *= borderRatio;
  vec2 halfSize = vec2(.5);
  halfSize.x *= borderRatio;
  float radius = min(.5 * u_roundness, halfSize.x);
  vec2 d = abs(borderUV) - halfSize + radius;
  float outsideDistance = length(max(d, 0.)) - radius;
  float insideDistance = min(max(d.x, d.y), 0.0);
  float distance = outsideDistance + insideDistance;
    
  float border = roundedBox(borderUV, halfSize, radius, distance, .5 * u_softness);

  float pulse = u_pulse * getWaveformValue(.18 * u_time);
  
  border *= (1. + .1 * pulse);
  border *= (1. + u_intensity);

  vec2 smokeUV = .001 * u_smokeSize * v_patternUV;
  float smoke = clamp(3. * noise(2.7 * smokeUV + .5 * t), 0., 1.);
  smoke -= noise(3.4 * smokeUV - .5 * t);
  smoke *= roundedBoxSmoke(borderUV, halfSize, radius, distance, u_smoke);
  smoke = 50. * pow(smoke, 2.);
  smoke *= u_smoke;
  smoke *= (.8 + .4 * pulse);
  smoke = clamp(smoke, 0., 1.);

  border += smoke;

  float sectorsTotal = 0.;

  vec3 color = vec3(0.);
  float opacity = 0.;
  
  vec3 accumColor = vec3(0.);
  float accumAlpha = 0.;
  
  for (int i = 0; i < ${pulsingBorderMeta.maxSpotsPerColor}; i++) {
    if (i >= int(u_spotsPerColor)) break;
    float idx = float(i);
  
    for (int j = 0; j < ${pulsingBorderMeta.maxColorCount}; j++) {
      if (j >= int(u_colorsCount)) break;
      float colorIdx = float(j);

      vec2 randVal = rand(vec2(idx * 10. + 2., 40. + colorIdx));
  
      float time = (.1 + .15 * abs(sin(idx * (2. + colorIdx)) * cos(idx * (2. + 2.5 * colorIdx)))) * t + randVal.x * 3.;
      time *= mix(1., -1., step(.5, randVal.y));
  
      float mask = .2 + mix(
        sin(t + idx * (5. - 1.5 * colorIdx)),
        cos(t + idx * (3. + 1.3 * colorIdx)),
        step(mod(colorIdx, 2.), .5)
      );
      
      mask += pulse;
      if (mask < 0.) continue;
  
      float atg1 = fract(angle + time);
      float sector = smoothstep(.5 - u_spotSize, .5, atg1) * smoothstep(.5 + u_spotSize, .5, atg1);
      sector *= border;
      sector *= mask;
      sector = clamp(sector, 0., 1.);
      
      sectorsTotal += sector;
      
      float alpha = sector * u_colors[j].a;
      accumColor += u_colors[j].rgb * alpha;
      accumAlpha += alpha;
    }
  }
  
  color = accumColor;
  opacity = clamp(accumAlpha, 0., 1.);
  
  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;
  color = color + bgColor * (1. - opacity);
  opacity = opacity + u_colorBack.a * (1. - opacity);
  
  ${colorBandingFix}

  fragColor = vec4(color, opacity);
}
`;

// node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js
function getShaderColorFromString(colorString) {
  if (Array.isArray(colorString)) {
    if (colorString.length === 4) return colorString;
    if (colorString.length === 3) return [...colorString, 1];
    return fallbackColor;
  }
  if (typeof colorString !== "string") {
    return fallbackColor;
  }
  let r, g, b, a = 1;
  if (colorString.startsWith("#")) {
    [r, g, b, a] = hexToRgba(colorString);
  } else if (colorString.startsWith("rgb")) {
    [r, g, b, a] = parseRgba(colorString);
  } else if (colorString.startsWith("hsl")) {
    [r, g, b, a] = hslaToRgba(parseHsla(colorString));
  } else {
    console.error("Unsupported color format", colorString);
    return fallbackColor;
  }
  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex.split("").map((char) => char + char).join("");
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;
  const a = parseInt(hex.slice(6, 8), 16) / 255;
  return [r, g, b, a];
}
function parseRgba(rgba) {
  const match = rgba.match(/^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+))?\s*\)$/i);
  if (!match) return [0, 0, 0, 1];
  return [
    parseInt(match[1] ?? "0") / 255,
    parseInt(match[2] ?? "0") / 255,
    parseInt(match[3] ?? "0") / 255,
    match[4] === void 0 ? 1 : parseFloat(match[4])
  ];
}
function parseHsla(hsla) {
  const match = hsla.match(/^hsla?\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([0-9.]+))?\s*\)$/i);
  if (!match) return [0, 0, 0, 1];
  return [
    parseInt(match[1] ?? "0"),
    parseInt(match[2] ?? "0"),
    parseInt(match[3] ?? "0"),
    match[4] === void 0 ? 1 : parseFloat(match[4])
  ];
}
function hslaToRgba(hsla) {
  const [h, s, l, a] = hsla;
  const hDecimal = h / 360;
  const sDecimal = s / 100;
  const lDecimal = l / 100;
  let r, g, b;
  if (s === 0) {
    r = g = b = lDecimal;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;
    const p = 2 * lDecimal - q;
    r = hue2rgb(p, q, hDecimal + 1 / 3);
    g = hue2rgb(p, q, hDecimal);
    b = hue2rgb(p, q, hDecimal - 1 / 3);
  }
  return [r, g, b, a];
}
var clamp = (n, min, max) => Math.min(Math.max(n, min), max);
var fallbackColor = [0, 0, 0, 1];

// node_modules/@paper-design/shaders/dist/get-shader-noise-texture.js
function getShaderNoiseTexture(texture = 0) {
  if (typeof window === "undefined") {
    throw new Error("Paper Shaders: cant create a texture on the server");
  }
  let src = "";
  if (texture === 0) {
    src = "data:image/png;base64,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";
  } else if (texture === 1) {
    src = "data:image/png;base64,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";
  }
  const img = new Image();
  img.src = src;
  return img;
}

// node_modules/@paper-design/shaders-react/dist/use-merge-refs.js
var React = __toESM(require_react(), 1);
function useMergeRefs(refs) {
  const cleanupRef = React.useRef(void 0);
  const refEffect = React.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}

// node_modules/@paper-design/shaders-react/dist/shader-mount.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
async function processUniforms(uniformsProp) {
  const processedUniforms = {};
  const imageLoadPromises = [];
  const isValidUrl = (url) => {
    try {
      if (url.startsWith("/")) return true;
      new URL(url);
      return true;
    } catch {
      return false;
    }
  };
  const isExternalUrl = (url) => {
    try {
      if (url.startsWith("/")) return false;
      const urlObject = new URL(url, window.location.origin);
      return urlObject.origin !== window.location.origin;
    } catch {
      return false;
    }
  };
  Object.entries(uniformsProp).forEach(([key, value]) => {
    if (typeof value === "string") {
      if (!isValidUrl(value)) {
        console.warn(`Uniform "${key}" has invalid URL "${value}". Skipping image loading.`);
        return;
      }
      const imagePromise = new Promise((resolve, reject) => {
        const img = new Image();
        if (isExternalUrl(value)) {
          img.crossOrigin = "anonymous";
        }
        img.onload = () => {
          processedUniforms[key] = img;
          resolve();
        };
        img.onerror = () => {
          console.error(`Could not set uniforms. Failed to load image at ${value}`);
          reject();
        };
        img.src = value;
      });
      imageLoadPromises.push(imagePromise);
    } else {
      processedUniforms[key] = value;
    }
  });
  await Promise.all(imageLoadPromises);
  return processedUniforms;
}
var ShaderMount2 = (0, import_react.forwardRef)(
  function ShaderMountImpl({
    fragmentShader,
    uniforms: uniformsProp,
    webGlContextAttributes,
    speed = 0,
    frame = 0,
    minPixelRatio,
    maxPixelCount,
    ...divProps
  }, forwardedRef) {
    const [isInitialized, setIsInitialized] = (0, import_react.useState)(false);
    const divRef = (0, import_react.useRef)(null);
    const shaderMountRef = (0, import_react.useRef)(null);
    (0, import_react.useEffect)(() => {
      const initShader = async () => {
        const uniforms = await processUniforms(uniformsProp);
        if (divRef.current && !shaderMountRef.current) {
          shaderMountRef.current = new ShaderMount(
            divRef.current,
            fragmentShader,
            uniforms,
            webGlContextAttributes,
            speed,
            frame,
            minPixelRatio,
            maxPixelCount
          );
          setIsInitialized(true);
        }
      };
      initShader();
      return () => {
        var _a;
        (_a = shaderMountRef.current) == null ? void 0 : _a.dispose();
        shaderMountRef.current = null;
      };
    }, [fragmentShader, webGlContextAttributes]);
    (0, import_react.useEffect)(() => {
      const updateUniforms = async () => {
        var _a;
        const uniforms = await processUniforms(uniformsProp);
        (_a = shaderMountRef.current) == null ? void 0 : _a.setUniforms(uniforms);
      };
      updateUniforms();
    }, [uniformsProp, isInitialized]);
    (0, import_react.useEffect)(() => {
      var _a;
      (_a = shaderMountRef.current) == null ? void 0 : _a.setSpeed(speed);
    }, [speed, isInitialized]);
    (0, import_react.useEffect)(() => {
      var _a;
      (_a = shaderMountRef.current) == null ? void 0 : _a.setMaxPixelCount(maxPixelCount);
    }, [maxPixelCount, isInitialized]);
    (0, import_react.useEffect)(() => {
      var _a;
      (_a = shaderMountRef.current) == null ? void 0 : _a.setMinPixelRatio(minPixelRatio);
    }, [minPixelRatio, isInitialized]);
    (0, import_react.useEffect)(() => {
      var _a;
      (_a = shaderMountRef.current) == null ? void 0 : _a.setFrame(frame);
    }, [frame, isInitialized]);
    return (0, import_jsx_runtime.jsx)("div", { ref: useMergeRefs([divRef, forwardedRef]), ...divProps });
  }
);
ShaderMount2.displayName = "ShaderMount";

// node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js
function colorPropsAreEqual(prevProps, nextProps) {
  var _a, _b, _c;
  for (const key in prevProps) {
    if (key === "colors") {
      const prevIsArray = Array.isArray(prevProps.colors);
      const nextIsArray = Array.isArray(nextProps.colors);
      if (!prevIsArray || !nextIsArray) {
        if (Object.is(prevProps.colors, nextProps.colors) === false) {
          return false;
        }
        continue;
      }
      if (((_a = prevProps.colors) == null ? void 0 : _a.length) !== ((_b = nextProps.colors) == null ? void 0 : _b.length)) {
        return false;
      }
      if (!((_c = prevProps.colors) == null ? void 0 : _c.every((color, index) => {
        var _a2;
        return color === ((_a2 = nextProps.colors) == null ? void 0 : _a2[index]);
      }))) {
        return false;
      }
      continue;
    }
    if (Object.is(prevProps[key], nextProps[key]) === false) {
      return false;
    }
  }
  return true;
}

// node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var defaultPreset = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 4e4,
    colors: ["#5100ff", "#00ff80", "#ffcc00", "#ea00ff"],
    distortion: 0.8,
    swirl: 0.1
  }
};
var purplePreset = {
  name: "Purple",
  params: {
    ...defaultObjectSizing,
    speed: 0.6,
    frame: 100,
    colors: ["#aaa7d7", "#3c2b8e", "#f4eabb", "#c99cd5"],
    distortion: 0.3,
    swirl: 0.5
  }
};
var beachPreset = {
  name: "Beach",
  params: {
    ...defaultObjectSizing,
    speed: 0.1,
    frame: 0,
    colors: ["#bcecf6", "#80c3e4", "#f3eccb", "#f3d987"],
    distortion: 0.8,
    swirl: 0.35
  }
};
var meshGradientPresets = [defaultPreset, purplePreset, beachPreset];
var MeshGradient = (0, import_react2.memo)(function MeshGradientImpl({
  // Own props
  speed = defaultPreset.params.speed,
  frame = defaultPreset.params.frame,
  colors = defaultPreset.params.colors,
  distortion = defaultPreset.params.distortion,
  swirl = defaultPreset.params.swirl,
  // Sizing props
  fit = defaultPreset.params.fit,
  rotation = defaultPreset.params.rotation,
  scale = defaultPreset.params.scale,
  originX = defaultPreset.params.originX,
  originY = defaultPreset.params.originY,
  offsetX = defaultPreset.params.offsetX,
  offsetY = defaultPreset.params.offsetY,
  worldWidth = defaultPreset.params.worldWidth,
  worldHeight = defaultPreset.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_distortion: distortion,
    u_swirl: swirl,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_rotation: rotation,
    u_scale: scale,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime2.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: meshGradientFragmentShader,
      uniforms
    }
  );
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/smoke-ring.js
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var defaultPreset2 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    speed: 0.4,
    frame: 0,
    colorBack: "#ffffff",
    colors: ["#136c5e", "#0f0224"],
    noiseScale: 5,
    noiseIterations: 10,
    radius: 0.5,
    thickness: 0.25,
    innerShape: 1.2
  }
};
var poisonPreset = {
  name: "Poison",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colorBack: "#000000",
    colors: ["#d4ff00", "#0c7f08"],
    noiseScale: 2.2,
    noiseIterations: 10,
    radius: 0.4,
    thickness: 0.2,
    innerShape: 0.6
  }
};
var linePreset = {
  name: "Line",
  params: {
    ...defaultObjectSizing,
    frame: 0,
    colorBack: "#000000",
    colors: ["#1fe8ff", "#4540a4"],
    noiseScale: 1.1,
    noiseIterations: 2,
    radius: 0.38,
    thickness: 0.01,
    innerShape: 0.88,
    speed: 4
  }
};
var cloudPreset = {
  name: "Cloud",
  params: {
    ...defaultObjectSizing,
    frame: 0,
    colorBack: "#3b9bff",
    colors: ["#ffffff"],
    noiseScale: 1.5,
    noiseIterations: 10,
    radius: 0.5,
    thickness: 0.65,
    innerShape: 0.9,
    speed: 0.5
  }
};
var smokeRingPresets = [defaultPreset2, linePreset, poisonPreset, cloudPreset];
var SmokeRing = (0, import_react3.memo)(function SmokeRingImpl({
  // Own props
  speed = defaultPreset2.params.speed,
  frame = defaultPreset2.params.frame,
  colorBack = defaultPreset2.params.colorBack,
  colors = defaultPreset2.params.colors,
  noiseScale = defaultPreset2.params.noiseScale,
  thickness = defaultPreset2.params.thickness,
  radius = defaultPreset2.params.radius,
  innerShape = defaultPreset2.params.innerShape,
  noiseIterations = defaultPreset2.params.noiseIterations,
  // Sizing props
  fit = defaultPreset2.params.fit,
  scale = defaultPreset2.params.scale,
  rotation = defaultPreset2.params.rotation,
  originX = defaultPreset2.params.originX,
  originY = defaultPreset2.params.originY,
  offsetX = defaultPreset2.params.offsetX,
  offsetY = defaultPreset2.params.offsetY,
  worldWidth = defaultPreset2.params.worldWidth,
  worldHeight = defaultPreset2.params.worldHeight,
  ...props
}) {
  const noiseTexture = typeof window !== "undefined" && { u_noiseTexture: getShaderNoiseTexture() };
  const uniforms = {
    // Own uniforms
    u_colorBack: getShaderColorFromString(colorBack),
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_noiseScale: noiseScale,
    u_thickness: thickness,
    u_radius: radius,
    u_innerShape: innerShape,
    u_noiseIterations: noiseIterations,
    ...noiseTexture,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime3.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: smokeRingFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/neuro-noise.js
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var defaultPreset3 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    colorFront: "#bf9eff",
    colorBack: "#000000",
    brightness: 1.3
  }
};
var marblePreset = {
  name: "Marble",
  params: {
    ...defaultPatternSizing,
    scale: 0.4,
    speed: 0,
    frame: 0,
    colorFront: "#1d2131",
    colorBack: "#f7f7f7",
    brightness: 1.1
  }
};
var neuroNoisePresets = [defaultPreset3, marblePreset];
var NeuroNoise = (0, import_react4.memo)(function NeuroNoiseImpl({
  // Own props
  speed = defaultPreset3.params.speed,
  frame = defaultPreset3.params.frame,
  colorFront = defaultPreset3.params.colorFront,
  colorBack = defaultPreset3.params.colorBack,
  brightness = defaultPreset3.params.brightness,
  // Sizing props
  fit = defaultPreset3.params.fit,
  scale = defaultPreset3.params.scale,
  rotation = defaultPreset3.params.rotation,
  originX = defaultPreset3.params.originX,
  originY = defaultPreset3.params.originY,
  offsetX = defaultPreset3.params.offsetX,
  offsetY = defaultPreset3.params.offsetY,
  worldWidth = defaultPreset3.params.worldWidth,
  worldHeight = defaultPreset3.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colorFront: getShaderColorFromString(colorFront),
    u_colorBack: getShaderColorFromString(colorBack),
    u_brightness: brightness,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime4.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: neuroNoiseFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/dot-orbit.js
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var defaultPreset4 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 2,
    frame: 0,
    colors: ["#661400", "#ccbb00", "#cc0088"],
    size: 1,
    sizeRange: 0,
    spreading: 1,
    stepsPerColor: 2
  }
};
var dotOrbitPresets = [defaultPreset4];
var DotOrbit = (0, import_react5.memo)(function DotOrbitImpl({
  // Own props
  speed = defaultPreset4.params.speed,
  frame = defaultPreset4.params.frame,
  colors = defaultPreset4.params.colors,
  size = defaultPreset4.params.size,
  sizeRange = defaultPreset4.params.sizeRange,
  spreading = defaultPreset4.params.spreading,
  stepsPerColor = defaultPreset4.params.stepsPerColor,
  // Sizing props
  fit = defaultPreset4.params.fit,
  scale = defaultPreset4.params.scale,
  rotation = defaultPreset4.params.rotation,
  originX = defaultPreset4.params.originX,
  originY = defaultPreset4.params.originY,
  offsetX = defaultPreset4.params.offsetX,
  offsetY = defaultPreset4.params.offsetY,
  worldWidth = defaultPreset4.params.worldWidth,
  worldHeight = defaultPreset4.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_size: size,
    u_sizeRange: sizeRange,
    u_spreading: spreading,
    u_stepsPerColor: stepsPerColor,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime5.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: dotOrbitFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/dot-grid.js
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var defaultPreset5 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    colorBack: "#000000",
    colorFill: "#ffffff",
    colorStroke: "#00000000",
    size: 2,
    gapX: 50,
    gapY: 50,
    strokeWidth: 0,
    sizeRange: 0,
    opacityRange: 0,
    shape: "circle"
  }
};
var macrodataPreset = {
  name: "Macrodata",
  params: {
    ...defaultPatternSizing,
    colorBack: "#15212d",
    colorFill: "#5794ff",
    colorStroke: "#00000000",
    size: 3,
    gapX: 25,
    gapY: 25,
    strokeWidth: 0,
    sizeRange: 0.25,
    opacityRange: 0.9,
    shape: "circle"
  }
};
var trianglesPreset = {
  name: "Triangles",
  params: {
    ...defaultPatternSizing,
    colorBack: "#ffffff",
    colorFill: "#ffffff",
    colorStroke: "#808080",
    size: 5,
    gapX: 32,
    gapY: 32,
    strokeWidth: 1,
    sizeRange: 0,
    opacityRange: 0,
    shape: "triangle"
  }
};
var bubblesPreset = {
  name: "Bubbles",
  params: {
    ...defaultPatternSizing,
    colorBack: "#002c9e80",
    colorFill: "#ffffff",
    colorStroke: "#000000",
    size: 15,
    gapX: 60,
    gapY: 60,
    strokeWidth: 12,
    sizeRange: 0.7,
    opacityRange: 1.3,
    shape: "circle"
  }
};
var treeLinePreset = {
  name: "Tree line",
  params: {
    ...defaultPatternSizing,
    colorBack: "#f4fce7",
    colorFill: "#052e19",
    colorStroke: "#00000000",
    size: 8,
    gapX: 20,
    gapY: 90,
    strokeWidth: 0,
    sizeRange: 1,
    opacityRange: 0.6,
    shape: "circle"
  }
};
var diamondsPreset = {
  name: "Diamonds",
  params: {
    ...defaultPatternSizing,
    colorBack: "#ffffff",
    colorFill: "#ff0000",
    colorStroke: "#00000000",
    size: 15,
    gapX: 30,
    gapY: 30,
    strokeWidth: 0,
    sizeRange: 0,
    opacityRange: 2,
    shape: "diamond"
  }
};
var wallpaperPreset = {
  name: "Wallpaper",
  params: {
    ...defaultPatternSizing,
    colorBack: "#204030",
    colorFill: "#00000000",
    colorStroke: "#bd955b",
    size: 9,
    gapX: 32,
    gapY: 32,
    strokeWidth: 1,
    sizeRange: 0,
    opacityRange: 0,
    shape: "diamond"
  }
};
var matrixPreset = {
  name: "Enter the Matrix",
  params: {
    ...defaultPatternSizing,
    colorBack: "#000000",
    colorFill: "#47ffea",
    colorStroke: "#00000000",
    size: 2,
    gapX: 10,
    gapY: 10,
    strokeWidth: 0.5,
    sizeRange: 0.25,
    opacityRange: 1,
    shape: "triangle"
  }
};
var waveformPreset = {
  name: "Waveform",
  params: {
    ...defaultPatternSizing,
    colorBack: "#ffffff",
    colorFill: "#0934b8",
    colorStroke: "#00000000",
    size: 100,
    gapX: 2,
    gapY: 215,
    strokeWidth: 0,
    sizeRange: 1,
    opacityRange: 0,
    shape: "square"
  }
};
var dotGridPresets = [
  defaultPreset5,
  macrodataPreset,
  trianglesPreset,
  bubblesPreset,
  treeLinePreset,
  diamondsPreset,
  wallpaperPreset,
  matrixPreset,
  waveformPreset
];
var DotGrid = (0, import_react6.memo)(function DotGridImpl({
  // Own props
  colorBack = defaultPreset5.params.colorBack,
  colorFill = defaultPreset5.params.colorFill,
  colorStroke = defaultPreset5.params.colorStroke,
  size = defaultPreset5.params.size,
  gapX = defaultPreset5.params.gapX,
  gapY = defaultPreset5.params.gapY,
  strokeWidth = defaultPreset5.params.strokeWidth,
  sizeRange = defaultPreset5.params.sizeRange,
  opacityRange = defaultPreset5.params.opacityRange,
  shape = defaultPreset5.params.shape,
  // Sizing props
  fit = defaultPreset5.params.fit,
  scale = defaultPreset5.params.scale,
  rotation = defaultPreset5.params.rotation,
  originX = defaultPreset5.params.originX,
  originY = defaultPreset5.params.originY,
  offsetX = defaultPreset5.params.offsetX,
  offsetY = defaultPreset5.params.offsetY,
  worldWidth = defaultPreset5.params.worldWidth,
  worldHeight = defaultPreset5.params.worldHeight,
  // Other props
  maxPixelCount = 6016 * 3384,
  // Higher max resolution for this shader
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colorBack: getShaderColorFromString(colorBack),
    u_colorFill: getShaderColorFromString(colorFill),
    u_colorStroke: getShaderColorFromString(colorStroke),
    u_dotSize: size,
    u_gapX: gapX,
    u_gapY: gapY,
    u_strokeWidth: strokeWidth,
    u_sizeRange: sizeRange,
    u_opacityRange: opacityRange,
    u_shape: DotGridShapes[shape],
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime6.jsx)(ShaderMount2, { ...props, maxPixelCount, fragmentShader: dotGridFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/simplex-noise.js
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var defaultPreset6 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    colors: ["#40a0bf", "#bf4040", "#ffcc00"],
    stepsPerColor: 3,
    softness: 0
  }
};
var simplexNoisePresets = [defaultPreset6];
var SimplexNoise = (0, import_react7.memo)(function SimplexNoiseImpl({
  // Own props
  speed = defaultPreset6.params.speed,
  frame = defaultPreset6.params.frame,
  colors = defaultPreset6.params.colors,
  stepsPerColor = defaultPreset6.params.stepsPerColor,
  softness = defaultPreset6.params.softness,
  // Sizing props
  fit = defaultPreset6.params.fit,
  scale = defaultPreset6.params.scale,
  rotation = defaultPreset6.params.rotation,
  originX = defaultPreset6.params.originX,
  originY = defaultPreset6.params.originY,
  offsetX = defaultPreset6.params.offsetX,
  offsetY = defaultPreset6.params.offsetY,
  worldWidth = defaultPreset6.params.worldWidth,
  worldHeight = defaultPreset6.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_stepsPerColor: stepsPerColor,
    u_softness: softness,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime7.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: simplexNoiseFragmentShader,
      uniforms
    }
  );
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/metaballs.js
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var defaultPreset7 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    scale: 1,
    speed: 1,
    frame: 0,
    colors: ["#b399ff", "#99ffc4", "#ffe699", "#e099ff"],
    count: 7,
    size: 1
  }
};
var metaballsPresets = [defaultPreset7];
var Metaballs = (0, import_react8.memo)(function MetaballsImpl({
  // Own props
  speed = defaultPreset7.params.speed,
  frame = defaultPreset7.params.frame,
  colors = defaultPreset7.params.colors,
  size = defaultPreset7.params.size,
  count = defaultPreset7.params.count,
  // Sizing props
  fit = defaultPreset7.params.fit,
  rotation = defaultPreset7.params.rotation,
  scale = defaultPreset7.params.scale,
  originX = defaultPreset7.params.originX,
  originY = defaultPreset7.params.originY,
  offsetX = defaultPreset7.params.offsetX,
  offsetY = defaultPreset7.params.offsetY,
  worldWidth = defaultPreset7.params.worldWidth,
  worldHeight = defaultPreset7.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_size: size,
    u_count: count,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_rotation: rotation,
    u_scale: scale,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime8.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: metaballsFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/waves.js
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var defaultPreset8 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    scale: 1.6,
    rotation: 0,
    color1: "#ffffff",
    color2: "#102c70",
    shape: 0,
    frequency: 0.5,
    amplitude: 0.6,
    spacing: 0.65,
    proportion: 0.15,
    softness: 0
  }
};
var spikesPreset = {
  name: "Spikes",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 2.3,
    rotation: 0,
    color1: "#fdffe6",
    color2: "#34123b",
    shape: 0,
    frequency: 0.5,
    amplitude: 0.9,
    spacing: 0.37,
    proportion: 0.93,
    softness: 0.15
  }
};
var groovyPreset = {
  name: "Groovy",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.5,
    rotation: 1,
    color1: "#fcfcee",
    color2: "#ff896b",
    shape: 2.37,
    frequency: 0.2,
    amplitude: 0.67,
    spacing: 1.17,
    proportion: 0.57,
    softness: 0
  }
};
var tangledUpPreset = {
  name: "Tangled up",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 3.04,
    rotation: 1,
    color1: "#133a41",
    color2: "#c2d8b6",
    shape: 3,
    frequency: 0.44,
    amplitude: 0.57,
    spacing: 1.05,
    proportion: 0.97,
    softness: 0
  }
};
var zigZagPreset = {
  name: "Zig zag",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 2.7,
    rotation: 1,
    color1: "#000000",
    color2: "#e6e6e6",
    shape: 0,
    frequency: 0.6,
    amplitude: 0.8,
    spacing: 0.5,
    proportion: 1,
    softness: 0.5
  }
};
var waveRidePreset = {
  name: "Ride the wave",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.84,
    rotation: 0,
    color1: "#fdffe6",
    color2: "#1f1f1f",
    shape: 2.23,
    frequency: 0.1,
    amplitude: 0.6,
    spacing: 0.41,
    proportion: 0.99,
    softness: 0
  }
};
var wavesPresets = [
  defaultPreset8,
  spikesPreset,
  groovyPreset,
  tangledUpPreset,
  zigZagPreset,
  waveRidePreset
];
var Waves = (0, import_react9.memo)(function WavesImpl({
  // Own props
  color1 = defaultPreset8.params.color1,
  color2 = defaultPreset8.params.color2,
  shape = defaultPreset8.params.shape,
  frequency = defaultPreset8.params.frequency,
  amplitude = defaultPreset8.params.amplitude,
  spacing = defaultPreset8.params.spacing,
  proportion = defaultPreset8.params.proportion,
  softness = defaultPreset8.params.softness,
  // Sizing props
  fit = defaultPreset8.params.fit,
  scale = defaultPreset8.params.scale,
  rotation = defaultPreset8.params.rotation,
  offsetX = defaultPreset8.params.offsetX,
  offsetY = defaultPreset8.params.offsetY,
  originX = defaultPreset8.params.originX,
  originY = defaultPreset8.params.originY,
  worldWidth = defaultPreset8.params.worldWidth,
  worldHeight = defaultPreset8.params.worldHeight,
  // Other props
  maxPixelCount = 6016 * 3384,
  // Higher max resolution for this shader
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_color1: getShaderColorFromString(color1),
    u_color2: getShaderColorFromString(color2),
    u_shape: shape,
    u_frequency: frequency,
    u_amplitude: amplitude,
    u_spacing: spacing,
    u_proportion: proportion,
    u_softness: softness,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime9.jsx)(ShaderMount2, { ...props, fragmentShader: wavesFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/perlin-noise.js
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var defaultPreset9 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 0.5,
    frame: 0,
    color1: "#262626",
    color2: "#d9d9d9",
    proportion: 0.35,
    softness: 0.1,
    octaveCount: 2,
    persistence: 1,
    lacunarity: 1.5
  }
};
var nintendoWaterPreset = {
  name: "Nintendo Water",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.2,
    speed: 0.4,
    frame: 0,
    color1: "#2d69d4",
    color2: "#d1eefc",
    proportion: 0.42,
    softness: 0,
    octaveCount: 2,
    persistence: 0.55,
    lacunarity: 1.8
  }
};
var colonyPreset = {
  name: "Colony",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.15,
    speed: 0,
    frame: 0,
    color1: "#f4f0ae",
    color2: "#0a1a5e",
    octaveCount: 6,
    persistence: 1,
    lacunarity: 2.55,
    proportion: 0.65,
    softness: 0.35
  }
};
var phosphenesPreset = {
  name: "Phosphenes",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.03,
    speed: 0.15,
    frame: 0,
    color1: "#ec7c8b",
    color2: "#66cc99",
    proportion: 0.45,
    softness: 0.45,
    octaveCount: 6,
    persistence: 0.3,
    lacunarity: 3
  }
};
var mossPreset = {
  name: "Moss",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 0.15,
    speed: 0.02,
    frame: 0,
    color1: "#05ff4a",
    color2: "#262626",
    proportion: 0.65,
    softness: 0.35,
    octaveCount: 6,
    persistence: 1,
    lacunarity: 2.55
  }
};
var wormsPreset = {
  name: "Worms",
  params: {
    ...defaultPatternSizing,
    scale: 1 / 2,
    speed: 0,
    frame: 0,
    color1: "#ffffff",
    color2: "#595959",
    proportion: 0.5,
    softness: 0,
    octaveCount: 1,
    persistence: 1,
    lacunarity: 1.5
  }
};
var perlinNoisePresets = [
  defaultPreset9,
  nintendoWaterPreset,
  colonyPreset,
  phosphenesPreset,
  mossPreset,
  wormsPreset
];
var PerlinNoise = (0, import_react10.memo)(function PerlinNoiseImpl({
  // Own props
  speed = defaultPreset9.params.speed,
  frame = defaultPreset9.params.frame,
  color1 = defaultPreset9.params.color1,
  color2 = defaultPreset9.params.color2,
  proportion = defaultPreset9.params.proportion,
  softness = defaultPreset9.params.softness,
  octaveCount = defaultPreset9.params.octaveCount,
  persistence = defaultPreset9.params.persistence,
  lacunarity,
  // Sizing props
  fit = defaultPreset9.params.fit,
  worldWidth = defaultPreset9.params.worldWidth,
  worldHeight = defaultPreset9.params.worldHeight,
  scale = defaultPreset9.params.scale,
  rotation = defaultPreset9.params.rotation,
  originX = defaultPreset9.params.originX,
  originY = defaultPreset9.params.originY,
  offsetX = defaultPreset9.params.offsetX,
  offsetY = defaultPreset9.params.offsetY,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_color1: getShaderColorFromString(color1),
    u_color2: getShaderColorFromString(color2),
    u_proportion: proportion,
    u_softness: softness ?? defaultPreset9.params.softness,
    u_octaveCount: octaveCount ?? defaultPreset9.params.octaveCount,
    u_persistence: persistence ?? defaultPreset9.params.persistence,
    u_lacunarity: lacunarity ?? defaultPreset9.params.lacunarity,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime10.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: perlinNoiseFragmentShader,
      uniforms
    }
  );
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/voronoi.js
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var defaultPreset10 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 0.5,
    frame: 0,
    colors: ["#e65c1a", "#e6c31a", "#1aace6"],
    stepsPerColor: 1,
    colorGlow: "#5500ff",
    colorBack: "#ffffff",
    distortion: 0.42,
    gap: 0.06,
    innerGlow: 0
  }
};
var shadowPreset = {
  name: "Shadow",
  params: {
    ...defaultPatternSizing,
    speed: 0.5,
    frame: 0,
    colors: ["#faf7fe", "#fefdf7", "#fbf7fe"],
    stepsPerColor: 1,
    colorGlow: "#76587a",
    colorBack: "#ffffff",
    distortion: 0.23,
    gap: 0,
    innerGlow: 0.8
  }
};
var voronoiPresets = [defaultPreset10, shadowPreset];
var Voronoi = (0, import_react11.memo)(function VoronoiImpl({
  // Own props
  speed = defaultPreset10.params.speed,
  frame = defaultPreset10.params.frame,
  colors = defaultPreset10.params.colors,
  stepsPerColor = defaultPreset10.params.stepsPerColor,
  colorGlow = defaultPreset10.params.colorGlow,
  colorBack = defaultPreset10.params.colorBack,
  distortion = defaultPreset10.params.distortion,
  gap = defaultPreset10.params.gap,
  innerGlow = defaultPreset10.params.innerGlow,
  // Sizing props
  fit = defaultPreset10.params.fit,
  scale = defaultPreset10.params.scale,
  rotation = defaultPreset10.params.rotation,
  originX = defaultPreset10.params.originX,
  originY = defaultPreset10.params.originY,
  offsetX = defaultPreset10.params.offsetX,
  offsetY = defaultPreset10.params.offsetY,
  worldWidth = defaultPreset10.params.worldWidth,
  worldHeight = defaultPreset10.params.worldHeight,
  ...props
}) {
  const noiseTexture = typeof window !== "undefined" && { u_noiseTexture: getShaderNoiseTexture() };
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_stepsPerColor: stepsPerColor,
    u_colorGlow: getShaderColorFromString(colorGlow),
    u_colorBack: getShaderColorFromString(colorBack),
    u_distortion: distortion,
    u_gap: gap,
    u_innerGlow: innerGlow,
    ...noiseTexture,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime11.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: voronoiFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/warp.js
var import_react12 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var defaultPreset11 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    rotation: 0,
    speed: 1,
    frame: 0,
    colors: ["#262626", "#7accf2", "#ffffff"],
    proportion: 0.35,
    softness: 1,
    distortion: 0.25,
    swirl: 0.8,
    swirlIterations: 10,
    shapeScale: 0.1,
    shape: "checks"
  }
};
var presetAbyss = {
  name: "The Abyss",
  params: {
    ...defaultPatternSizing,
    scale: 3,
    rotation: 2,
    speed: 0.6,
    frame: 0,
    colors: ["#15122e", "#7b89f2", "#ffffff"],
    proportion: 0,
    softness: 1,
    distortion: 0.09,
    swirl: 0.48,
    swirlIterations: 5,
    shapeScale: 0.85,
    shape: "edge"
  }
};
var presetCauldron = {
  name: "Cauldron Pot",
  params: {
    ...defaultPatternSizing,
    scale: 0.9,
    rotation: 160,
    speed: 20,
    frame: 0,
    colors: ["#a7e58b", "#324472", "#0a180d"],
    proportion: 0.64,
    softness: 1.5,
    distortion: 0.2,
    swirl: 0.86,
    swirlIterations: 7,
    shapeScale: 0.6,
    shape: "edge"
  }
};
var presetFilteredLight = {
  name: "Filtered Light",
  params: {
    ...defaultPatternSizing,
    scale: 0.3,
    rotation: 45,
    speed: 3.2,
    frame: 0,
    colors: ["#171714", "#d4d8be", "#f9f9e0"],
    proportion: 0.4,
    softness: 1,
    distortion: 0.09,
    swirl: 0.1,
    swirlIterations: 0,
    shapeScale: 0.1,
    shape: "stripes"
  }
};
var presetIceberg = {
  name: "Iceberg",
  params: {
    ...defaultPatternSizing,
    scale: 0.8,
    rotation: 190,
    offsetX: 0.3,
    speed: 0.5,
    frame: 0,
    colors: ["#ffffff", "#324771", "#0a180d"],
    proportion: 0.3,
    softness: 1.2,
    distortion: 0.2,
    swirl: 0.86,
    swirlIterations: 7,
    shapeScale: 0,
    shape: "checks"
  }
};
var presetInk = {
  name: "Live Ink",
  params: {
    ...defaultPatternSizing,
    scale: 1.2,
    rotation: 44,
    offsetY: -0.3,
    speed: 10,
    frame: 0,
    colors: ["#111314", "#9faeab", "#f3fee7"],
    proportion: 0.35,
    softness: 0,
    distortion: 0.25,
    swirl: 0.8,
    swirlIterations: 10,
    shapeScale: 0.28,
    shape: "checks"
  }
};
var presetKelp = {
  name: "Kelp",
  params: {
    ...defaultPatternSizing,
    scale: 0.88,
    rotation: 50,
    speed: 80,
    frame: 0,
    colors: ["#dbff8f", "#404f3e", "#091316"],
    proportion: 0.93,
    softness: 0.05,
    distortion: 0,
    swirl: 0.15,
    swirlIterations: 0,
    shapeScale: 0.74,
    shape: "stripes"
  }
};
var presetNectar = {
  name: "Nectar",
  params: {
    ...defaultPatternSizing,
    scale: 2,
    offsetY: 0.6,
    rotation: 0,
    speed: 30,
    frame: 0,
    colors: ["#151310", "#d3a86b", "#f0edea"],
    proportion: 0.24,
    softness: 1,
    distortion: 0.21,
    swirl: 0.57,
    swirlIterations: 10,
    shapeScale: 0.75,
    shape: "edge"
  }
};
var presetPassion = {
  name: "Passion",
  params: {
    ...defaultPatternSizing,
    scale: 2.5,
    rotation: 1.35,
    speed: 15,
    frame: 0,
    colors: ["#3b1515", "#954751", "#ffc085"],
    proportion: 0.5,
    softness: 1,
    distortion: 0.09,
    swirl: 0.9,
    swirlIterations: 6,
    shapeScale: 0.25,
    shape: "checks"
  }
};
var presetPhantom = {
  name: "Phantom",
  params: {
    ...defaultPatternSizing,
    scale: 1.2,
    rotation: 180,
    offsetY: -0.2,
    speed: 30,
    frame: 0,
    colors: ["#12112c", "#7b89f2", "#d7dcfb"],
    proportion: 0.5,
    softness: 1,
    distortion: 0.2,
    swirl: 0.3,
    swirlIterations: 7,
    shapeScale: 0.1,
    shape: "checks"
  }
};
var presetSilk = {
  name: "Silk",
  params: {
    ...defaultPatternSizing,
    scale: 2,
    rotation: 0,
    speed: 5,
    frame: 0,
    colors: ["#141111", "#665551", "#baaea9"],
    proportion: 0,
    softness: 1,
    distortion: 0.3,
    swirl: 0.6,
    swirlIterations: 11,
    shapeScale: 0.25,
    shape: "stripes"
  }
};
var warpPresets = [
  defaultPreset11,
  presetAbyss,
  presetCauldron,
  presetFilteredLight,
  presetIceberg,
  presetInk,
  presetKelp,
  presetNectar,
  presetPassion,
  presetPhantom,
  presetSilk
];
var Warp = (0, import_react12.memo)(function WarpImpl({
  // Own props
  speed = defaultPreset11.params.speed,
  frame = defaultPreset11.params.frame,
  colors = defaultPreset11.params.colors,
  proportion = defaultPreset11.params.proportion,
  softness = defaultPreset11.params.softness,
  distortion = defaultPreset11.params.distortion,
  swirl = defaultPreset11.params.swirl,
  swirlIterations = defaultPreset11.params.swirlIterations,
  shapeScale = defaultPreset11.params.shapeScale,
  shape = defaultPreset11.params.shape,
  // Sizing props
  fit = defaultPreset11.params.fit,
  scale = defaultPreset11.params.scale,
  rotation = defaultPreset11.params.rotation,
  originX = defaultPreset11.params.originX,
  originY = defaultPreset11.params.originY,
  offsetX = defaultPreset11.params.offsetX,
  offsetY = defaultPreset11.params.offsetY,
  worldWidth = defaultPreset11.params.worldWidth,
  worldHeight = defaultPreset11.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_proportion: proportion,
    u_softness: softness,
    u_distortion: distortion,
    u_swirl: swirl,
    u_swirlIterations: swirlIterations,
    u_shapeScale: shapeScale,
    u_shape: WarpPatterns[shape],
    // Sizing uniforms
    u_scale: scale,
    u_rotation: rotation,
    u_fit: ShaderFitOptions[fit],
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime12.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: warpFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/god-rays.js
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var defaultPreset12 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    offsetX: -0.4,
    offsetY: -0.4,
    colorBack: "#002238",
    colors: ["#ffcd66", "#ffb899", "#a8fffb"],
    frequency: 6,
    spotty: 0.28,
    midIntensity: 1,
    midSize: 3,
    density: 0.3,
    blending: 0,
    speed: 1,
    frame: 0
  }
};
var auroraPreset = {
  name: "Aurora",
  params: {
    ...defaultObjectSizing,
    offsetY: 1,
    colorBack: "#404040",
    colors: ["#666eff", "#66ff99", "#66d9ff"],
    frequency: 2.4,
    spotty: 0.9,
    midIntensity: 0.8,
    midSize: 2.1,
    density: 0.5,
    blending: 1,
    speed: 0.5,
    frame: 0
  }
};
var warpPreset = {
  name: "Warp",
  params: {
    ...defaultObjectSizing,
    colorBack: "#000000",
    colors: ["#ff00c4", "#ff8c00", "#ffffff"],
    frequency: 1.2,
    spotty: 0.15,
    midIntensity: 0,
    midSize: 0,
    density: 0.79,
    blending: 0.4,
    speed: 2,
    frame: 0
  }
};
var linearPreset = {
  name: "Linear",
  params: {
    ...defaultObjectSizing,
    offsetX: 0.2,
    offsetY: -0.7,
    colorBack: "#000000",
    colors: ["#ffffff1f", "#ffffff3d", "#ffffff29"],
    frequency: 1.2,
    spotty: 0.25,
    midSize: 1.1,
    midIntensity: 0.75,
    density: 0.79,
    blending: 1,
    speed: 0.5,
    frame: 0
  }
};
var etherPreset = {
  name: "Ether",
  params: {
    ...defaultObjectSizing,
    offsetX: -0.6,
    colorBack: "#090f1d",
    colors: ["#148effa6", "#c4dffebe", "#232a47"],
    frequency: 0.3,
    spotty: 0.77,
    midSize: 1.1,
    midIntensity: 0.5,
    density: 0.6,
    blending: 0.6,
    speed: 1,
    frame: 0
  }
};
var godRaysPresets = [defaultPreset12, auroraPreset, warpPreset, linearPreset, etherPreset];
var GodRays = (0, import_react13.memo)(function GodRaysImpl({
  // Own props
  speed = defaultPreset12.params.speed,
  frame = defaultPreset12.params.frame,
  colorBack = defaultPreset12.params.colorBack,
  colors = defaultPreset12.params.colors,
  frequency = defaultPreset12.params.frequency,
  spotty = defaultPreset12.params.spotty,
  midIntensity = defaultPreset12.params.midIntensity,
  midSize = defaultPreset12.params.midSize,
  density = defaultPreset12.params.density,
  blending = defaultPreset12.params.blending,
  // Sizing props
  fit = defaultPreset12.params.fit,
  scale = defaultPreset12.params.scale,
  rotation = defaultPreset12.params.rotation,
  originX = defaultPreset12.params.originX,
  originY = defaultPreset12.params.originY,
  offsetX = defaultPreset12.params.offsetX,
  offsetY = defaultPreset12.params.offsetY,
  worldWidth = defaultPreset12.params.worldWidth,
  worldHeight = defaultPreset12.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colorBack: getShaderColorFromString(colorBack),
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_frequency: frequency,
    u_spotty: spotty,
    u_midIntensity: midIntensity,
    u_midSize: midSize,
    u_density: density,
    u_blending: blending,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime13.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: godRaysFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/spiral.js
var import_react14 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var defaultPreset13 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    color1: "#fafafa",
    color2: "#808080",
    density: 0,
    distortion: 0,
    strokeWidth: 0.5,
    strokeTaper: 0,
    strokeCap: 0,
    noiseFrequency: 0,
    noisePower: 0,
    softness: 0.01,
    speed: 1,
    frame: 0
  }
};
var noisyPreset = {
  name: "Noisy",
  params: {
    ...defaultPatternSizing,
    color1: "#a1ef2a",
    color2: "#288918",
    scale: 1.3,
    density: 0.5,
    distortion: 0,
    strokeWidth: 0.5,
    strokeTaper: 0,
    strokeCap: 0.5,
    noiseFrequency: 0.1,
    noisePower: 1,
    softness: 0,
    speed: 1,
    frame: 0
  }
};
var dropletPreset = {
  name: "Droplet",
  params: {
    ...defaultPatternSizing,
    color1: "#bf40a0",
    color2: "#effafe",
    scale: 0.65,
    density: 0,
    distortion: 0,
    strokeWidth: 0.05,
    strokeTaper: 0,
    strokeCap: 1,
    noiseFrequency: 0,
    noisePower: 0,
    softness: 0,
    speed: 1,
    frame: 0
  }
};
var sandPreset = {
  name: "Sand",
  params: {
    ...defaultPatternSizing,
    color1: "#a09560",
    color2: "#dedede",
    scale: 3,
    density: 0,
    distortion: 0,
    strokeWidth: 0.15,
    strokeTaper: 0,
    strokeCap: 0,
    noiseFrequency: 30,
    noisePower: 1,
    softness: 0.2,
    speed: 0,
    frame: 0
  }
};
var swirlPreset = {
  name: "Swirl",
  params: {
    ...defaultPatternSizing,
    color1: "#b3e6d9",
    color2: "#1a2b4d",
    scale: 4,
    density: 0.8,
    distortion: 0,
    strokeWidth: 0.5,
    strokeTaper: 0,
    strokeCap: 0,
    noiseFrequency: 0,
    noisePower: 0,
    softness: 0.5,
    speed: 1,
    frame: 0
  }
};
var hookPreset = {
  name: "Hook",
  params: {
    ...defaultPatternSizing,
    color1: "#000000",
    color2: "#85c2e0",
    scale: 0.8,
    density: 0,
    distortion: 0,
    strokeWidth: 0.5,
    strokeTaper: 0.5,
    strokeCap: 0,
    noiseFrequency: 0,
    noisePower: 0,
    softness: 0.02,
    speed: 3,
    frame: 0
  }
};
var vinylPreset = {
  name: "Vinyl",
  params: {
    ...defaultPatternSizing,
    color1: "#262626",
    color2: "#c2babb",
    density: 0,
    distortion: 0.3,
    strokeWidth: 0.95,
    strokeTaper: 0,
    strokeCap: 1,
    noiseFrequency: 0,
    noisePower: 0,
    softness: 0.11,
    speed: 1,
    frame: 0
  }
};
var spiralPresets = [
  defaultPreset13,
  noisyPreset,
  dropletPreset,
  swirlPreset,
  sandPreset,
  hookPreset,
  vinylPreset
];
var Spiral = (0, import_react14.memo)(function SpiralImpl({
  // Own props
  speed = defaultPreset13.params.speed,
  frame = defaultPreset13.params.frame,
  color1 = defaultPreset13.params.color1,
  color2 = defaultPreset13.params.color2,
  density = defaultPreset13.params.density,
  distortion = defaultPreset13.params.distortion,
  strokeWidth = defaultPreset13.params.strokeWidth,
  strokeTaper = defaultPreset13.params.strokeTaper,
  strokeCap = defaultPreset13.params.strokeCap,
  noiseFrequency = defaultPreset13.params.noiseFrequency,
  noisePower = defaultPreset13.params.noisePower,
  softness = defaultPreset13.params.softness,
  // Sizing props
  fit = defaultPreset13.params.fit,
  rotation = defaultPreset13.params.rotation,
  scale = defaultPreset13.params.scale,
  originX = defaultPreset13.params.originX,
  originY = defaultPreset13.params.originY,
  offsetX = defaultPreset13.params.offsetX,
  offsetY = defaultPreset13.params.offsetY,
  worldWidth = defaultPreset13.params.worldWidth,
  worldHeight = defaultPreset13.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_color1: getShaderColorFromString(color1),
    u_color2: getShaderColorFromString(color2),
    u_density: density,
    u_distortion: distortion,
    u_strokeWidth: strokeWidth,
    u_strokeTaper: strokeTaper,
    u_strokeCap: strokeCap,
    u_noiseFrequency: noiseFrequency,
    u_noisePower: noisePower,
    u_softness: softness,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime14.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: spiralFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/swirl.js
var import_react15 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var defaultPreset14 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    scale: 2.28,
    offsetX: -0.4,
    offsetY: 0.3,
    speed: 0.32,
    frame: 0,
    colors: ["#452424", "#0b7f05", "#ffe785", "#ff335c"],
    bandCount: 5,
    twist: 0.11,
    softness: 0.01,
    noiseFrequency: 1.2,
    noisePower: 0.46
  }
};
var openingPreset = {
  name: "Opening",
  params: {
    ...defaultObjectSizing,
    offsetX: -0.4,
    offsetY: 0.86,
    speed: 0.6,
    frame: 0,
    colors: ["#8b2e5f", "#b14467", "#e67a62", "#ff715c", "#ffc55c", "#f9f97c"],
    bandCount: 3,
    twist: 0.3,
    softness: 0,
    noiseFrequency: 2,
    noisePower: 0
  }
};
var jamesBondPreset = {
  name: "007",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colors: ["#000000", "#2e2e2e", "#000000", "#ffffff"],
    bandCount: 4,
    twist: 0.4,
    softness: 0,
    noiseFrequency: 0,
    noisePower: 0
  }
};
var candyPreset = {
  name: "Candy",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colors: ["#ffcd66", "#6bbceb", "#8a1fff"],
    bandCount: 2.5,
    twist: 0.2,
    softness: 1,
    noiseFrequency: 0,
    noisePower: 0
  }
};
var swirlPresets = [defaultPreset14, openingPreset, jamesBondPreset, candyPreset];
var Swirl = (0, import_react15.memo)(function SwirlImpl({
  // Own props
  speed = defaultPreset14.params.speed,
  frame = defaultPreset14.params.frame,
  colors = defaultPreset14.params.colors,
  bandCount = defaultPreset14.params.bandCount,
  twist = defaultPreset14.params.twist,
  softness = defaultPreset14.params.softness,
  noiseFrequency = defaultPreset14.params.noiseFrequency,
  noisePower = defaultPreset14.params.noisePower,
  // Sizing props
  fit = defaultPreset14.params.fit,
  rotation = defaultPreset14.params.rotation,
  scale = defaultPreset14.params.scale,
  originX = defaultPreset14.params.originX,
  originY = defaultPreset14.params.originY,
  offsetX = defaultPreset14.params.offsetX,
  offsetY = defaultPreset14.params.offsetY,
  worldWidth = defaultPreset14.params.worldWidth,
  worldHeight = defaultPreset14.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_bandCount: bandCount,
    u_twist: twist,
    u_softness: softness,
    u_noiseFrequency: noiseFrequency,
    u_noisePower: noisePower,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime15.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: swirlFragmentShader, uniforms });
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/dithering.js
var import_react16 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var defaultPreset15 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    color1: "#252531",
    color2: "#b59f82",
    shape: "simplex",
    type: "4x4",
    pxSize: 2
  }
};
var warpPreset2 = {
  name: "Warp",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    color1: "#2f6e83",
    color2: "#dceae8",
    shape: "warp",
    type: "4x4",
    pxSize: 2
  }
};
var sinePreset = {
  name: "Sine Wave",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    color1: "#730d54",
    color2: "#00becc",
    shape: "wave",
    type: "4x4",
    pxSize: 11
  }
};
var bugsPreset = {
  name: "Bugs",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    color1: "#000000",
    color2: "#008000",
    shape: "dots",
    type: "random",
    pxSize: 9
  }
};
var ripplePreset = {
  name: "Ripple",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    color1: "#603520",
    color2: "#c67953",
    shape: "ripple",
    type: "2x2",
    pxSize: 3
  }
};
var swirlPreset2 = {
  name: "Swirl",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    color1: "#000000",
    color2: "#263740",
    shape: "swirl",
    type: "8x8",
    pxSize: 2
  }
};
var spherePreset = {
  name: "Sphere",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    color1: "#301c2a",
    color2: "#366341",
    shape: "sphere",
    type: "4x4",
    pxSize: 2.5
  }
};
var ditheringPresets = [
  defaultPreset15,
  spherePreset,
  sinePreset,
  warpPreset2,
  ripplePreset,
  bugsPreset,
  swirlPreset2
];
var Dithering = (0, import_react16.memo)(function DitheringImpl({
  // Own props
  speed = defaultPreset15.params.speed,
  frame = defaultPreset15.params.frame,
  color1 = defaultPreset15.params.color1,
  color2 = defaultPreset15.params.color2,
  shape = defaultPreset15.params.shape,
  type = defaultPreset15.params.type,
  pxSize = defaultPreset15.params.pxSize,
  // Sizing props
  fit = defaultPreset15.params.fit,
  scale = defaultPreset15.params.scale,
  rotation = defaultPreset15.params.rotation,
  originX = defaultPreset15.params.originX,
  originY = defaultPreset15.params.originY,
  offsetX = defaultPreset15.params.offsetX,
  offsetY = defaultPreset15.params.offsetY,
  worldWidth = defaultPreset15.params.worldWidth,
  worldHeight = defaultPreset15.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_color1: getShaderColorFromString(color1),
    u_color2: getShaderColorFromString(color2),
    u_shape: DitheringShapes[shape],
    u_type: DitheringTypes[type],
    u_pxSize: pxSize,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime16.jsx)(ShaderMount2, { ...props, speed, frame, fragmentShader: ditheringFragmentShader, uniforms });
});

// node_modules/@paper-design/shaders-react/dist/shaders/grain-gradient.js
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var defaultPreset16 = {
  name: "Default",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    colors: ["#000a0f", "#c4730b", "#bdad5f", "#d8ccc7"],
    softness: 0.7,
    intensity: 0.15,
    noise: 0.5,
    shape: "wave"
  }
};
var dotsPreset = {
  name: "Dots",
  params: {
    ...defaultPatternSizing,
    scale: 0.6,
    speed: 1,
    frame: 0,
    colors: ["#0a0000", "#6f0000", "#0080ff", "#f2ebc9"],
    softness: 0.75,
    intensity: 0.15,
    noise: 0.7,
    shape: "dots"
  }
};
var truchetPreset = {
  name: "Truchet",
  params: {
    ...defaultPatternSizing,
    speed: 1,
    frame: 0,
    colors: ["#0a0000", "#6f2200", "#eabb7c", "#39b523"],
    softness: 0,
    intensity: 0.2,
    noise: 1,
    shape: "truchet"
  }
};
var cornersPreset = {
  name: "Corners",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colors: ["#031018", "#00aeff", "#00ffcc", "#ffc800"],
    softness: 0.4,
    intensity: 0.35,
    noise: 0.35,
    shape: "corners"
  }
};
var ripplePreset2 = {
  name: "Ripple",
  params: {
    ...defaultObjectSizing,
    scale: 0.5,
    speed: 1,
    frame: 0,
    colors: ["#140a00", "#6f2d00", "#88ddae", "#2c0b1d"],
    softness: 0.5,
    intensity: 0.5,
    noise: 0.5,
    shape: "ripple"
  }
};
var blobPreset = {
  name: "Blob",
  params: {
    ...defaultObjectSizing,
    scale: 1.3,
    speed: 1,
    frame: 0,
    colors: ["#0f0e18", "#3e6172", "#a49b74", "#568c50"],
    softness: 0,
    intensity: 0.15,
    noise: 0.5,
    shape: "blob"
  }
};
var spherePreset2 = {
  name: "Sphere",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colors: ["#000319", "#0059b3", "#37f5f5", "#18c039"],
    softness: 1,
    intensity: 0.15,
    noise: 0.5,
    shape: "sphere"
  }
};
var moonPreset = {
  name: "Moon",
  params: {
    ...defaultObjectSizing,
    scale: 0.6,
    speed: 1,
    frame: 0,
    colors: ["#000000", "#000000", "#28272d", "#ffeccc"],
    softness: 1,
    intensity: 0.56,
    noise: 1,
    shape: "sphere"
  }
};
var grainGradientPresets = [
  cornersPreset,
  defaultPreset16,
  dotsPreset,
  truchetPreset,
  ripplePreset2,
  blobPreset,
  spherePreset2,
  moonPreset
];
var GrainGradient = (0, import_react17.memo)(function GrainGradientImpl({
  // Own props
  speed = defaultPreset16.params.speed,
  frame = defaultPreset16.params.frame,
  colors = defaultPreset16.params.colors,
  softness = defaultPreset16.params.softness,
  intensity = defaultPreset16.params.intensity,
  noise = defaultPreset16.params.noise,
  shape = defaultPreset16.params.shape,
  // Sizing props
  fit = defaultPreset16.params.fit,
  scale = defaultPreset16.params.scale,
  rotation = defaultPreset16.params.rotation,
  originX = defaultPreset16.params.originX,
  originY = defaultPreset16.params.originY,
  offsetX = defaultPreset16.params.offsetX,
  offsetY = defaultPreset16.params.offsetY,
  worldWidth = defaultPreset16.params.worldWidth,
  worldHeight = defaultPreset16.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_softness: softness,
    u_intensity: intensity,
    u_noise: noise,
    u_shape: GrainGradientShapes[shape],
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime17.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: grainGradientFragmentShader,
      uniforms
    }
  );
});

// node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var defaultPreset17 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    patternBlur: 5e-3,
    patternScale: 3,
    dispersion: 0.015,
    liquid: 0.07,
    shape: 0,
    worldWidth: 0,
    worldHeight: 0
  }
};
var liquidMetalPresets = [defaultPreset17];
var LiquidMetal = (0, import_react18.memo)(function LiquidMetalImpl({
  // Own props
  speed = defaultPreset17.params.speed,
  frame = defaultPreset17.params.frame,
  patternBlur = defaultPreset17.params.patternBlur,
  patternScale = defaultPreset17.params.patternScale,
  dispersion = defaultPreset17.params.dispersion,
  liquid = defaultPreset17.params.liquid,
  shape = defaultPreset17.params.shape,
  // Sizing props
  fit = defaultPreset17.params.fit,
  scale = defaultPreset17.params.scale,
  rotation = defaultPreset17.params.rotation,
  originX = defaultPreset17.params.originX,
  originY = defaultPreset17.params.originY,
  offsetX = defaultPreset17.params.offsetX,
  offsetY = defaultPreset17.params.offsetY,
  worldWidth = defaultPreset17.params.worldWidth,
  worldHeight = defaultPreset17.params.worldHeight,
  ...props
}) {
  const uniforms = {
    // Own uniforms
    u_patternBlur: patternBlur,
    u_patternScale: patternScale,
    u_dispersion: dispersion,
    u_liquid: liquid,
    u_shape: shape,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_scale: scale,
    u_rotation: rotation,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime18.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: liquidMetalFragmentShader,
      uniforms
    }
  );
}, colorPropsAreEqual);

// node_modules/@paper-design/shaders-react/dist/shaders/pulsing-border.js
var import_react19 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var defaultPreset18 = {
  name: "Default",
  params: {
    ...defaultObjectSizing,
    scale: 0.7,
    speed: 1,
    frame: 0,
    colorBack: "#000000",
    colors: ["#f2244f", "#4da6e6"],
    roundness: 0.5,
    thickness: 0.02,
    softness: 0.5,
    intensity: 2.4,
    spotsPerColor: 4,
    spotSize: 0.15,
    pulse: 0,
    smoke: 1,
    smokeSize: 1.3
  }
};
var circlePreset = {
  name: "Circle",
  params: {
    ...defaultObjectSizing,
    worldWidth: 200,
    worldHeight: 200,
    scale: 0.5,
    speed: 1,
    frame: 0,
    colorBack: "#0f191f",
    colors: ["#ffdd33", "#ff8c00", "#ff002b"],
    roundness: 1,
    thickness: 0.03,
    softness: 0.2,
    intensity: 2,
    spotsPerColor: 4,
    spotSize: 0.15,
    pulse: 0,
    smoke: 0,
    smokeSize: 1
  }
};
var innerBorderPreset = {
  name: "Inner Border",
  params: {
    ...defaultObjectSizing,
    speed: 1,
    frame: 0,
    colorBack: "#181821",
    colors: ["#f5ad2b", "#2294d9", "#bf00ff"],
    roundness: 0,
    thickness: 0,
    softness: 0.4,
    intensity: 0,
    spotsPerColor: 3,
    spotSize: 0.18,
    pulse: 0.04,
    smoke: 0.75,
    smokeSize: 0.92
  }
};
var pulsingBorderPresets = [defaultPreset18, circlePreset, innerBorderPreset];
var PulsingBorder = (0, import_react19.memo)(function PulsingBorderImpl({
  // Own props
  speed = defaultPreset18.params.speed,
  frame = defaultPreset18.params.frame,
  colors = defaultPreset18.params.colors,
  colorBack = defaultPreset18.params.colorBack,
  roundness = defaultPreset18.params.roundness,
  thickness = defaultPreset18.params.thickness,
  softness = defaultPreset18.params.softness,
  intensity = defaultPreset18.params.intensity,
  spotsPerColor = defaultPreset18.params.spotsPerColor,
  spotSize = defaultPreset18.params.spotSize,
  pulse = defaultPreset18.params.pulse,
  smoke = defaultPreset18.params.smoke,
  smokeSize = defaultPreset18.params.smokeSize,
  // Sizing props
  fit = defaultPreset18.params.fit,
  rotation = defaultPreset18.params.rotation,
  scale = defaultPreset18.params.scale,
  originX = defaultPreset18.params.originX,
  originY = defaultPreset18.params.originY,
  offsetX = defaultPreset18.params.offsetX,
  offsetY = defaultPreset18.params.offsetY,
  worldWidth = defaultPreset18.params.worldWidth,
  worldHeight = defaultPreset18.params.worldHeight,
  ...props
}) {
  const noiseTexture = typeof window !== "undefined" && { u_noiseTexture: getShaderNoiseTexture(0) };
  const pulseTexture = typeof window !== "undefined" && { u_pulseTexture: getShaderNoiseTexture(1) };
  const uniforms = {
    // Own uniforms
    u_colorBack: getShaderColorFromString(colorBack),
    u_colors: colors.map(getShaderColorFromString),
    u_colorsCount: colors.length,
    u_roundness: roundness,
    u_thickness: thickness,
    u_softness: softness,
    u_intensity: intensity,
    u_spotsPerColor: spotsPerColor,
    u_spotSize: spotSize,
    u_pulse: pulse,
    u_smoke: smoke,
    u_smokeSize: smokeSize,
    ...pulseTexture,
    ...noiseTexture,
    // Sizing uniforms
    u_fit: ShaderFitOptions[fit],
    u_rotation: rotation,
    u_scale: scale,
    u_offsetX: offsetX,
    u_offsetY: offsetY,
    u_originX: originX,
    u_originY: originY,
    u_worldWidth: worldWidth,
    u_worldHeight: worldHeight
  };
  return (0, import_jsx_runtime19.jsx)(
    ShaderMount2,
    {
      ...props,
      speed,
      frame,
      fragmentShader: pulsingBorderFragmentShader,
      uniforms
    }
  );
}, colorPropsAreEqual);
export {
  Dithering,
  DotGrid,
  DotOrbit,
  GodRays,
  GrainGradient,
  LiquidMetal,
  MeshGradient,
  Metaballs,
  NeuroNoise,
  PerlinNoise,
  PulsingBorder,
  ShaderMount2 as ShaderMount,
  SimplexNoise,
  SmokeRing,
  Spiral,
  Swirl,
  Voronoi,
  Warp,
  Waves,
  ditheringPresets,
  dotGridPresets,
  dotOrbitMeta,
  dotOrbitPresets,
  getShaderColorFromString,
  godRaysMeta,
  godRaysPresets,
  grainGradientMeta,
  grainGradientPresets,
  isPaperShaderElement,
  liquidMetalPresets,
  meshGradientMeta,
  meshGradientPresets,
  metaballsMeta,
  metaballsPresets,
  neuroNoisePresets,
  perlinNoisePresets,
  pulsingBorderMeta,
  pulsingBorderPresets,
  simplexNoiseMeta,
  simplexNoisePresets,
  smokeRingMeta,
  smokeRingPresets,
  spiralPresets,
  swirlMeta,
  swirlPresets,
  voronoiMeta,
  voronoiPresets,
  warpMeta,
  warpPresets,
  wavesPresets
};
//# sourceMappingURL=@paper-design_shaders-react.js.map
